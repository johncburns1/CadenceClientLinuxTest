<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neon.Common</name>
    </assembly>
    <members>
        <member name="T:Neon.Build">
            <summary>
            Neon build constants.
            </summary>
        </member>
        <member name="F:Neon.Build.Company">
            <summary>
            The company name to use for all Neon assemblies.
            </summary>
        </member>
        <member name="F:Neon.Build.Copyright">
            <summary>
            The copyright statement to be included in all assemblies.
            </summary>
        </member>
        <member name="F:Neon.Build.ProductName">
            <summary>
            The product name.
            </summary>
        </member>
        <member name="F:Neon.Build.ProductVersion">
            <summary>
            The released product version.
            </summary>
        </member>
        <member name="F:Neon.Build.ProductLicense">
            <summary>
            The product license.
            </summary>
        </member>
        <member name="F:Neon.Build.ProductLicenseUrl">
            <summary>
            The product license URL.
            </summary>
        </member>
        <member name="F:Neon.Build.Configuration">
            <summary>
            The build configuration.
            </summary>
        </member>
        <member name="T:Neon.BuildEnvironment">
            <summary>
            Describes the build environment. 
            </summary>
        </member>
        <member name="P:Neon.BuildEnvironment.BuildMachine">
            <summary>
            Returns the build machine name.
            </summary>
        </member>
        <member name="P:Neon.BuildEnvironment.BuildRootPath">
            <summary>
            Returns the fully qualified path to the build root folder.
            </summary>
        </member>
        <member name="P:Neon.BuildEnvironment.BuildArtifactPath">
            <summary>
            Returns the fully qualified path to the build artifacts folder.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.ActionResult`1">
            <summary>
            Used to indicate that a service method uses the <c>IActionResult</c>
            pattern to return a <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type being returned.</typeparam>
        </member>
        <member name="T:Neon.CodeGen.ControllerValidationAttribute">
            <summary>
            <para>
            Used to have the <c>Neon.Xunit.XunitExtensions.ValidateController&lt;T&gt;()</c>
            method including the tagged method when validating the service controller
            against its definining interface.  This is useful for rare situations where a
            service controller inherits from another class that implements some endpoints.
            </para>
            <note>
            By default, <c>Neon.Xunit.XunitExtensions.ValidateController&lt;T&gt;()</c>
            only considers service methods implemented directly in the service controller
            during validation.
            </note>
            </summary>
        </member>
        <member name="T:Neon.CodeGen.DataModelAttribute">
            <summary>
            Used to provide the model code generator additional information
            about a specific data type.  Use of this optional because the code
            generator assumes that all types that are not specifically tagged
            by <see cref="T:Neon.CodeGen.ServiceModelAttribute"/> are data types.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.DataModelAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.DataModelAttribute.Name">
            <summary>
            <para>
            Optionally specifies the type identifier that will be used by
            generated code to identify the object type at runtime. This
            will be used when deserializing the object.
            </para>
            <para>
            This defaults to the fully qualified name of the type as it
            appears in the source assembly as it is scanned by the code 
            generator.  You may want to set this to reduce the length
            or just to customize how your data is persistedd.
            </para>
            </summary>
        </member>
        <member name="T:Neon.CodeGen.FromBodyAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by parsing the request body as JSON.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.FromBodyAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.FromBodyAttribute.Name">
            <summary>
            This is ignored.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.FromHeaderAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by parsing a request header value.
            </summary>
            <remarks>
            By default, this option will look for the HTTP header with the same
            name as the tagged endpoint parameter.  This can be overriden by setting
            the <see cref="P:Neon.CodeGen.FromHeaderAttribute.Name"/> property.
            </remarks>
        </member>
        <member name="M:Neon.CodeGen.FromHeaderAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.FromHeaderAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method property
            name when generating the client code.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.FromQueryAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by parsing a request URI query parameter.
            </summary>
            <remarks>
            By default, this option will look for the query parameter with the same
            name as the tagged endpoint parameter.  This can be overriden by setting
            the <see cref="P:Neon.CodeGen.FromQueryAttribute.Name"/> property.
            </remarks>
        </member>
        <member name="M:Neon.CodeGen.FromQueryAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies URI query parameter name.  This defaults to 
            the actual parameter name.
            </param>
        </member>
        <member name="P:Neon.CodeGen.FromQueryAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method property
            name when generating the client code.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.FromRouteAttribute">
            <summary>
            Used to indicate that a service endpoint parameter is to be obtained
            by extracting it from the URI route template.
            </summary>
            <remarks>
            By default, this option will look for the query parameter with the same
            name as the tagged endpoint parameter.  This can be overriden by setting
            the <see cref="P:Neon.CodeGen.FromRouteAttribute.Name"/> property.
            </remarks>
        </member>
        <member name="M:Neon.CodeGen.FromRouteAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies URI query parameter name.  This defaults to 
            the actual parameter name.
            </param>
        </member>
        <member name="P:Neon.CodeGen.FromRouteAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method property
            name when generating the client code.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.GeneratedClientAttribute">
            <summary>
            Used to tag generated service client classes with additional
            metadata that will be used when validatating the a generated service
            client actually matches an ASP.NET service implementation.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.GeneratedClientAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="routeTemplate">The controller's route template.</param>
        </member>
        <member name="P:Neon.CodeGen.GeneratedClientAttribute.RouteTemplate">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.GeneratedMethodAttribute">
            <summary>
            Used to tag generated service client methods with additional
            metadata that will be used when validatating the a generated service
            client actually matches an ASP.NET service implementation.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.GeneratedMethodAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.GeneratedMethodAttribute.DefinedAs">
            <summary>
            The method name from the service model definition.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.GeneratedMethodAttribute.Returns">
            <summary>
            The method result type.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.GeneratedMethodAttribute.RouteTemplate">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.GeneratedMethodAttribute.HttpMethod">
            <summary>
            The HTTP method for the endpoint.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.GeneratedParamAttribute">
            <summary>
            Used to tag generated service client method parameters with additional
            metadata that will be used when validatating the a generated service
            client actually matches an ASP.NET service implementation.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.GeneratedParamAttribute.#ctor(Neon.CodeGen.PassAs)">
            <summary>
            Constructor.
            </summary>
            <param name="passAs">Indicates how the client passes the tagged parameter to the service.</param>
        </member>
        <member name="P:Neon.CodeGen.GeneratedParamAttribute.PassAs">
            <summary>
            Indicates how the client passes the tagged parameter to the service.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.GeneratedParamAttribute.Name">
            <summary>
            Parameter name as it appears on the wire for parameters passed
            as a query, header, or route.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.HashSourceAttribute">
            <summary>
            Used to tag data model properties that should be included in the
            <see cref="M:System.Object.GetHashCode"/> computation.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HashSourceAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.HttpAttribute">
            <summary>
            Base class for the HTTP related attributes below.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.HttpAttribute.Template">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.HttpAttribute.HttpMethod">
            <summary>
            Returns the HTTP method.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.HttpAttribute.Name">
            <summary>
            Optionally overrides the tagged service endpoint method name when
            generating the client code.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.HttpAttribute.Order">
            <summary>
            <b>NOT SUPPORTED:</b> The order in which the route is to be applied.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.HttpDeleteAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>DELETE</b> method.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HttpDeleteAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.CodeGen.HttpGetAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>GET</b> method.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HttpGetAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.CodeGen.HttpHeadAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>HEAD</b> method.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HttpHeadAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.CodeGen.HttpOptionsAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>OPTIONS</b> method.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HttpOptionsAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.CodeGen.HttpPatchAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>PATCH</b> method.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HttpPatchAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.CodeGen.HttpPostAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>POST</b> method.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HttpPostAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.CodeGen.HttpPutAttribute">
            <summary>
            Used to identify a service endpoint that is triggered via the <b>PUT</b> method.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.HttpPutAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="T:Neon.CodeGen.IActionResult">
            <summary>
            Used to indicate that a service method uses the <c>IActionResult</c>
            pattern to return <c>void</c>.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.NoCodeGenAttribute">
            <summary>
            Used to indicate that a class or interface should be ignored
            during code generation.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.NoControllerValidationAttribute">
            <summary>
            Used to prevent the <c>Neon.Xunit.XunitExtensions.ValidateController&lt;T&gt;()</c>
            method from including the tagged method when validating the service controller
            against its definining interface.  This is useful for rare situations where a
            service controller implements some extra endpoints that are not covered by the
            generated client.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.PassAs">
            <summary>
            Identifies how a generated service client will pass a parameter to 
            an ASP.NET service.
            </summary>
        </member>
        <member name="F:Neon.CodeGen.PassAs.Query">
            <summary>
            Passes the parameter is passed as a URI query parameter.
            </summary>
        </member>
        <member name="F:Neon.CodeGen.PassAs.Route">
            <summary>
            Passes the parameter within the URI route template. 
            </summary>
        </member>
        <member name="F:Neon.CodeGen.PassAs.Header">
            <summary>
            Passes the parameter as an HTTP header.
            </summary>
        </member>
        <member name="F:Neon.CodeGen.PassAs.Body">
            <summary>
            Passes the parameter as the HTTP request body. 
            </summary>
        </member>
        <member name="T:Neon.CodeGen.PersistableAttribute">
            <summary>
            <para>
            Used to customize the database related code generated for the tagged
            data model interface.
            </para>
            <para>
            By default, a <c>public static string GetKey(param object[] args)</c> method
            is included in generated entity classes so that a database key for a specific
            entity can be easialy obtained.  This method simply generates a string by
            calling <see cref="M:System.Object.ToString"/> on all of arguments or using <b>"NULL"</b>
            for <c>null</c> values which each of these being separated by a single colon
            and then prepending the entire thing with the entity type.  The generated code 
            will look something like this:
            </para>
            <code lang="C#">
            public class PersonEntity : Entity&lt;Person&gt;
            {
                public static string GetKey(params object[] args)
                {
                    if (args.Length == 0)
                    {
                        throw new ArgumentException("At least one argument is expected.");
                    }
                    
                    var key = "entity-type::";
                    
                    for (int i=0; i $lt; args.Length; i++)
                    {
                        var arg = args[i];
                        
                        if (i &gt; 0)
                        {
                            key += ":";
                        }
                        
                        key += arg != null ? arg.ToString() : "NULL";
                    }
            
                    return key;
                }
                
                ...
            }
            </code>
            </summary>
        </member>
        <member name="P:Neon.CodeGen.PersistableAttribute.GetKeyArgs">
            <summary>
            This property combined with <see cref="P:Neon.CodeGen.PersistableAttribute.GetKeyString"/> is used
            to generate a <c>public static string GetKey(...)</c> method.
            See the class remarks for more information.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.PersistableAttribute.GetKeyString">
            <summary>
            This property combined with <see cref="P:Neon.CodeGen.PersistableAttribute.GetKeyArgs"/> is used
            to generate a <c>public static string GetKey(...)</c> method.
            See the class remarks for more information.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.PersistableKeyAttribute">
            <summary>
            Used to tag the property acting as the database key for an <see cref="T:Neon.Data.IRoundtripData"/>.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.RouteAttribute">
            <summary>
            Used to customize request routing at the service level.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.RouteAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="template">The optional routing template.</param>
        </member>
        <member name="P:Neon.CodeGen.RouteAttribute.Template">
            <summary>
            The route template.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.RouteAttribute.Name">
            <summary>
            The route name.
            </summary>
        </member>
        <member name="P:Neon.CodeGen.RouteAttribute.Order">
            <summary>
            <b>NOT SUPPORTED:</b> The order in which the route is to be applied.
            </summary>
        </member>
        <member name="T:Neon.CodeGen.ServiceModelAttribute">
            <summary>
            Used to indicate that an <c>interface</c> should be included when
            generating a service client class.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.ServiceModelAttribute.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies the name to be used for the generated
            service client class.  This defaults to the tagged controller
            class name with a "Controller" suffix being stripped off if
            present.
            </param>
            <param name="group">
            <para>
            Optionally specifies that the methods from this controller
            should be grouped together in a generated controller class
            composed from multiple service controllers.  Set this to the
            name to be used for the client property under which these 
            methods will be generated.
            </para>
            <note>
            <paramref name="name"/> must also be specified when <paramref name="group"/>
            is set.
            </note>
            </param>
        </member>
        <member name="P:Neon.CodeGen.ServiceModelAttribute.Name">
            <summary>
            <para>
            Returns the name to be used for the generated client class
            and for transmitting requests to the server or <c>null</c>
            if the name is to be derived from the tagged class name.
            </para>
            <note>
            The tagged controller class name will be used as the default
            name, stripping "Controller" off the end of the class name
            if present.
            </note>
            </summary>
        </member>
        <member name="P:Neon.CodeGen.ServiceModelAttribute.Group">
            <summary>
            <para>
            Optionally used to group multiple methods from different
            controllers with the same <see cref="P:Neon.CodeGen.ServiceModelAttribute.Name"/> together
            into the same generated service client class or subclass.
            </para>
            <para>
            This defaults to <c>null</c> which means that the service
            methods from the different controllers will be generated
            directly within the generated service client.  When this
            is not <c>null</c> or empty, a subclass using this name
            with "Client" appended will be generated with the methods
            from the controllers with this group name.
            </para>
            </summary>
        </member>
        <member name="T:Neon.CodeGen.TargetAttribute">
            <summary>
            Used to group data models and service definitions so that the
            class included in the generated code can filtered.
            </summary>
        </member>
        <member name="M:Neon.CodeGen.TargetAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The target name.</param>
        </member>
        <member name="P:Neon.CodeGen.TargetAttribute.Name">
            <summary>
            Returns the group name.
            </summary>
        </member>
        <member name="T:Neon.Collections.ArgDictionary">
            <summary>
            A dictionary of objects keyed by case sensitive strings.
            </summary>
        </member>
        <member name="T:Neon.Collections.Bits">
            <summary>
            Implements an efficient array of boolean values that can also
            perform bit oriented operations such as AND, OR, NOT, XOR.
            </summary>
            <remarks>
            <note>
            This class is similar to the .NET <see cref="T:System.Collections.BitArray"/> class.  The main
            difference is that this class serializes the bits to a byte array as you'd
            expect, with bit zero being the most significant bit of the first byte,
            bit one being the second significant bit, etc.  The <see cref="T:System.Collections.BitArray"/>
            class serializes the first bit to the least significant bit of the first byte.
            </note>
            <para>
            A <see cref="T:Neon.Collections.Bits" /> bitmap encodes internally as an array of 32-bit integers which
            is much more memory efficent than how the .NET Framework would encode an
            array of boolean values.  Use the <see cref="M:Neon.Collections.Bits.#ctor(System.Int32)" /> constructor to
            create a zeroed bitmap with the specified number of bits, <see cref="M:Neon.Collections.Bits.#ctor(System.Boolean[])" />
            to initialize the bitmap from a boolean array, or <see cref="M:Neon.Collections.Bits.#ctor(System.String)" />
            to create a bitmap from a string of ones and zeros, and <see cref="M:Neon.Collections.Bits.#ctor(System.Byte[],System.Int32)" />
            to load a bitmap from a byte array serialized by a previous call to <see cref="M:Neon.Collections.Bits.ToBytes" />.
            </para>
            <para>
            You can use the indexer to get/set specific bits in the bitmap.  Note that all
            indexes are zero-based.  <see cref="M:Neon.Collections.Bits.ClearRange(System.Int32,System.Int32)" /> sets the specified range of 
            bits to zero, <see cref="M:Neon.Collections.Bits.SetRange(System.Int32,System.Int32)" /> sets the specified range of bits to one,
            and <see cref="M:Neon.Collections.Bits.ClearAll" /> and <see cref="M:Neon.Collections.Bits.SetAll" /> sets all bits to the 
            appropriate value.  <see cref="M:Neon.Collections.Bits.Resize(System.Int32)" /> can be used to resize a bitmap.
            </para>
            <para>
            The class implements the following bitwise operations: <see cref="M:Neon.Collections.Bits.Not" />, <see cref="M:Neon.Collections.Bits.And(Neon.Collections.Bits)" />,
            <see cref="M:Neon.Collections.Bits.Or(Neon.Collections.Bits)" />, <see cref="M:Neon.Collections.Bits.Xor(Neon.Collections.Bits)" />, <see cref="M:Neon.Collections.Bits.ShiftLeft(System.Int32)" />, and <see cref="M:Neon.Collections.Bits.ShiftRight(System.Int32)" />.
            Note that the lengths of the two bitmaps passed to binary operations must be the same.
            </para>
            <para>
            <see cref="M:Neon.Collections.Bits.Clone" /> returns a copy of the bitmap and <see cref="M:Neon.Collections.Bits.ToArray" /> converts the
            bitmap into a boolean array.  The <see cref="P:Neon.Collections.Bits.IsAllZeros" /> and <see cref="P:Neon.Collections.Bits.IsAllOnes" /> properties
            can be used to determine if a bitmap is all zeros or ones and <see cref="M:Neon.Collections.Bits.Equals(System.Object)" /> can be
            used to determine whether two bitmaps are the same.  <see cref="M:Neon.Collections.Bits.ToString" /> renders the bitmap
            as a string of 1s and 0s.
            </para>
            <para>
            This class also defines explict casts for converting to and from a string of ones and zeros
            and also defines the bitwise <b>||</b>, <b>&amp;</b>, <b>~</b> and <b>^</b>,
            <b>&lt;&lt;</b>, and <b>&gt;&gt;</b> operators.
            </para>
            </remarks>
        </member>
        <member name="F:Neon.Collections.Bits.IntBitMask">
            <summary>
            32-bit oriented bit position masks.
            </summary>
        </member>
        <member name="F:Neon.Collections.Bits.ByteBitMasks">
            <summary>
            8-bit oriented serialization bit positions masks.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.op_Explicit(Neon.Collections.Bits)~System.String">
            <summary>
            Casts a <see cref="T:Neon.Collections.Bits" /> instance into a bit string of ones and zeros.
            </summary>
            <param name="bits">The bitmap.</param>
            <returns>The bit string.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.op_Explicit(System.String)~Neon.Collections.Bits">
            <summary>
            Casts a bit string of ones and zeros into a <see cref="T:Neon.Collections.Bits" /> bitmap.
            </summary>
            <param name="bitString">The bit string.</param>
            <returns>The bitmap.</returns>
            <exception cref="T:System.FormatException">Thrown if <paramref name="bitString"/> contains a character other than a 1 or 0.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_OnesComplement(Neon.Collections.Bits)">
            <summary>
            Returns the bitwise <b>not</b> on a bitmap.
            </summary>
            <param name="bits">The source bitmap.</param>
            <returns>The output bitmap.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.op_BitwiseAnd(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Returns the intersection of two bitmaps.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns>The intersection.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_BitwiseOr(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Returns the union of two bitmaps.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns>The union.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_ExclusiveOr(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Returns the exclusive or of two bitmaps.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns>The exclusive-or of the bits.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.op_LeftShift(Neon.Collections.Bits,System.Int32)">
            <summary>
            Left shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="input">The input bitmap.</param>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted left past position zero will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.op_RightShift(Neon.Collections.Bits,System.Int32)">
            <summary>
            Right shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="input">The input bitmap.</param>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted right past the end of the bitmap will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.op_Equality(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Determines whether two bitmaps contain the same values.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns><c>true</c> if the bitmaps are the same.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.op_Inequality(Neon.Collections.Bits,Neon.Collections.Bits)">
            <summary>
            Determines whether two bitmaps do not contain the same values.
            </summary>
            <param name="b1">The first bitmap.</param>
            <param name="b2">The second bitmap.</param>
            <returns><c>true</c> if the bitmaps are the same.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Int32)">
            <summary>
            Constructs a zeroed bitmap of a specified length.
            </summary>
            <param name="length">The bitmap length.</param>
            <exception cref="T:System.ArgumentException">Thrown is <paramref name="length" /> is negative.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Boolean[])">
            <summary>
            Constructs a bitmap from a boolean array.
            </summary>
            <param name="array">The array.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="array" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.String)">
            <summary>
            Constructs a bitmap by parsing a string of 1s and 0s.
            </summary>
            <param name="bitString">The bit string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="bitString" /> is <c>null</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if <paramref name="bitString"/> contains a character other than a 1 or 0.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Byte[])">
            <summary>
            Constructs a bitmap from a an array of bytes.
            </summary>
            <param name="bytes">The byte array.</param>
            <remarks>
            This constructor is useful for deserializing bitmaps persisted to a binary structure.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="bytes" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.#ctor(System.Byte[],System.Int32)">
            <summary>
            Constructs a bitmap from a specified number of bits from an array of bytes.
            </summary>
            <param name="bytes">The byte array.</param>
            <param name="length">
            Specifies length of the bitmap to be created.
            </param>
            <remarks>
            This constructor is useful for deserializing bitmaps persisted to a binary structure.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="bytes" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown is <paramref name="length" /> is negative.</exception>
            <remarks>
            <note>
            The byte array may be larger or smaller than the implied number of bits
            as compared to the <paramref name="length" /> parameter.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Collections.Bits.Length">
            <summary>
            Returns the length of the bitmap.
            </summary>
        </member>
        <member name="P:Neon.Collections.Bits.Item(System.Int32)">
            <summary>
            Gets or sets a bit in the bitmap.
            </summary>
            <param name="index">The zero-based index of the bit.</param>
            <returns>The bit value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throw if the <paramref name="index" /> is not in range.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.ClearRange(System.Int32,System.Int32)">
            <summary>
            Zeros a number of bits starting at an index.
            </summary>
            <param name="index">The start index.</param>
            <param name="count">Number of bits.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the <paramref name="index"/> or <paramref name="count"/> is out of range.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.ClearAll">
            <summary>
            Zeros all bits.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.SetRange(System.Int32,System.Int32)">
            <summary>
            Sets a number of bits starting at an index.
            </summary>
            <param name="index">The start index.</param>
            <param name="count">Number of bits.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the <paramref name="index"/> or <paramref name="count"/> is out of range.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.SetAll">
            <summary>
            Sets all bits.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.Resize(System.Int32)">
            <summary>
            Creates a new bitmap from the current instance, but resized to contain
            the specified number of bits.
            </summary>
            <param name="length">The length desired for the new bitmap.</param>
            <returns>The resized bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="length" /> is negative.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.Not">
            <summary>
            Returns a bitmap that inverts all the bits of the current bitmap.
            </summary>
            <returns>The inverted <see cref="T:Neon.Collections.Bits" />.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.And(Neon.Collections.Bits)">
            <summary>
            Performs a bitwise <b>and</b> on the <paramref name="bits"/> passed and the
            current bits and returns the result.
            </summary>
            <param name="bits">The source <see cref="T:Neon.Collections.Bits" />.</param>
            <returns>A new <see cref="T:Neon.Collections.Bits" /> instance with the intersection.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.Or(Neon.Collections.Bits)">
            <summary>
            Performs a bitwise <b>or</b> on the <paramref name="bits"/> passed and the
            current bits and returns the result.
            </summary>
            <param name="bits">The source <see cref="T:Neon.Collections.Bits" />.</param>
            <returns>A new <see cref="T:Neon.Collections.Bits" /> instance with the union.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.Xor(Neon.Collections.Bits)">
            <summary>
            Performs a bitwise <b>xor</b> on the <paramref name="bits"/> passed and the
            current bits and returns the result.
            </summary>
            <param name="bits">The source <see cref="T:Neon.Collections.Bits" />.</param>
            <returns>A new <see cref="T:Neon.Collections.Bits" /> instance with the exclusive or results.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the source bitmaps don't have the same length.</exception>
        </member>
        <member name="M:Neon.Collections.Bits.ShiftLeft(System.Int32)">
            <summary>
            Left shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted left past position zero will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.ShiftRight(System.Int32)">
            <summary>
            Right shifts a bitmap by a number of positions and returns the result.
            </summary>
            <param name="count">The number of positions to shift.</param>
            <returns>The shifted bitmap.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="count" /> is less than zero.</exception>
            <remarks>
            <note>
            Any bits shifted right past the end of the bitmap will be lost.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.Clone">
            <summary>
            Returns a clone of the bitmap.
            </summary>
            <returns>The cloned copy.</returns>
        </member>
        <member name="P:Neon.Collections.Bits.IsAllZeros">
            <summary>
            Returns <c>true</c> if all of the bits are set to zeros.
            </summary>
        </member>
        <member name="P:Neon.Collections.Bits.IsAllOnes">
            <summary>
            Returns <c>true</c> if all of the bits are set to ones.
            </summary>
        </member>
        <member name="M:Neon.Collections.Bits.Equals(System.Object)">
            <summary>
            Determines if the bitmap passed is equal to the current bitmap.
            </summary>
            <param name="obj">The instance to be compared.</param>
            <returns></returns>
        </member>
        <member name="M:Neon.Collections.Bits.GetHashCode">
            <summary>
            Computes a hash code for the instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.ToArray">
            <summary>
            Converts the bitmap into a boolean array.
            </summary>
            <returns>The boolean array.</returns>
        </member>
        <member name="M:Neon.Collections.Bits.ToBytes">
            <summary>
            Converts the bitmap into an array of bytes.
            </summary>
            <returns>The byte array.</returns>
            <remarks>
            This method is useful for serializing bitmaps for storage in a binary structure.
            </remarks>
        </member>
        <member name="M:Neon.Collections.Bits.ToString">
            <summary>
            Renders the bitmap as a string of ones and zeros.
            </summary>
            <returns>The bitmap string.</returns>
        </member>
        <member name="T:Neon.Collections.NiceDictionary`2">
            <summary>
            A dictionary of values where the indexer will return the default value
            for keys that don't map to an item.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="P:Neon.Collections.NiceDictionary`2.Item(`0)">
            <summary>
            Accesses the value associated with a specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>
            The associated value or the <c>default</c> value for the
            type when there's no associated value.
            </returns>
        </member>
        <member name="T:Neon.Common.Block">
            <summary>
            Used to reference a block in a <see cref="T:Neon.Common.BlockArray"/> or <see cref="T:Neon.IO.BlockStream"/>.
            </summary>
        </member>
        <member name="M:Neon.Common.Block.op_Explicit(System.ArraySegment{System.Byte})~Neon.Common.Block">
            <summary>
            Explict cast from a <see cref="T:System.Byte" /> <see cref="T:System.ArraySegment`1" /> to a <see cref="T:Neon.Common.Block" />.
            </summary>
            <param name="segment">The array segment to be converted.</param>
            <returns>The equivalent <see cref="T:Neon.Common.Block" />.</returns>
        </member>
        <member name="M:Neon.Common.Block.op_Explicit(Neon.Common.Block)~System.ArraySegment{System.Byte}">
            <summary>
            Explict cast from a <see cref="T:Neon.Common.Block" /> to a <see cref="T:System.Byte" /> <see cref="T:System.ArraySegment`1" />
            </summary>
            <param name="block">The <see cref="T:Neon.Common.Block" /> to be converted.</param>
            <returns>The equivalent <see cref="T:System.ArraySegment`1" />.</returns>
        </member>
        <member name="M:Neon.Common.Block.Assemble(Neon.Common.Block[])">
            <summary>
            Assembles the bytes referenced by the blocks into a contiguous buffer.
            </summary>
            <param name="blocks">The blocks.</param>
            <returns>A contiguous buffer.</returns>
        </member>
        <member name="M:Neon.Common.Block.#ctor(System.Byte[])">
            <summary>
            Constructs a block.
            </summary>
            <param name="buffer">The byte buffer.</param>
        </member>
        <member name="M:Neon.Common.Block.#ctor(System.Int32)">
            <summary>
            Allocates a block to a newly allocated buffer of the
            specified size.
            </summary>
            <param name="size">The new block size in bytes.</param>
        </member>
        <member name="M:Neon.Common.Block.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructs a block.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">Offset of the first referenced byte.</param>
            <param name="length">Byte length of the reference.</param>
        </member>
        <member name="P:Neon.Common.Block.Buffer">
            <summary>
            The referenced buffer.
            </summary>
        </member>
        <member name="P:Neon.Common.Block.Offset">
            <summary>
            The offset of the starting position of the referenced bytes in the buffer.
            </summary>
        </member>
        <member name="P:Neon.Common.Block.Length">
            <summary>
            The number of referenced bytes.
            </summary>
        </member>
        <member name="M:Neon.Common.Block.SetRange(System.Int32,System.Int32)">
            <summary>
            Modifies the range of bytes referenced by the instance.
            </summary>
            <param name="offset">Index of the first referenced byte.</param>
            <param name="length">Number of bytes referenced.</param>
        </member>
        <member name="P:Neon.Common.Block.Item(System.Int32)">
            <summary>
            Accesses the byte at the specified index in the block.
            </summary>
        </member>
        <member name="M:Neon.Common.Block.CopyTo(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from the logical offset in the block
            to the target byte array.
            </summary>
            <param name="sourceOffset">Logical offset of the first byte to copy.</param>
            <param name="target">The output byte array.</param>
            <param name="targetOffset">Target offset where the first byte is to be written.</param>
            <param name="length"></param>
        </member>
        <member name="M:Neon.Common.Block.CopyFrom(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies bytes from the byte array passed into the block.
            </summary>
            <param name="source">The source byte array.</param>
            <param name="sourceOffset">Offset of the first byte to copy from the source array.</param>
            <param name="targetOffset">Logical offset of the first target byte in the block.</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="T:Neon.Common.BlockArray">
            <summary>
            Implements an array of <see cref="T:Neon.Common.Block"/> instances.
            </summary>
            <remarks>
            <para>
            The purpose of <see cref="T:Neon.Common.BlockArray"/> is to avoid performance robbing 
            buffer reallocations and copies and large obvject heap applications as can happen 
            with extensive use of the <see cref="T:System.IO.MemoryStream"/> class.  Rather than doing I/O
            to a single large buffer, the <see cref="T:Neon.Common.BlockArray"/> provides the underlying
            functionality for spreading I/O across multiple blocks.  This avoids any need
            to reallocate and copy a large buffer as the stream grows an also
            tends to allocate consistently sized memory blocks, making life
            easier for the memory allocator.
            </para>
            <para>
            This class is pretty flexible.  Blocks can be explicitly added and
            removed from the class or the <see cref="M:Neon.Common.BlockArray.ExtendTo(System.Int32)" />, 
            <see cref="M:Neon.Common.BlockArray.TruncateTo(System.Int32)" />, or <see cref="M:Neon.Common.BlockArray.SetExactSize(System.Int32)" />
            methods can be used have the class handle block management.
            </para>
            <para>
            The <see cref="P:Neon.Common.BlockArray.BlockSize" /> and <see cref="P:Neon.Common.BlockArray.BlockOffset" />
            properties are used by the internal block management methods when allocating 
            new blocks.  <see cref="P:Neon.Common.BlockArray.BlockSize" /> defaults to 512 and specifies 
            the size of new blocks.  <see cref="P:Neon.Common.BlockArray.BlockOffset" />
            defaults to 0.  New blocks will have their <see cref="P:Neon.Common.Block.Offset" /> field set to
            <see cref="P:Neon.Common.BlockArray.BlockOffset" />.
            </para>
            <para>
            BlockOffset provides for some tricky performance optimizations.
            A common situation in network protocols is the need to fragment
            serialized data across multiple data packets with fixed sized
            headers.  Setting BlockOffset to the size of the fixed header
            will reserve these bytes at the beginning of each block.  The
            data can be serialized into the array and then afterwards, the
            headers can be written manually into each block.  This technique
            can avoid lots of buffer copying.
            </para>
            <para>
            <note>
            You should call <see cref="M:Neon.Common.BlockArray.Reload" /> after 
            directly modifying the <see cref="P:Neon.Common.Block.Length" /> or <see cref="P:Neon.Common.Block.Offset" />
            properties of any of the blocks in the array.  It is not necessary 
            to call this for changes to the Block.Buffer 
            array.
            </note>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.op_Implicit(Neon.Common.Block[])~Neon.Common.BlockArray">
            <summary>
            Implicit cast from and array of Blocks into a BlockArray.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor">
            <summary>
            Constructs an empty list.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Int32)">
            <summary>
            Constructs an array with the specified capacity.
            </summary>
            <param name="capacity">The capacity in bytes.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an array with the specified capacity and block size.
            </summary>
            <param name="capacity">The capacity in bytes.</param>
            <param name="blockSize">Size of blocks added when extending the array.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an array with the specified capacity, block size, and block offset.
            </summary>
            <param name="capacity">The capacity in bytes.</param>
            <param name="blockSize">Size of blocks added when extending the array.</param>
            <param name="blockOffset">Bytes to be reserved at the beginning of each new block.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(Neon.Common.Block[])">
            <summary>
            Constructs an array from the blocks passed.
            </summary>
            <param name="blocks">The blocks.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.#ctor(System.Byte[])">
            <summary>
            Constructs a block array from a buffer.
            </summary>
            <param name="buffer">The buffer to append.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.ClearPos">
            <summary>
            Clears the cached position related fields.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.Reload">
            <summary>
            Reloads cached information about the blocks in the array.
            </summary>
            <remarks>
            This should be called after making changes to the Length
            property of any blocks in the array.
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.CalcPos(System.Int32)">
            <summary>
            Calculates the block and position of the specified logically indexed
            byte in the block.
            </summary>
            <param name="index">The logical index.</param>
            <remarks>
            The method updates the lastIndex, lastBlock, lastBlockIndex, 
            and lastBlockPos with the calculated values.
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.Reset">
            <summary>
            Used internally by unit tests to reset any internal positional
            optimization information maintained by the class.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(System.Byte[])">
            <summary>
            Appends a block formed by a buffer to the array.
            </summary>
            <param name="buffer">The buffer to add.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(Neon.Common.Block)">
            <summary>
            Appends a block to end of the array.
            </summary>
            <param name="block">The new block.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(Neon.Common.BlockArray)">
            <summary>
            Appends all blocks from a block array to this array.
            </summary>
            <param name="blocks">The source array.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.Append(Neon.Common.BlockArray,System.Int32,System.Int32)">
            <summary>
            Appends blocks from a block array to this array.
            </summary>
            <param name="blocks">The source array.</param>
            <param name="index">Index of the first block to append.</param>
            <param name="count">Number of blocks to append.</param>
        </member>
        <member name="P:Neon.Common.BlockArray.BlockOffset">
            <summary>
            The default offset to use when adding new blocks to the array.
            </summary>
        </member>
        <member name="P:Neon.Common.BlockArray.BlockSize">
            <summary>
            The size of new blocks added when extending the array.
            </summary>
        </member>
        <member name="P:Neon.Common.BlockArray.Count">
            <summary>
            Returns the number of blocks in the list.
            </summary>
        </member>
        <member name="P:Neon.Common.BlockArray.Size">
            <summary>
            Returns the total size of all the blocks in bytes.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.ExtendTo(System.Int32)">
            <summary>
            Adds blocks to the array as necessary to ensure that the total size
            of these blocks is at least equal to the value passed.
            </summary>
            <param name="capacity">The minimum requested capacity in bytes.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.TruncateTo(System.Int32)">
            <summary>
            Removes blocks from the and of the array array such that only 
            those blocks necessary to achieve the specified capacity remain.
            </summary>
            <param name="capacity">The desired capacity in bytes.</param>
            <remarks>
            The method does nothing if the requested capacity is larger
            than the current size of the blocks.
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.SetExactSize(System.Int32)">
            <summary>
            Adjusts the blocks in the array such that their sizes
            total exactly to the value passed.
            </summary>
            <param name="capacity">The desired size.</param>
            <remarks>
            The method removes or appends blocks onto the end of the
            array to reach the desired size.  The method will also
            adjust the length of the final block if necessary.
            </remarks>
        </member>
        <member name="P:Neon.Common.BlockArray.Item(System.Int32)">
            <summary>
            Accesses the indexed byte in the logical array formed by
            concatentating all of the blocks.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.CopyTo(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from the logical offset in the blocks to the target byte array.
            </summary>
            <param name="sourceOffset">Logical offset of the first byte to copy.</param>
            <param name="target">The output byte array.</param>
            <param name="targetOffset">Target offset where the first byte is to be written.</param>
            <param name="length"></param>
        </member>
        <member name="M:Neon.Common.BlockArray.CopyFrom(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies bytes from the byte array passed into the blocks.
            </summary>
            <param name="source">The source byte array.</param>
            <param name="sourceOffset">Offset of the first byte to copy from the source array.</param>
            <param name="targetOffset">Logical offset of the first target byte in the buffer references.</param>
            <param name="length">Number of bytes to copy.</param>
        </member>
        <member name="M:Neon.Common.BlockArray.ToByteArray">
            <summary>
            Assembles the blocks referenced by the array into a contiguous
            byte array.
            </summary>
            <returns>A contiguous byte array.</returns>
        </member>
        <member name="M:Neon.Common.BlockArray.GetBlocks">
            <summary>
            Returns an array to the underlying blocks.
            </summary>
        </member>
        <member name="M:Neon.Common.BlockArray.GetBlock(System.Int32)">
            <summary>
            Returns the indexed block in the list.
            </summary>
            <param name="index">The index (0..Count-1).</param>
            <returns>The block.</returns>
        </member>
        <member name="M:Neon.Common.BlockArray.Extract(System.Int32,System.Int32)">
            <summary>
            Extracts a range of bytes from the array into newly
            created block array.
            </summary>
            <param name="index">Logical index of the first byte.</param>
            <param name="length">Number of bytes to extract.</param>
            <returns>A new block array referencing the bytes.</returns>
            <remarks>
            <note>
            Although this method does create a new BlockArray
            and Block objects, it does not copy the underlying buffers.
            Instead, it adjusts the new Block objects to reference the
            requested portions of the original underlying buffers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.Extract(System.Int32)">
            <summary>
            Extracts a range of bytes from the array from the specified
            index to the end of the array into newly created block array.
            </summary>
            <param name="index">Logical index of the first byte.</param>
            <returns>A new block array referencing the bytes.</returns>
            <remarks>
            <note>
            Although this method does create a new BlockArray
            and Block objects, it does not copy the underlying buffers.
            Instead, it adjusts the new Block objects to reference the
            requested portions of the original underlying buffers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.BlockArray.Clone">
            <summary>
            Returns a shallow copy of the block array.
            </summary>
            <returns>The cloned array.</returns>
            <remarks>
            A new set of Block objects will be returned but they
            will point to the same underlying buffers.
            </remarks>
        </member>
        <member name="T:Neon.Common.CommandLine">
            <summary>
            Performs common operations on application a DOS or Linux command line.
            </summary>
            <remarks>
            <para>
            Command lines may consist of zero or more items.  Items that begin with
            the dash (-) character are considered to be command line options.  Items that
            begin with an at sign (@) can be considered to be response files, and all
            other items are considered to be command line arguments.
            </para>
            <note>
            The "<b>-</b>" and "<b>--</b>" items (without an option name are considered 
            arguments, not options.
            </note>
            <para>
            The static <see cref="M:Neon.Common.CommandLine.ExpandFiles(System.String[])" /> method can be used to process
            response files specified in a command line.  Response files
            are specified by prepending a '@' character to the name of a text
            file and then treating each line of the file as a command line item.
            </para>
            <para>
            The static <see cref="M:Neon.Common.CommandLine.ExpandWildcards(System.String)" /> method can be used to 
            expand file names with wildcard characters into the set of actual 
            files that match the pattern.
            </para>
            <para>
            The <see cref="T:Neon.Common.CommandLine" /> class can also handles parsing of items
            as command line options.
            </para>
            <code language="none">
            
                -&lt;option name&gt;[=&lt;value&gt;]
            
            </code>
            <para>
            will be parsed into name/value pairs and will be available for
            lookup via the string keyed indexer.  Options that specify no
            value will be assigned an empty string value.
            </para>
            <note>
            Command line option names are case sensitive.
            </note>
            <para>
            The class will also make all command line items available via the
            integer keyed indexer which will return items based on
            their position on the command line and also via the <see cref="P:Neon.Common.CommandLine.Items" />
            property.  Command line items that are not command, are available via
            the <see cref="P:Neon.Common.CommandLine.Arguments" /> property.  Options can be looked up via 
            the <see cref="M:Neon.Common.CommandLine.GetOption(System.String,System.String)"/> and <see cref="M:Neon.Common.CommandLine.GetOptionValues(System.String)"/>
            overrides.
            </para>
            <para>
            <see cref="T:Neon.Common.CommandLine"/> also supports the definition of long and
            short forms of options with optional default values using the
            <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/> method.  This associates one or more
            option names with an optional default value.
            </para>
            <para>
            You can use this easily implement the short and long forms 
            of options as well as to centralize the specification of 
            option default values.
            </para>
            <code language="C#">
            var commandLine = new CommandLine(args);
            
            commandLine.DefineOption("-q", "--quiet");
            commandLine.DefineOption("-k", "--key").Default = "none";
            
            // These calls both return the option value for "-q" or "--quiet".
            // Since no default value was set, the default value will be the
            // empty string.
            
            commandLine.GetOption("-q");
            commandLine.GetOption("--quiet");
            
            // These calls both return the option value for "-k" or "--key".
            // The default value will be "none".
            
            commandLine.GetOption("-k");
            commandLine.GetOption("--key");
            </code>
            <note>
            This class assumes that the position of command line options doesn't
            matter, which is somewhat simplistic.  In particular, the <see cref="M:Neon.Common.CommandLine.Shift(System.Int32,System.String)"/> 
            method actually relocates all of the options to the beginning of the 
            shifted command line.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Common.CommandLine.OptionDefinition">
            <summary>
            Associates one or more option names with a default value.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.OptionDefinition.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Constructor.
            </summary>
            <param name="names">The associated option names.</param>
        </member>
        <member name="P:Neon.Common.CommandLine.OptionDefinition.Names">
            <summary>
            Returns the array of associated option names.
            </summary>
        </member>
        <member name="P:Neon.Common.CommandLine.OptionDefinition.Default">
            <summary>
            The option's default value or the empty string.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.Parse(System.String)">
            <summary>
            Parses the argument string passed into a <see cref="T:Neon.Common.CommandLine" />
            instance, dealing with quoted parameters, etc.
            </summary>
            <param name="input">The argument string.</param>
        </member>
        <member name="M:Neon.Common.CommandLine.ExpandFiles(System.String[])">
            <summary>
            Expands the command line by processing items beginning with '@' as input files.
            </summary>
            <returns>The set of expanded items.</returns>
            <remarks>
            <para>
            Command line items will be assumed to specify a
            text file name after the '@'.  This file will be read
            and each non-empty line of text will be inserted as a
            command line parameter.
            </para>
            <para>
            Lines of text whose first non-whitespace character is a
            pound sign (#) will be ignored as comments.
            </para>
            <para>
            Command line parameters may also span multiple lines by
            beginning the parameter with a line of text begininning with
            "{{" and finishing it with a line of text containing "}}".
            In this case, the command line parameter will be set to the
            text between the {{...}} with any CRLF sequences replaced by
            a single space.
            </para>
            <para>
            Here's an example:
            </para>
            <code language="none">
            # This is a comment and will be ignored
            
            -param1=aaa
            -param2=bbb
            {{
            -param3=hello
            world
            }}
            </code>
            <para>
            This will be parsed as three command line parameters:
            <b>-param1=aaa</b>, <b>-param2=bbb</b>, and <b>-param3=hello world</b>
            </para>
            </remarks>
            <exception cref="T:System.IO.IOException">Thrown if there's a problem opening an "@" input file.</exception>
            <exception cref="T:System.FormatException">Thrown if there's an error parsing an "@" input file.</exception>
        </member>
        <member name="M:Neon.Common.CommandLine.ExpandWildcards(System.String)">
            <summary>
            Checks the argument passed for wildcards and expands them into the
            appopriate set of matching file names.
            </summary>
            <param name="path">The file path potentially including wildcards.</param>
            <returns>The set of matching file names.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.Format(System.Object[])">
            <summary>
            Formats an array of objects into a form suitable for passing to a 
            process on the command line by adding double quotes around any values
            with embedded spaces.
            </summary>
            <param name="args">The arguments to be formatted.</param>
            <returns>the formatted string.</returns>
            <exception cref="T:System.FormatException">Thrown if any of the arguments contain double quote or any other invalid characters.</exception>
        </member>
        <member name="M:Neon.Common.CommandLine.ToStrings(System.Object[])">
            <summary>
            Converts an array of objects to an array of strings.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.#ctor(System.Object[])">
            <summary>
            Constructs an instance optionally expanding any response file specified
            in the arguments passed.
            </summary>
            <param name="args">The optional command line arguments.</param>
        </member>
        <member name="M:Neon.Common.CommandLine.DefineOption(System.String[])">
            <summary>
            Adds an option definition to the command line and returns the
            definition so its default value may be set if desired.
            </summary>
            <param name="names">The option names (e.g. the short and long form).</param>
            <returns>The <see cref="T:Neon.Common.CommandLine.OptionDefinition"/>.</returns>
            <remarks>
            <para>
            You can use this easily implement the short and long forms 
            of options as well as to centralize the specification of 
            option default values.
            </para>
            <code language="C#">
            var commandLine = new CommandLine(args);
            
            commandLine.DefineOption("-q", "--quiet");
            commandLine.DefineOption("-k", "--key").Default = "none";
            
            // These calls both return the option value for "-q" or "--quiet".
            // Since no default value was set, the default value will be the
            // empty string.
            
            commandLine.GetOption("-q");
            commandLine.GetOption("--quiet");
            
            // These calls both return the option value for "-k" or "--key".
            // The default value will be "none".
            
            commandLine.GetOption("-k");
            commandLine.GetOption("--key");
            </code>
            </remarks>
        </member>
        <member name="P:Neon.Common.CommandLine.Items">
            <summary>
            Returns the array of command line arguments (including both
            command line options and values).
            </summary>
        </member>
        <member name="P:Neon.Common.CommandLine.Arguments">
            <summary>
            Returns the array of command line values (items that are not
            command line options).
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.GetArguments(System.Int32)">
            <summary>
            Enumerates the command line arguments beginning at the specified index.
            </summary>
            <param name="startIndex">The index of the first argument to be returned.</param>
            <returns>The enumerated arguments.</returns>
        </member>
        <member name="P:Neon.Common.CommandLine.Item(System.Int32)">
            <summary>
            Returns an item from the command line based on its position.
            </summary>
            <param name="index">The zero-based position of the desired argument.</param>
            <returns>The argument string.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.GetOption(System.String,System.String)">
            <summary>
            Returns the value associated with a command line option if the option was present 
            on the command line otherwise, the specified default value will be returned.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <param name="def">The default value.</param>
            <returns>The option value if present, the specified default value otherwise.</returns>
            <remarks>
            <para>
            If the <paramref name="optionName"/> was included in a previous <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/>
            call, then all aliases for the option will be searched.  If the option is not
            present on the command line and <paramref name="def"/> is <c>null</c>, then the default
            defined default value will be returned otherwise <paramref name="def"/> will override
            the definition.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.GetFlag(System.String)">
            <summary>
            Determines whether an option is present on the command line.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <returns>The option value if present, the specified default value otherwise.</returns>
        </member>
        <member name="P:Neon.Common.CommandLine.Options">
            <summary>
            Returns the command line options as a dictionary of option name/value tuples.
            </summary>
        </member>
        <member name="M:Neon.Common.CommandLine.HasOption(System.String)">
            <summary>
            Determines if an option was present on the command line.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <returns><c>true</c> if the option is present.</returns>
            <remarks>
            <para>
            If the <paramref name="optionName"/> was included in a previous <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/>
            call, then all aliases for the option will be searched.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.GetOptionValues(System.String)">
            <summary>
            Returns all of the values a command line option that appears multiple
            times in the command.
            </summary>
            <param name="optionName">The case sensitive option name (including the leading dashes (<b>-</b>).</param>
            <returns>The array of values found sorted in the same order thney appear in the command line.</returns>
            <remarks>
            <note>
            Only command line options that actually specify a value using the
            colon (=) syntax are returned by this method.
            </note>
            <para>
            If the <paramref name="optionName"/> was included in a previous <see cref="M:Neon.Common.CommandLine.DefineOption(System.String[])"/>
            call, then all aliases for the option will be searched.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Common.CommandLine.HasHelpOption">
            <summary>
            Determines if the <b>--help</b> command line option is present.
            </summary>
            <returns><c>true</c> if the <b>--help</b> help option is present.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.Shift(System.Int32,System.String)">
            <summary>
            Returns a new <see cref="T:Neon.Common.CommandLine" /> which includes all of the command line options
            and the arguments starting at the position passed to the end of the command line,
            essentially shifting arguments to the left.
            </summary>
            <param name="position">The index of the first argument to be included in the result.</param>
            <param name="splitter">
            The optional argument used to ensure that we're only shifting the left 
            side of a command line.  This defaults to <b>"--"</b> but may be set to
            <c>null</c> or the empty string to disable this behavior.
            </param>
            <returns>The new <see cref="T:Neon.Common.CommandLine" />.</returns>
        </member>
        <member name="M:Neon.Common.CommandLine.Split(System.String,System.Boolean)">
            <summary>
            Splits the command line into two parts, the command line to the left of 
            the first specified item (defaults to <b>"--"</b>) and the command line 
            to the right of it.
            </summary>
            <param name="splitter">The split item (defaults to <b>"--"</b>).</param>
            <param name="addSplitterToRight">
            Optionally specifies that the split item should be included in the 
            right command line returned.
            </param>
            <returns>A tuple with <b>Left</b> and <b>Right</b> properties.</returns>
            <remarks>
            <note>
            The <b>Left</b> command line will return with a copy of the original option
            definitions.
            </note>
            <note>
            If there is no split item present, then <b>Right</b> will be <c>null</c>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.StartsWithArgs(System.String[])">
            <summary>
            Determines whether the command line starts with the specified arguments.
            </summary>
            <param name="args">The non-<c>null</c> argument strings.</param>
            <returns><c>true</c> if the command is prefxed with the specified arguments.</returns>
            <remarks>
            <note>
            The argument comparison is case sensitive.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.CommandLine.ToString">
            <summary>
            Renders the command line as a string suitable for presenting to a process or
            a command line shell.  Arguments that include spaces will be enclosed in 
            double quotes.
            </summary>
            <returns>The command line string.</returns>
        </member>
        <member name="T:Neon.Common.Credentials">
            <summary>
            Used to persist credentials.
            </summary>
            <remarks>
            <para>
            Two forms of credentials are currently supported: a standalone security token or
            API key or the combination of a username and password.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Common.Credentials.Token">
            <summary>
            The security token.
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.Username">
            <summary>
            The username (use in conjunction with <see cref="P:Neon.Common.Credentials.Password"/>).
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.Password">
            <summary>
            The password (use in conjunction with <see cref="P:Neon.Common.Credentials.Username"/>).
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.HasToken">
            <summary>
            Returns <c>true</c> if the credentials hold a <see cref="P:Neon.Common.Credentials.Token"/>.
            </summary>
        </member>
        <member name="P:Neon.Common.Credentials.HasUsernamePassword">
            <summary>
            Returns <c>true</c> if the credentials hold a <see cref="P:Neon.Common.Credentials.Username"/> and <see cref="P:Neon.Common.Credentials.Password"/>.
            </summary>
        </member>
        <member name="T:Neon.Common.EnvironmentParser">
            <summary>
            Handles parsing of environment variables.
            </summary>
        </member>
        <member name="T:Neon.Common.EnvironmentParser.Parser`1">
            <summary>
            Attempts to parse an environment variable as a specific type.
            </summary>
            <typeparam name="T">The output type.</typeparam>
            <param name="input">The string to be parsed.</param>
            <param name="value">Returns as the parsed value on success.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns><c>true</c> If the input was parsed successfully.</returns>
        </member>
        <member name="T:Neon.Common.EnvironmentParser.Validator`1">
            <summary>
            Validates that a parsed environment variable is valid.
            </summary>
            <typeparam name="T">The parsed variable type.</typeparam>
            <param name="input">The input value.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.StringParser(System.String,System.String@,System.String@)">
            <summary>
            Parses a <see cref="T:System.String"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.IntParser(System.String,System.Int32@,System.String@)">
            <summary>
            Parses an <see cref="T:System.Int32"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.DoubleParser(System.String,System.Double@,System.String@)">
            <summary>
            Parses a <see cref="T:System.Double"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.BoolParser(System.String,System.Boolean@,System.String@)">
            <summary>
            Parses a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.TimeSpanParser(System.String,System.TimeSpan@,System.String@)">
            <summary>
            Parses a <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="input">The input value.</param>
            <param name="value">Returns as the parsed value.</param>
            <param name="error">Returns as the error message on failure.</param>
            <returns>Returns <c>true</c> if the input value is valid.</returns>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.#ctor(Neon.Diagnostics.INeonLogger)">
            <summary>
            Constructor.
            </summary>
            <param name="log">The optional logger.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogMissingVariable(System.String)">
            <summary>
            Reports a missing environment variable.
            </summary>
            <param name="variable">The variable name.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogUnparsableVariable(System.String,System.String,System.Object)">
            <summary>
            Reports a non-parsable environment variable.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="value">The invalid variable value.</param>
            <param name="def">The value actually used instead.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogInvalidVariable(System.String,System.String,System.String)">
            <summary>
            Reports an invalid environment variable.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="value">The invalid variable value.</param>
            <param name="error">Specifies an optional error message.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogInvalidVariable(System.String,System.String,System.Object,System.String)">
            <summary>
            Reports an invalid environment variable.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="value">The invalid variable value.</param>
            <param name="def">The value actually used instead.</param>
            <param name="error">Specifies an optional error message.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.LogVariable(System.String,System.String)">
            <summary>
            Reports an environment variable value.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="value">The invalid variable value.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.ThrowNotFound(System.String)">
            <summary>
            Throws a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> for an environment variable.
            </summary>
            <param name="variable">The variable name.</param>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Parse``1(System.String,System.String,Neon.Common.EnvironmentParser.Parser{``0},System.Boolean,Neon.Common.EnvironmentParser.Validator{``0})">
            <summary>
            Attempts to parse an environment variable as a <typeparamref name="T"/>, writting 
            messages to the associated logger if one was passed to the constructor.
            </summary>
            <typeparam name="T">The parsed output type.</typeparam>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="parser">The parser function.</param>
            <param name="validator">Optional validation function.</param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.String,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.String})">
            <summary>
            Attempts to parse an environment variable as a <see cref="T:System.String"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.Int32,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.Int32})">
            <summary>
            Attempts to parse an environment variable as an <see cref="T:System.Int32"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.Double,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.Double})">
            <summary>
            Attempts to parse an environment variable as an <see cref="T:System.Double"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.Boolean,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.Boolean})">
            <summary>
            Attempts to parse an environment variable as a <see cref="T:System.Boolean"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="M:Neon.Common.EnvironmentParser.Get(System.String,System.TimeSpan,System.Boolean,Neon.Common.EnvironmentParser.Validator{System.TimeSpan})">
            <summary>
            Attempts to parse an environment variable as a <see cref="T:System.TimeSpan"/>, writting messages
            to the associated logger if one was passed to the constructor.
            </summary>
            <param name="variable">The variable name.</param>
            <param name="defaultInput">The default value.</param>
            <param name="required">Optionally specifies that the variable is required to exist.</param>
            <param name="validator">
            Optional validation function to be called to verify that the parsed variable
            value is valid.  This should return <c>null</c> for valid values and an error
            message for invalid ones.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the variable does not exists and <paramref name="required"/>=<c>true</c>.</exception>
            <exception cref="T:System.FormatException">Thrown if the variable could not be parsed or the <paramref name="validator"/> returned an error.</exception>
        </member>
        <member name="T:Neon.Common.GlobPattern">
            <summary>
            Implements a very simple glob matcher inspired by the GitHub <c>.gitignore</c> patterns
            described <a href="https://git-scm.com/docs/gitignore">here</a>.
            </summary>
            <remarks>
            <para>
            The current implementation is somewhat limited compared to that for <c>.gitignore</c>:
            </para>
            <list type="bullet">
            <item>
            Only <b>"*"</b> and <b>"**"</b> wildcard chacacters are allowed.
            <b>"!"</b> and <b>"[..]"</b> are not recognized.
            </item>
            <item>
            <b>"*"</b> matches anything except for <b>"/"</b>.
            </item>
            <item>
            <b>"**"</b> matches zero or more directories.
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Common.GlobPattern.Parse(System.String)">
            <summary>
            Parses a <see cref="T:Neon.Common.GlobPattern"/> from a pattern string.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns>The created <see cref="T:Neon.Common.GlobPattern"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if the pattern is <c>null</c> or empty.</exception>
            <exception cref="T:System.FormatException">Thrown if the pattern is invalid.</exception>
        </member>
        <member name="M:Neon.Common.GlobPattern.TryParse(System.String,Neon.Common.GlobPattern@)">
            <summary>
            Attempts to parse a <see cref="T:Neon.Common.GlobPattern"/>.
            </summary>
            <param name="pattern">The pattern string.</param>
            <param name="globPattern">Returns as the parsed <see cref="T:Neon.Common.GlobPattern"/>.</param>
            <returns><c>true</c> if the pattern was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.GlobPattern.#ctor(System.String)">
            <summary>
            Private constructor.
            </summary>
            <param name="pattern">The glob pattern.</param>
        </member>
        <member name="P:Neon.Common.GlobPattern.RegexPattern">
            <summary>
            Returns the glob as a regular expression string.
            </summary>
        </member>
        <member name="P:Neon.Common.GlobPattern.Regex">
            <summary>
            Returns the <see cref="P:Neon.Common.GlobPattern.Regex"/> that can be used to match strings against the glob.
            </summary>
        </member>
        <member name="M:Neon.Common.GlobPattern.IsMatch(System.String)">
            <summary>
            Matches a string against the glob.
            </summary>
            <param name="input">The value to be matched.</param>
            <returns><c>true</c> if the parameter matches the glob.</returns>
        </member>
        <member name="M:Neon.Common.GlobPattern.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.HexDumpOption">
            <summary>
            Enumerates the option flags for the <see cref="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,System.Int32,System.Int32,Neon.Common.HexDumpOption)"/> 
            and <see cref="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,Neon.Common.HexDumpOption)"/> > methods.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.None">
            <summary>
            Enable no special formatting options.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.ShowAll">
            <summary>
            Enables all formatting options.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.ShowAnsi">
            <summary>
            Include ANSI characters after the HEX bytes on each line.
            </summary>
        </member>
        <member name="F:Neon.Common.HexDumpOption.ShowOffsets">
            <summary>
            Include the byte offset of the first byte of each line.
            </summary>
        </member>
        <member name="T:Neon.Common.IServiceContainer">
            <summary>
            <para>
            This interface combines the capabilities of <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and
            <see cref="T:System.IServiceProvider"/> to define an object that can dynamically add
            and remove service implementations.  See the default implementation 
            <see cref="T:Microsoft.Extensions.DependencyInjection.ServiceCollection"/> for more information.
            </para>
            <note>
            Implementations must be thread-safe.
            </note>
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="T:Neon.Common.NotReadyException">
            <summary>
            Indicates that a component is not ready to perform an operation but may
            become ready in the future.
            </summary>
        </member>
        <member name="M:Neon.Common.NotReadyException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.NotReadyException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs an exception with a specific message and optional inner exception.
            </summary>
            <param name="message">The custom message.</param>
            <param name="innerException">Optional inner exception.</param>
        </member>
        <member name="T:Neon.Common.ProgramExitException">
            <summary>
            Used to signal that a program or tool should exit.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramExitException.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="exitCode">The desired program exit code.</param>
        </member>
        <member name="P:Neon.Common.ProgramExitException.ExitCode">
            <summary>
            Returns the desired program exit code.
            </summary>
        </member>
        <member name="T:Neon.Common.SemanticVersion">
            <summary>
            Implements a semantic version as defined by the <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning 2.0.0</a>
            specification.  This is similar to the base <see cref="T:System.Version"/> class but includes support for pre-release identifiers
            as well as build information.
            </summary>
        </member>
        <member name="M:Neon.Common.SemanticVersion.TryParse(System.String,Neon.Common.SemanticVersion@)">
            <summary>
            Attempts to parse a semantic version string.
            </summary>
            <param name="versionText">The version text.</param>
            <param name="version">Returns as the parsed version on success.</param>
            <returns><c>true</c> if the version was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Parse(System.String)">
            <summary>
            Parses a semantic version string.
            </summary>
            <param name="versionText">The version text.</param>
            <returns>The parsed <see cref="T:Neon.Common.SemanticVersion"/>.</returns>
            <exception cref="T:System.FormatException">Thrown if the version could not be parsed.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Create(System.Int32,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Creates a semantic version number from parameters.
            </summary>
            <param name="major">The major version.</param>
            <param name="minor">Optional minor version.</param>
            <param name="patch">Optional patch version.</param>
            <param name="build">Optional build.</param>
            <param name="prerelease">Optional prerelease.</param>
            <returns>The <see cref="T:Neon.Common.SemanticVersion"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if any of the parameters are invalid.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Compare(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two non-null semantic versions.
            </summary>
            <param name="v1">The first version.</param>
            <param name="v2">The second version.</param>
            <returns>
            <b>-1</b> if <paramref name="v1"/> is less than <paramref name="v2"/><br/>
            <b>0</b> if <paramref name="v1"/> equals <paramref name="v2"/><br/>
            <b>+1</b> if <paramref name="v1"/> is greater than <paramref name="v2"/>
            </returns>
            <remarks>
            <note>
            A <c>null</c> version is considered to be less than a non-null version.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Equality(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances for equality.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> if the versions have the same precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Inequality(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances for inequality.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> if the versions have the different precedences.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_GreaterThan(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is greater.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has greater precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_GreaterThanOrEqual(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is greater or equal.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has the same or greater precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_LessThan(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is less.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has lower precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_LessThanOrEqual(Neon.Common.SemanticVersion,Neon.Common.SemanticVersion)">
            <summary>
            Compares two <see cref="T:Neon.Common.SemanticVersion"/> instances to see if the first is less or equal.
            </summary>
            <param name="v1">Version #1.</param>
            <param name="v2">Version #2.</param>
            <returns><c>true</c> <paramref name="v1"/> has the same or lower precedence.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if either parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Explicit(Neon.Common.SemanticVersion)~System.String">
            <summary>
            Explicitly casts a <see cref="T:Neon.Common.SemanticVersion"/> into a string.
            </summary>
            <param name="version">The version input.</param>
        </member>
        <member name="M:Neon.Common.SemanticVersion.op_Explicit(System.String)~Neon.Common.SemanticVersion">
            <summary>
            Explicitly casts a string into a <see cref="T:Neon.Common.SemanticVersion"/>.
            </summary>
            <param name="version">The version input.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.SemanticVersion.#ctor">
            <summary>
            Default constuctor.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Major">
            <summary>
            The major version number.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Minor">
            <summary>
            The minor version number.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Patch">
            <summary>
            The patch version number.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Prerelease">
            <summary>
            The prerelease identifer or <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Common.SemanticVersion.Build">
            <summary>
            The build information or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Common.SemanticVersion.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.SemanticVersion.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.SemanticVersion.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.SemanticVersion.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.ServiceContainer">
            <summary>
            This class combines the capabilities of a <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and
            <see cref="T:System.IServiceProvider"/> into a single object that implements the
            combined <see cref="T:Neon.Common.IServiceContainer"/> interface.
            </summary>
            <remarks>
            <para>
            The design of <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and <see cref="T:System.IServiceProvider"/> seems
            somewhat limited.  This assumes that applications explicitly initialize a <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/>
            instance during startup and then call <c>BuildServiceProvider()</c> to return the <see cref="T:System.IServiceProvider"/>
            that can actually be used to find a service at runtime.
            </para>
            <para>
            This works fine for lots of applications, but with a framework like Neon, it is
            useful to have a global service provider that allows the client to register
            default services for applications that are not coded to be aware of dependency
            injection.  The problem with the Microsoft DependencyInjection design is that
            additional services registered after a <c>BuildServiceProvider()</c> call will 
            not be returned by the service provider.
            </para>
            <para>
            This class combines both these capabilities into a single class such that 
            services can be registered and located dynamically without ever having to
            call <c>BuildServiceProvider()</c>.
            </para>
            <note>
            The <c>BuildServiceProvider()</c> extension methods still work the same and
            return only a point-in-time snapshot of the services.  You may not need to
            call these though, because you can call <see cref="M:Neon.Common.ServiceContainer.GetService(System.Type)"/> directly.
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Common.ServiceContainer.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Common.ServiceContainer.Count">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Common.ServiceContainer.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Add(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Contains(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.CopyTo(Microsoft.Extensions.DependencyInjection.ServiceDescriptor[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Insert(System.Int32,Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.Remove(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.IndexOf(Microsoft.Extensions.DependencyInjection.ServiceDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ServiceContainer.GetService(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.Stub">
            <summary>
            Used in situations where an innocous parameter is required to disambiguate
            constructor or method overloads.
            </summary>
        </member>
        <member name="T:Neon.Common.Stub.Value">
            <summary>
            An empty value structure.
            </summary>
        </member>
        <member name="F:Neon.Common.Stub.Param">
            <summary>
            Returns the stub value.
            </summary>
        </member>
        <member name="T:Neon.Common.ToolException">
            <summary>
            Typically thrown when a tool or subprocess is executed an fails.
            </summary>
        </member>
        <member name="M:Neon.Common.ToolException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The optional exception message.</param>
            <param name="inner">The optional inner exception.</param>
        </member>
        <member name="T:Neon.Common.ExecuteException">
            <summary>
            Thrown by <see cref="M:Neon.Common.ExecuteResponse.EnsureSuccess"/> if the executed command
            did not return a <b>zero</b> exit code.
            </summary>
        </member>
        <member name="M:Neon.Common.ExecuteException.#ctor(System.Int32,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="exitCode">The command exit code.</param>
            <param name="message">The error message.</param>
        </member>
        <member name="P:Neon.Common.ExecuteException.ExitCode">
            <summary>
            Returns the command exit code.
            </summary>
        </member>
        <member name="T:Neon.Common.ExecuteResponse">
            <summary>
            Holds the process exit code and captured standard output from a process
            launched by <see cref="M:Neon.Common.NeonHelper.ExecuteCapture(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.Action{System.String},System.Action{System.String})"/>.
            </summary>
        </member>
        <member name="M:Neon.Common.ExecuteResponse.#ctor">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.ExitCode">
            <summary>
            Returns the process exit code.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.OutputText">
            <summary>
            Returns the captured standard output stream text from the process.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.ErrorText">
            <summary>
            Returns the captured standard error stream text from the process.
            </summary>
        </member>
        <member name="P:Neon.Common.ExecuteResponse.AllText">
            <summary>
            Returns the captured standard output and error stream text from the process.
            </summary>
        </member>
        <member name="M:Neon.Common.ExecuteResponse.EnsureSuccess">
            <summary>
            Ensure that the command returned a zero exit code.
            </summary>
            <exception cref="T:Neon.Common.ExecuteException">Thrown if the exit code isn't zero.</exception>
        </member>
        <member name="T:Neon.Common.NeonHelper">
            <summary>
            Provides global common utilities and state.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeflateString(System.String)">
            <summary>
            Uses deflate to commpress a string.
            </summary>
            <param name="input">The input string or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.InflateString(System.Byte[])">
            <summary>
            Uses deflate to decompress a string from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeflateBytes(System.Byte[])">
            <summary>
            Uses deflate to commpress a byte array.
            </summary>
            <param name="bytes">The input byte array or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.InflateBytes(System.Byte[])">
            <summary>
            Uses deflate to decompress a byte array from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsGzipped(System.String)">
            <summary>
            Examines a file to determine whether it has been compressed via GZIP.
            </summary>
            <param name="path">The file path.</param>
            <returns><c>true</c> if the file is compressed via GZIP.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsGzipped(System.IO.Stream)">
            <summary>
            Examines a <see cref="T:System.IO.Stream"/> to determine whether it has been compressed via GZIP.
            This assumes that the current position points to the GZIP header if there is one.
            The stream position will be restored before returning.
            </summary>
            <param name="stream">The stream.</param>
            <returns><c>true</c> if the file is compressed via GZIP.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GzipString(System.String)">
            <summary>
            Uses GZIP to commpress a string.
            </summary>
            <param name="input">The input string or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GunzipString(System.Byte[])">
            <summary>
            Uses GZIP to decompress a string from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GzipBytes(System.Byte[])">
            <summary>
            Uses GZIP to commpress a byte array.
            </summary>
            <param name="bytes">The input byte array or <c>null</c>.</param>
            <returns>The compressed bytes or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GunzipBytes(System.Byte[])">
            <summary>
            Uses GZIP to decompress a byte array from compressed bytes.
            </summary>
            <param name="bytes">The compressed bytes or <c>null</c>.</param>
            <returns>The decompressed string or <c>null</c>.</returns>
        </member>
        <member name="F:Neon.Common.NeonHelper.syncRoot">
            <summary>
            Used for thread synchronization.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.CR">
            <summary>
            Ordinal value of an ASCII carriage return.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.LF">
            <summary>
            Ordinal value of an ASCII linefeed.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.HT">
            <summary>
            Ordinal value of an ASCII horizontal TAB.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.ESC">
            <summary>
            Ordinal value of an ASCII escape character.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.TAB">
            <summary>
            Ordinal value of an ASCII TAB character.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.CRLF">
            <summary>
            A string consisting of a CRLF sequence.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.LineEnding">
            <summary>
            Returns the native text line ending for the current environment.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.FileWildcards">
            <summary>
            Returns the characters used as wildcards for the current file system.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatTZ">
            <summary>
            Returns the date format string used for serialize dates with millisecond
            precision to strings like: <b>2018-06-05T14:30:13.000Z</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatTZOffset">
            <summary>
            Returns the date format string used for serialize dates with millisecond
            precision to strings like: <b>2018-06-05T14:30:13.000+00:00</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatMicroTZ">
            <summary>
            Returns the date format string used for serialize dates with microsecond
            precision to strings like: <b>2018-06-05T14:30:13.000000Z</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormatMicroTZOffset">
            <summary>
            Returns the date format string used for serialize dates with microsecond
            precision to strings like: <b>2018-06-05T14:30:13.000000+00:00</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormat100NsTZ">
            <summary>
            Returns the date format string used for serialize dates with 100 nanosecond
            precision to strings like: <b>2018-06-05T14:30:13.000000Z</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.DateFormat100NsTZOffset">
            <summary>
            Returns the date format string used for serialize dates with 100 nanosecond
            precision to strings like: <b>2018-06-05T14:30:13.000000+00:00</b>
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.UnixEpoch">
            <summary>
            Returns the Unix epoch time: 01-01-1970 (UTC).
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.is64Bit">
            <summary>
            Indicates whether the current application was built as 32 or 64-bit or <c>null</c>
            if this hasn't been determined yet.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.isDevWorkstation">
            <summary>
            Indicates whether the current application is running on a developer workstation
            or <c>null</c> if this hasn't been determined yet.  This is determined by the
            presence of the <b>DEV_WORKSTATION</b> environment variable.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.serviceContainer">
            <summary>
            The <see cref="T:Neon.Common.ServiceContainer"/> instance returned by 
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/>.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.specialUtf8EncodingProvider">
            <summary>
            Set to <c>true</c> when the special UTF-8 encoding provider with the misspelled
            name <b>utf8</b> (without the dash) has been initialized.  See 
            <see cref="M:Neon.Common.NeonHelper.RegisterMisspelledUtf8Provider"/> for more information.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.ServiceContainer">
            <summary>
            The root dependency injection service container used by Neon class libraries. 
            and applications.
            </summary>
            <remarks>
            <para>
            This instance implements both the <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> and <see cref="T:System.IServiceProvider"/>
            interfaces and supports adding, removing, and locating services over the lifetime
            of the application.  This is more flexible than the default Microsoft injection
            pattern, where services are added to an <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> at startup
            and then a read-only snapshot is taken via a <b>BuildServiceProvider()</b> call
            that is used throughout the remaining application lifespan.
            </para>
            <para>
            This is implemented by a <see cref="T:Microsoft.Extensions.DependencyInjection.ServiceCollection"/> by default.  It is possible
            to replace this very early during application initialization but the default 
            implementation should suffice for most purposes.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Common.NeonHelper.Is64Bit">
            <summary>
            Returns <c>true</c> if the application was built as 64-bit.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsDevWorkstation">
            <summary>
            Indicates whether the current application is running on a developer workstation.
            This is determined by the presence of the <b>DEV_WORKSTATION</b> environment variable.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.Is32BitBuild">
            <summary>
            Returns <c>true</c> if the client was built as 32-bit.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.RegisterMisspelledUtf8Provider">
            <summary>
            Ensures that a special UTF-8 text encoding provider misnamed as <b>utf8</b>
            (without the dash) is registered.  This is required sometimes because
            certain REST APIs may return incorrect <b>charset</b> values.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.EscapeCsv(System.String)">
            <summary>
            Escapes a string passed so that is suitable for writing to
            a CSV file as a field.
            </summary>
            <param name="value">The field value.</param>
            <returns>The escaped string.</returns>
            <remarks>
            The method surrounds the value with double quotes if it contains
            a comma or CRLF as well as escaping any double quotes in the
            string with second double quote.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ParseCsv(System.String)">
            <summary>
            Parses a CSV encoded string into its component fields.
            </summary>
            <param name="value">The encoded CSV string.</param>
            <returns>The decoded fields.</returns>
            <exception cref="T:System.FormatException">Thrown if the CSV file format is not valid.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToHex(System.Byte[],System.Boolean)">
            <summary>
            Converts the byte buffer passed into a hex encoded string.
            </summary>
            <param name="buf">The buffer</param>
            <param name="uppercase">Optionally renders the hex digits in uppercase.</param>
            <returns>The hex encoded string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.FromHex(System.String)">
            <summary>
            Parses the hex string passed and converts it a byte array.   
            </summary>
            <param name="s">The string to convert from hex.</param>
            <returns>The corresponding byte array.</returns>
            <exception cref="T:System.FormatException">Thrown if the input is not valid.</exception>
            <remarks>
            <note>
            The method ignores whitespace characters 
            (SP,CR,LF, and TAB) in the string so that HEX strings
            copied directly from typical hex dump outputs can
            be passed directly with minimal editing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseHex(System.String,System.Byte[]@)">
            <summary>
            Attempts to parse a hex string into a byte array.   
            </summary>
            <param name="s">The string to convert from hex.</param>
            <param name="output">Returns as the parsed byte array on success.</param>
            <returns><c>true</c> if the string was parsed successfully.</returns>
            <remarks>
            <note>
            The method ignores whitespace characters 
            (SP,CR,LF, and TAB) in the string so that HEX strings
            copied directly from typical hex dump outputs can
            be passed directly with minimal editing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsHex(System.Char)">
            <summary>
            Returns <c>true</c> if the character passed is a hex digit.
            </summary>
            <param name="ch">The character to test.</param>
            <returns><c>true</c> if the character is in one of the ranges: 0..9, a..f or A..F.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToHex(System.Byte,System.Boolean)">
            <summary>
            Converts a single byte into its hexidecimal equivalent.
            </summary>
            <param name="value">The input byte.</param>
            <param name="uppercase">Optionally return the hex value as uppercase.</param>
            <returns>The hex string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.HexValue(System.Char)">
            <summary>
            Returns the decimal value of the hex digit passed.
            </summary>
            <param name="ch">The hex digit.</param>
            <returns>The corresponding decimal value.</returns>
            <remarks>
            Throws a FormatException if the character is not a hex digit.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseHex(System.String,System.Int32@)">
            <summary>
            Attempts to parse a hex encoded string into an integer.
            </summary>
            <param name="input">The input string.</param>
            <param name="value">The parsed integer.</param>
            <returns><c>true</c> if the input could be parsed successfully.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,System.Int32,System.Int32,Neon.Common.HexDumpOption)">
            <summary>
            Returns a byte array as a formatted hex dump.
            </summary>
            <param name="data">The buffer to be dumped.</param>
            <param name="start">The first byte to be dumped.</param>
            <param name="count">The number of bytes to be dumped.</param>
            <param name="bytesPerLine">The number of bytes to dump per output line.</param>
            <param name="options">The formatting options.</param>
            <returns>The hex dump string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.HexDump(System.Byte[],System.Int32,Neon.Common.HexDumpOption)">
            <summary>
            Returns a byte array as a formatted hex dump.
            </summary>
            <param name="data">The buffer to be dumped.</param>
            <param name="bytesPerLine">The number of bytes to dump per output line.</param>
            <param name="options">The formatting options.</param>
            <returns>The hex dump string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ReadConsolePassword(System.String)">
            <summary>
            Reads a password from the <see cref="T:System.Console"/> terminated by <b>Enter</b>
            without echoing the typed characters.
            </summary>
            <param name="prompt">Optional prompt.</param>
            <returns>The password entered.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeleteFolder(System.String)">
            <summary>
            Recursively deletes a file system folder, ignoring any errors.
            </summary>
            <param name="folder">The folder path.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeleteFolderContents(System.String)">
            <summary>
            Recursively deletes the contents of a file folder, ignoring any errors.
            </summary>
            <param name="folder">The folder path.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.DeleteFolder(System.String,System.Int32,System.Boolean)">
            <summary>
            <para>
            Recursively deletes a directory.  Note that this assumes that any files
            have already been deleted.
            </para>
            <note>
            This method intentially ignores any errors.
            </note>
            </summary>
            <param name="path">The directory path.</param>
            <param name="level">The nesting level (top == 0).</param>
            <param name="deleteTop">Optionally deletes the top directory.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.CopyFolder(System.String,System.String)">
            <summary>
            Recursively copies the files within one directory to another, creating
            target folders as required.
            </summary>
            <param name="sourceFolder">The source folder.</param>
            <param name="targetFolder">The target folder.</param>
            <remarks>
            <note>
            This method does not currently copy empty folders.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.OpenStandardInput">
            <summary>
            Opens the current process standard inout stream.
            </summary>
            <returns>The open <see cref="T:System.IO.Stream"/>.</returns>
            <remarks>
            <note>
            <para>
            This method integrates with <see cref="T:Neon.Common.ProgramRunner"/> such that
            program executions simulated by calls to <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.String,System.String[])"/>
            or <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.Byte[],System.String[])"/>
            can read the simulated input.
            </para>
            <para>
            Should generally call this instead of calling <see cref="M:System.Console.OpenStandardInput"/>
            directly.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ReadStandardInputText">
            <summary>
            Reads the <b>standard input</b> file to the end and returns the
            result as a string.
            </summary>
            <returns>The standard input.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ReadStandardInputBytes">
            <summary>
            Reads the <b>standard input</b> file to the end and returns the
            result as bytes.
            </summary>
            <returns>The standard input.</returns>
        </member>
        <member name="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings">
            <summary>
            The global <b>relaxed</b> JSON serializer settings.  These settings 
            <b>do not require</b> that all source JSON properties match those 
            defined by the type being deserialized.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings">
            <summary>
            The global <b>strict</b> JSON serializer settings.  These settings 
            <b>do require</b> that all source JSON properties match those defined 
            by the type being deserialized.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.JsonConverters">
            <summary>
            <para>
            Returns the list of <see cref="T:Newtonsoft.Json.JsonConverter"/> instances that will be automatically
            recognized by the JSON deserializers.  This is initialized with converters for some
            common types like <see cref="T:Neon.Common.SemanticVersion"/>, <see cref="T:System.TimeSpan"/>, and 
            <see cref="T:System.Version"/>.
            </para>
            <note>
            <b>IMPORTANT:</b> You may customize this list but for that to have any impact,
            you must make the modifications <b>very early</b> in your application startup sequence,
            <b>before any JSON serialization operations</b> have been performed.  Any changes
            made after this will be ignored.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.AddTypeConverters(Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Adds the standard type converters to serializer settings.
            </summary>
            <param name="settings">The target settings.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerialize(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to JSON text.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <returns>The JSON text.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerializeToBytes(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to UTF-8 encoded JSON bytes.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <returns>The UTF-8 encoded JSON bytes.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize``1(System.String,System.Boolean)">
            <summary>
            Deserializes JSON text, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="json">The JSON text.</param>
            <param name="strict">Optionally require that all input properties map to <typeparamref name="T"/> properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize``1(System.Byte[],System.Boolean)">
            <summary>
            Deserializes UITF-8 encoded JSON bytes, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="jsonBytes">The UTF-8 encoded JSON bytes.</param>
            <param name="strict">Optionally require that all input properties map to <typeparamref name="T"/> properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize(System.Type,System.String,System.Boolean)">
            <summary>
            Non-generic method that deserializes JSON text, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <param name="type">The target type.</param>
            <param name="json">The JSON text.</param>
            <param name="strict">Optionally require that all input properties map to <paramref name="type"/> properties.</param>
            <returns>The parsed <c>object</c>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize(System.Type,System.Byte[],System.Boolean)">
            <summary>
            Non-generic method that deserializes UTF-8 encoded JSON bytes, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <param name="type">The target type.</param>
            <param name="jsonBytes">The UTF-8 encoded JSON bytes.</param>
            <param name="strict">Optionally require that all input properties map to <paramref name="type"/> properties.</param>
            <returns>The parsed <c>object</c>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerialize(System.Object,Newtonsoft.Json.JsonSerializerSettings,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to JSON text using custom settings.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <param name="settings">The optional settings or <c>null</c> to use <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/>.</param>
            <returns>The JSON text.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonSerializeToBytes(System.Object,Newtonsoft.Json.JsonSerializerSettings,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes an object to UTF-8 encoded JSON bytes using custom settings.
            </summary>
            <param name="value">The value to be serialized.</param>
            <param name="format">Output formatting option (defaults to <see cref="F:Newtonsoft.Json.Formatting.None"/>).</param>
            <param name="settings">The optional settings or <c>null</c> to use <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/>.</param>
            <returns>The ITF-8 encoded JSON bytes.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonDeserialize``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Deserializes JSON text using custom settings.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="json">The JSON text.</param>
            <param name="settings">The optional settings or <c>null</c> to use <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/>.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            This method uses the default <see cref="F:Neon.Common.NeonHelper.JsonRelaxedSerializerSettings"/> when specific
            settings are not passed.  You may pass <see cref="F:Neon.Common.NeonHelper.JsonStrictSerializerSettings"/> or
            entirely custom settings.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonClone``1(``0)">
            <summary>
            Creates a deep clone of an object by first serializing to JSON and then
            deserializing it.
            </summary>
            <typeparam name="T">The object type.</typeparam>
            <param name="value">The object being clonned or <c>null</c>.</param>
            <returns>The clone.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonEquals(System.Object,System.Object)">
            <summary>
            Compares two object instances for equality by serializing them JSON and
            comparing the output.
            </summary>
            <param name="v1">Value 1</param>
            <param name="v2">Value 2</param>
            <returns><c>true</c> if the instances are the same.</returns>
            <remarks>
            This is a convienent and safe way of comparing two objects without having
            to comparing a potentially complex tree of members and then maintaining
            that as code changes over time at the cost of having to perform the
            serializations.
            </remarks>
        </member>
        <member name="F:Neon.Common.NeonHelper.EnumMemberSerializationInfo.EnumToStrings">
            <summary>
            Maps serialized enum [EnumMember] strings to their ordinal value.
            </summary>
        </member>
        <member name="F:Neon.Common.NeonHelper.EnumMemberSerializationInfo.EnumToOrdinals">
            <summary>
            Maps enum ordinal values to their [EnumMember] string.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.IsOdd(System.Int32)">
            <summary>
            Determines whether an integer is odd.
            </summary>
            <param name="value">The value.</param>
            <returns><c>true</c> if the value is odd.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.NullableEquals``1(System.Nullable{``0},System.Nullable{``0})">
            <summary>
            Determines whether two nullable values are equal.
            </summary>
            <typeparam name="T">The base value type.</typeparam>
            <param name="v1">Value #1.</param>
            <param name="v2">Value #2.</param>
            <returns><c>true</c> if the values are equal.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToLinuxLineEndings(System.String)">
            <summary>
            Converts Windows line endings (CR-LF) to Linux/Unix line endings (LF).
            </summary>
            <param name="input">The input string or <c>null</c>.</param>
            <returns>The input string with converted line endings.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExceptionError(System.Exception,System.Boolean,System.Boolean)">
            <summary>
            Returns a string representation of an exception suitable for logging.
            </summary>
            <param name="e">The exception.</param>
            <param name="stackTrace">Optionally include the stack track.</param>
            <param name="excludeInner">Optionally exclude information about any inner exception.</param>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ThreadRun(System.Action)">
            <summary>
            Starts a new <see cref="T:System.Threading.Thread"/> to perform an action.
            </summary>
            <param name="action">The action to be performed.</param>
            <returns>The <see cref="T:System.Threading.Thread"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DoesNotThrow(System.Action)">
            <summary>
            Verfies that an action does not throw an exception.
            </summary>
            <param name="action">The action.</param>
            <returns><c>true</c> if no exception was thrown.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.DoesNotThrow``1(System.Action)">
            <summary>
            Verfies that an action does not throw a <typeparamref name="TException"/>.
            </summary>
            <param name="action">The action.</param>
            <typeparam name="TException">The exception type.</typeparam>
            <returns><c>true</c> if no exception was thrown.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExpandTabs(System.String,System.Int32)">
            <summary>
            Expands any embedded TAB <b>(\t)</b> characters in the string passed
            into spaces such that the tab stops will be formatted correctly.
            </summary>
            <param name="input">The input string.</param>
            <param name="tabStop">
            Optionally expands TABs into spaces when greater than zero or converts 
            a series of leading spaces into tabs if less than zero.  This defaults
            to <b>4</b>.
            </param>
            <returns>The expanded string.</returns>
            <remarks>
            <note>
            If the string passed includes line ending characters (CR or LF) then 
            the output will include line endings for every line, including the
            last one.
            </note>
            <para>
            A positive <paramref name="tabStop"/> does what you'd expect by converting
            spaces in the string into TABs such that the tab stops align to the value
            passed.  This works a bit differently for negative values.
            </para>
            <para>
            A negative <paramref name="tabStop"/> indicates that leading spaces in each
            line will be converted into TABs.  A value of -1 indicates that each leading
            two spaces will bve converted into a TAB, a value of -2 indicates that each
            leading 2 spaces will be converted into a TAB, and so on.
            </para>
            <para>
            Conversion to TABs will cease when the first non space is ecountered and
            any odd number of spaces remaining will be included in the output.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitFor(System.Func{System.Boolean},System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Waits for a boolean function to return <c>true</c>.
            </summary>
            <param name="action">The boolean delegate.</param>
            <param name="timeout">The maximum time to wait.</param>
            <param name="pollTime">The time to wait between polling or <c>null</c> for a reasonable default.</param>
            <exception cref="T:System.TimeoutException">Thrown if the never returned <c>true</c> before the timeout.</exception>
            <remarks>
            This method periodically calls <paramref name="action"/> until it
            returns <c>true</c> or <pararef name="timeout"/> exceeded.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitForAsync(System.Func{System.Threading.Tasks.Task{System.Boolean}},System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Asynchronously waits for a boolean function to return <c>true</c>.
            </summary>
            <param name="action">The boolean delegate.</param>
            <param name="timeout">The maximum time to wait.</param>
            <param name="pollTime">The time to wait between polling or <c>null</c> for a reasonable default.</param>
            <exception cref="T:System.TimeoutException">Thrown if the never returned <c>true</c> before the timeout.</exception>
            <remarks>
            This method periodically calls <paramref name="action"/> until it
            returns <c>true</c> or <pararef name="timeout"/> exceeded.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Compares two <c>null</c> or non-<c>null</c> enumerable sequences for equality.
            </summary>
            <typeparam name="T">The enumerable item type.</typeparam>
            <param name="sequence1">The first list or <c>null</c>.</param>
            <param name="sequence2">The second list or <c>null</c>.</param>
            <returns><c>true</c> if the sequences have matching elements.</returns>
            <remarks>
            <note>
            This method is capable of comparing <c>null</c> arguments and also
            uses <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to compare individual 
            elements.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.SequenceEqual``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Compares two <c>null</c> or non-<c>null</c> lists for equality.
            </summary>
            <typeparam name="T">The enumerable item type.</typeparam>
            <param name="list1">The first list or <c>null</c>.</param>
            <param name="list2">The second list or <c>null</c>.</param>
            <returns><c>true</c> if the sequences have matching elements.</returns>
            <remarks>
            <note>
            This method is capable of comparing <c>null</c> arguments and also
            uses <see cref="M:System.Object.Equals(System.Object,System.Object)"/> to compare 
            individual elements.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitAllAsync(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            Asynchronously waits for all of the <see cref="T:System.Threading.Tasks.Task"/>s passed to complete.
            </summary>
            <param name="tasks">The tasks to wait on.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitAllAsync(System.Threading.Tasks.Task[])">
            <summary>
            Asynchronously waits for all of the <see cref="T:System.Threading.Tasks.Task"/>s passed to complete.
            </summary>
            <param name="tasks">The tasks to wait on.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitAllAsync(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task},System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for all of the <see cref="T:System.Threading.Tasks.Task"/>s passed to complete.
            </summary>
            <param name="tasks">The tasks being performed.</param>
            <param name="timeout">The optional timeout.</param>
            <param name="cancellationToken">The optional cancellation token.</param>
            <exception cref="T:System.TimeoutException">Thrown if the <paramref name="timeout"/> was exceeded.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.WaitForParallel(System.Collections.Generic.IEnumerable{System.Action},System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Performs zero or more actions in parallel, synchronously waiting for all of them
            to completed.
            </summary>
            <param name="actions">The actions to be performed.</param>
            <param name="timeout">The optional timeout.</param>
            <param name="cancellationToken">The optional cancellation token.</param>
            <exception cref="T:System.TimeoutException">Thrown if the <paramref name="timeout"/> was exceeded.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.JTokenEquals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Compares the two Newtonsoft JSON.NET <see cref="T:Newtonsoft.Json.Linq.JToken"/> instances along
            with their decendants for equality.  This is an alternative to <see cref="P:Newtonsoft.Json.Linq.JToken.EqualityComparer"/> 
            which seems to have some problems, as outlined in the remarks.
            </summary>
            <param name="token1">The first token.</param>
            <param name="token2">The second token.</param>
            <returns><c>true</c> if the tokens are to be considered as equal.</returns>
            <remarks>
            <para>
            I have run into a situation in the <c>Neon.Couchbase.Dynamic.DynamicEntity</c> implementation
            where I've serialized a Couchbase Lite document and then when loading the updated
            revision, <see cref="P:Newtonsoft.Json.Linq.JToken.EqualityComparer"/> indicates that two properties with
            the same name and <c>null</c> values are different.
            </para>
            <para>
            I think the basic problem is that a NULL token has a different token type than
            a string token with a NULL value and also that some token types such as <see cref="F:Newtonsoft.Json.Linq.JTokenType.Date"/>,
            <see cref="F:Newtonsoft.Json.Linq.JTokenType.Guid"/>, <see cref="F:Newtonsoft.Json.Linq.JTokenType.TimeSpan"/>, and <see cref="F:Newtonsoft.Json.Linq.JTokenType.Uri"/> 
            will be round tripped as <see cref="F:Newtonsoft.Json.Linq.JTokenType.String"/> values.
            </para>
            <para>
            This method addresses these issues.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.StripFileScheme(System.String)">
            <summary>
            Removes a <b>file://</b> scheme from the path URI if this is scheme
            is present.  The result will be a valid file system path.
            </summary>
            <param name="path">The path/URI to be converted.</param>
            <returns>The file system path.</returns>
            <remarks>
            <note>
            <para>
            This method behaves slightly differently when running on Windows and
            when running on Unix/Linux.  On Windows, file URIs are absolute file
            paths of the form:
            </para>
            <code language="none">
            FILE:///C:/myfolder/myfile
            </code>
            <para>
            To convert this into a valid file system path this method strips the
            <b>file://</b> scheme <i>and</i> the following forward slash.  On
            Unix/Linux, file URIs will have the form:
            </para>
            <code language="none">
            FILE:///myfolder/myfile
            </code>
            <para>
            In this case, the forward shlash following the <b>file://</b> scheme
            is part of the file system path and will not be removed.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ArrayEquals(System.Byte[],System.Byte[])">
            <summary>
            Determines whether two byte arrays contain the same values in the same order.
            </summary>
            <param name="v1">Byte array #1.</param>
            <param name="v2">Byte array #2.</param>
            <returns><c>true</c> if the arrays are equal.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEnumMembers``1">
            <summary>
            Returns the serialization information for an enumeration type.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEnumMembers(System.Type)">
            <summary>
            Returns the serialization information for an enumeration type.
            </summary>
            <param name="type">The enumeration type.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.ParseEnum``1(System.String,System.Nullable{``0})">
            <summary>
            Type-safe <c>enum</c> parser that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.  This is case insensitive.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="input">The input string.</param>
            <param name="defaultValue">
            Optionally specifies the value to be returned if the input cannot
            be parsed instead of throwing an exception.
            </param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="input"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="input"/> is not valid.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParse``1(System.String,``0@)">
            <summary>
            Type-safe <c>enum</c> parser that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.  This is case insensitive.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="input">The input string.</param>
            <param name="output">Returns as the parsed value.</param>
            <returns><c>true</c> if the value was parsed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseEnum(System.Type,System.String,System.Object@)">
            <summary>
            <c>enum</c> parser that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.  This is case insensitive.
            </summary>
            <param name="type">The enumeration type.</param>
            <param name="input">The input string.</param>
            <param name="output">Returns as the parsed value.</param>
            <returns><c>true</c> if the value was parsed.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.EnumToString``1(``0)">
            <summary>
            Type-safe <c>enum</c> serializer that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="input">The input value.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.EnumToString(System.Type,System.Object)">
            <summary>
            Type-safe <c>enum</c> serializer that also honors any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            decorating the enumeration values.
            </summary>
            <param name="type">The enumeration type.</param>
            <param name="input">The input value.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.UrlTokenEncode(System.Byte[])">
            <summary>
            Encodes a byte array into a form suitable for using as a URI path
            segment or query parameter.
            </summary>
            <param name="input">The byte array.</param>
            <returns>The encoded string.</returns>
            <exception cref="T:System.NullReferenceException">Thrown if <paramref name="input"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.UrlTokenDecode(System.String)">
            <summary>
            Decodes a string encoded by <see cref="M:Neon.Common.NeonHelper.UrlTokenEncode(System.Byte[])"/> back
            into a byte array.
            </summary>
            <param name="input">The input string.</param>
            <returns>The decoded bytes.</returns>
            <exception cref="T:System.NullReferenceException">Thrown if <paramref name="input"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetAssemblyFolder(System.Reflection.Assembly)">
            <summary>
            Returns the fully qualified path to the folder holding the
            assembly passed (includes the terminating "\").
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>Path to the folder holding the assembly.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetAssemblyPath(System.Reflection.Assembly)">
            <summary>
            Returns the fully qualified path to the assembly file.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>The assembly's path.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetEntryAssemblyPath">
            <summary>
            Returns the fully qualified path the entry assembly for the current process.
            </summary>
            <returns>The entry assembly file path.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonOrYamlDeserialize``1(System.String,System.Boolean)">
            <summary>
            Deserializes JSON or YAML text using, optionally requiring strict mapping of input properties to the target type.
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="input">The input text (JSON or YAML).</param>
            <param name="strict">Optionally require that all input properties map to <typeparamref name="T"/> properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
            <remarks>
            <note>
            This method works by looking for leading '{' or '[' as the first non-whitespace character
            in the string to detect whether the input is JSON.  The method assumes YAML otherwise.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.TryParseBool(System.String,System.Boolean@)">
            <summary>
            Attempts to parse a boolean from common literals.
            </summary>
            <param name="input">The input literal.</param>
            <param name="value">Returns as the parsed value on success.</param>
            <returns><c>true</c> on success.</returns>
            <remarks>
            <para>
            This method recognizes the following case insensitive literals:
            </para>
            <list type="table">
            <item>
            <term><c>false</c></term>
            <description>
            <para><b>0</b></para>
            <para><b>off</b></para>
            <para><b>no</b></para>
            <para><b>disabled</b></para>
            <para><b>false</b></para>
            </description>
            </item>
            <item>
            <term><c>true</c></term>
            <description>
            <para><b>1</b></para>
            <para><b>on</b></para>
            <para><b>yes</b></para>
            <para><b>enabled</b></para>
            <para><b>true</b></para>
            </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ParseBool(System.String)">
            <summary>
            Parses common boolean literals.
            </summary>
            <param name="input">The input literal.</param>
            <returns>The parsed output.</returns>
            <exception cref="T:System.FormatException">Thrown if the value is not valid.</exception>
            <remarks>
            <para>
            This method recognizes the following case insensitive literals:
            </para>
            <list type="table">
            <item>
            <term><c>false</c></term>
            <description>
            <para><b>0</b></para>
            <para><b>off</b></para>
            <para><b>no</b></para>
            <para><b>disabled</b></para>
            <para><b>false</b></para>
            </description>
            </item>
            <item>
            <term><c>true</c></term>
            <description>
            <para><b>1</b></para>
            <para><b>on</b></para>
            <para><b>yes</b></para>
            <para><b>enabled</b></para>
            <para><b>true</b></para>
            </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.StripAnsibleWarnings(System.String)">
            <summary>
            <b>HACK:</b> This method attempts to trim warnings generated by Ansible because
            it writes these warnings to STDOUT instead of STDERR.  This is super fragile.
            </summary>
            <param name="text">The text to be adjusted.</param>
            <returns>The adjusted text.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.ToBoolString(System.Boolean)">
            <summary>
            Renders a <c>bool</c> value as either <b>true</b> or <b>false</b>
            (lower case).
            </summary>
            <param name="value">The value.</param>
            <returns><b>true</b> or <b>false</b>,</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.NoAwait(System.Threading.Tasks.Task)">
            <summary>
            Do nothing method that is used when you explicitly don't want to
            <c>await</c> a task and you don't want to see warning <b>CS4014</b>.
            </summary>
            <param name="task">The task.</param>
        </member>
        <member name="P:Neon.Common.NeonHelper.OpenEditorHandler">
            <summary>
            Used for implementing unit tests against the <see cref="M:Neon.Common.NeonHelper.OpenEditor(System.String)"/>
            method.  <see cref="M:Neon.Common.NeonHelper.OpenEditor(System.String)"/> will call this action when it's
            non-null passing the file path, rather than actually opening the file in
            an editor.  The handler can then simulate editing the file.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.OpenEditor(System.String)">
            <summary>
            Launches the platform text editor to create or edit a file.
            </summary>
            <param name="path">The file path.</param>
            <remarks>
            <para>
            This method will launch the editor specified in the <b>EDITOR</b>
            environment variable otherwise it will launch NotePad on Windows
            and Vim on Linux and OS/X.  <b>EDITOR</b> should be set to the
            command line used to launch the editor with special <b>$FILE</b> 
            parameter.  This will be replaced with the path to the file being 
            edited.
            </para>
            <note>
            We'll simply append the file path if <b>$FILE</b> isn't found in
            the <b>EDITOR</b> environment variable.
            </note>
            <para>
            This method will block until the editor is closed.
            </para>
            <note>
            For unit testing, you may set <see cref="P:Neon.Common.NeonHelper.OpenEditorHandler"/> to
            an action that will simulate editing the file.  This action will
            be called instead of actually opening an editor when set.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.PackageReferenceToNeonCommonIsRequired">
            <summary>
            <para>
            This method may be called to ensure that the <b>Neon.Common</b> assembly
            is required at compile in a project that doesn't reference <b>Neon.Common</b>.
            The method does nothing.
            </para>
            <note>
            A call to this is currently included by <b>Neon.CodeGen</b> to ensure that
            the enclosing project references <b>Neon.Common</b>.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.DetectOS">
            <summary>
            Detects the current operating system.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.OsDescription">
            <summary>
            Returns the operation system description.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.FrameworkDescription">
            <summary>
            Returns the .NET runtime description.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsWindows">
            <summary>
            Returns <c>true</c> if the application is running on a Windows variant
            operating system.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsLinux">
            <summary>
            Returns <c>true</c> if the application is running on a Linux variant
            operating system.
            </summary>
        </member>
        <member name="P:Neon.Common.NeonHelper.IsOSX">
            <summary>
            Returns <c>true</c> if the application is running on Max OSX.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetProgramPath(System.String)">
            <summary>
            Returns the path to an executable. 
            </summary>
            <param name="program">The program file name or fully qualified path.</param>
            <returns>The executable path.</returns>
            <remarks>
            <para>
            The behavior of this method varies based on whether the host operating system
            is Windows or Linux/OSX.
            </para>
            <para>
            For Windows, the <see cref="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)"/> method does not 
            search the PATH for the application.  This method attempts to convert the program
            file name into a fully qualified path by actually searching the PATH.
            </para>
            <para>
            For Linux/OSX, the <paramref name="program"/> value is returned unchanged.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.NormalizeExecArgs(System.Object[])">
            <summary>
            Normalizes an array of argument objects into a form that can
            be passed to an invoked process by adding a quotes and escape
            characters as necessary. 
            </summary>
            <param name="args">The arguments.</param>
            <returns>The formatted argument string.</returns>
            <remarks>
            <note>
            <c>null</c> and empty arguments are ignored.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.NormalizeArg(System.String)">
            <summary>
            Normalizes a string argument.
            </summary>
            <param name="argValue">The argument.</param>
            <returns>The argument string with any required quotes and escapes.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.Fork(System.String,System.Object[])">
            <summary>
            Forks a child process that will run in parallel with the current process.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <returns>The <see cref="T:System.Diagnostics.Process"/> information.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.Execute(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process)">
            <summary>
            Starts a process with an array of arguments to run an executable file and
            then waits for the process to terminate.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.Execute(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process)">
            <summary>
            Starts a process to run an executable file and then waits for the process to terminate.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteAsync(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process)">
            <summary>
            Asyncrhonously starts a process to run an executable file with an array of
            arguments and then and waits for the process to terminate.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteAsync(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process)">
            <summary>
            Asyncrhonously starts a process to run an executable file and then waits for the process to terminate.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <returns>The process exit code.</returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Common.NeonHelper.ProcessStreamRedirector">
            <summary>
            Used to redirect process output streams.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCapture(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.Action{System.String},System.Action{System.String})">
            <summary>
            Starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <param name="outputAction">Optional action that will be called when the process outputs some text.</param>
            <param name="errorAction">Optional action that will be called when the process outputs some error text.</param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            <para>
            You can optionally specify the <paramref name="outputAction"/> and/or <paramref name="errorAction"/>
            callbacks to receive the process output as it is received.  <paramref name="outputAction"/> will 
            be called with both the STDOUT and STDERR streams if <paramref name="errorAction"/> is <c>null</c>
            otherwise it will called only with STDOUT text.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCapture(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process,System.Action{System.String},System.Action{System.String})">
            <summary>
            Starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Optional maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <param name="outputAction">Optional action that will be called when the process outputs some text.</param>
            <param name="errorAction">Optional action that will be called when the process outputs some error text.</param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            <para>
            You can optionally specify the <paramref name="outputAction"/> and/or <paramref name="errorAction"/>
            callbacks to receive the process output as it is received.  <paramref name="outputAction"/> will 
            be called with both the STDOUT and STDERR streams if <paramref name="errorAction"/> is <c>null</c>
            otherwise it will called only with STDOUT text.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCaptureAsync(System.String,System.Object[],System.Nullable{System.TimeSpan},System.Diagnostics.Process)">
            <summary>
            Asynchronously starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteCaptureAsync(System.String,System.String,System.Nullable{System.TimeSpan},System.Diagnostics.Process)">
            <summary>
            Asynchronously starts a process to run an executable file and then waits for the process to terminate
            while capturing any output written to the standard output and error streams.
            </summary>
            <param name="path">Path to the executable file.</param>
            <param name="args">Command line arguments (or <c>null</c>).</param>
            <param name="timeout">
            Maximum time to wait for the process to complete or <c>null</c> to wait
            indefinitely.
            </param>
            <param name="process">
            The optional <see cref="T:System.Diagnostics.Process"/> instance to use to launch the process.
            </param>
            <returns>
            The <see cref="T:Neon.Common.ExecuteResponse"/> including the process exit code and capture 
            standard output and error streams.
            </returns>
            <exception cref="T:System.TimeoutException">Thrown if the process did not exit within the <paramref name="timeout"/> limit.</exception>
            <remarks>
            <note>
            If <paramref name="timeout"/> is exceeded and execution has not commpleted in time 
            then a <see cref="T:System.TimeoutException"/> will be thrown and the process will be killed
            if it was created by this method.  Process instances passed via the <paramref name="process"/>
            parameter will not be killed in this case.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.StartProcess(System.Reflection.Assembly,System.String)">
            <summary>
            Starts a process for an <see cref="T:System.Reflection.Assembly" /> by calling the assembly's <b>main()</b>
            entry point method. 
            </summary>
            <param name="assembly">The assembly to be started.</param>
            <param name="args">The command line arguments (or <c>null</c>).</param>
            <returns>The process started.</returns>
            <remarks>
            <note>
            This method works only for executable assemblies with
            an appropriate <b>main</b> entry point that reside on the
            local file system.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.OpenBrowser(System.String)">
            <summary>
            Launches the default browser to display the specified URI.
            </summary>
            <param name="uri">The target URI.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.ExecuteShell(System.String)">
            <summary>
            Executes a command using the local shell, <b>CMD.EXE</b> for Windows and
            <b>Bash</b> for OSX and Linux.
            </summary>
            <param name="command">The command and arguments to be executed.</param>
            <returns>The process exit code.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetProcessById(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Diagnostics.Process"/> associated with an ID
            or <c>null</c> if no process with this ID exists.
            </summary>
            <param name="id">The target process ID.</param>
            <returns>The <see cref="T:System.Diagnostics.Process"/> or <c>null</c>.</returns>
            <remarks>
            This is slightly different from how <see cref="M:System.Diagnostics.Process.GetProcessById(System.Int32)"/>
            works.  That method throws an <see cref="T:System.ArgumentException"/> if there's
            no process with the ID where as this one will return <c>null</c>.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomInt">
            <summary>
            Returns an integer pseudo random number.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomDouble">
            <summary>
            Returns a double pseudo random number between 0.0 and +1.0
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomDouble(System.Double)">
            <summary>
            Returns a double pseudo random number between 0.0 and the specified limit.
            </summary>
            <param name="limit">The limit.</param>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomInt(System.Int32)">
            <summary>
            Returns a pseudo random number in the range of 0..limit-1.
            </summary>
            <param name="limit">The value returned will not exceed one less than this value.</param>
            <returns>The random number.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomIndex(System.Int32)">
            <summary>
            Returns a random index into a sequence whose length is specified.
            </summary>
            <param name="length">The sequence length.</param>
            <returns>The random index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if length is &lt;= 0.</exception>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomTimespan(System.TimeSpan)">
            <summary>
            Returns a random <see cref="T:System.TimeSpan"/> between zero and a specified maximum.
            </summary>
            <param name="maxInterval">The maximum interval.</param>
            <returns>The random timespan.</returns>
            <remarks>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomTimespan(System.TimeSpan,System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> between the specified base interval
            plus a random period of the specified fraction of the value.
            </summary>
            <param name="baseInterval">The base interval.</param>
            <param name="fraction">The fractional multiplier for the random component.</param>
            <returns>The random timespan.</returns>
            <remarks>
            <para>
            The value returned is at least as large as <paramref name="baseInterval" /> with an
            added random fractional interval if <paramref name="fraction" /> is positive or the value
            returned may be less than <paramref name="baseInterval" /> for a negative <paramref name="fraction" />.  
            This is computed via:
            </para>
            <code language="cs">
            baseInterval + Helper.RandTimespan(TimeSpan.FromSeconds(baseInterval.TotalSeconds * fraction));
            </code>
            <para>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.PseudoRandomTimespan(System.TimeSpan,System.TimeSpan)">
            <summary>
            Returns a random <see cref="T:System.TimeSpan" /> value between the min/max
            values specified.
            </summary>
            <param name="minInterval">The minimum interval.</param>
            <param name="maxInterval">The maximum interval.</param>
            <returns>The randomized time span.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetCryptoRandomBytes(System.Int32)">
            <summary>
            Generates a byte array filled with a cryptographically strong sequence of random values.
            </summary>
            <param name="count">The number of random bytes to be generated.</param>
            <returns>The random byte array.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetCryptoRandomPassword(System.Int32)">
            <summary>
            Generates a cryptographically random password.
            </summary>
            <param name="length">The password length.</param>
            <returns>The generated password.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.CreateSecureRandom">
            <summary>
            Creates a <see cref="T:System.Random"/> pseudo random number generated
            with a cryptographically random seed.
            </summary>
            <returns>A <see cref="T:System.Random"/>.</returns>
        </member>
        <member name="T:Neon.Common.NeonHelper.LowercaseYamlNamingConvention">
            <summary>
            YAML naming convention that renders property names as lowercase
            and is case insensitive.
            </summary>
        </member>
        <member name="T:Neon.Common.NeonHelper.YamlEnumTypeConverter">
            <summary>
            Customizes <c>enum</c> type conversions to/from strings recognizing
            <c>[EnumMember]</c> attributes when present.
            </summary>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlEnumTypeConverter.Accepts(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlEnumTypeConverter.ReadYaml(YamlDotNet.Core.IParser,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlEnumTypeConverter.WriteYaml(YamlDotNet.Core.IEmitter,System.Object,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlSerialize(System.Object)">
            <summary>
            <para>
            Serializes an object to YAML. 
            </para>
            <note>
            Property names are always converted to lowercase when serializing to YAML.
            </note>
            </summary>
            <param name="value">The value to be serialized.</param>
            <returns>The YAML text.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.YamlDeserialize``1(System.String,System.Boolean)">
            <summary>
            <para>
            Deserializes YAML text to an object, optionally requiring strict mapping of input properties to the target type.
            </para>
            <note>
            Property names are expected to be lowercase.
            </note>
            </summary>
            <typeparam name="T">The desired output type.</typeparam>
            <param name="yaml">The YAML text.</param>
            <param name="strict">Optionally require that all input properties map to route properties.</param>
            <returns>The parsed <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Common.NeonHelper.JsonToYaml(System.String)">
            <summary>
            Converts a JSON text to YAML.
            </summary>
            <param name="jsonText">The JSON text.</param>
            <returns>The equivalent YAML text.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="jsonText"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="jsonText"/> does not specify a value, array, or object.</exception>
            <remarks>
            <note>
            Property names are always converted to lower case when converting to YAML.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Common.NeonHelper.SerializeYaml(System.Text.StringBuilder,Newtonsoft.Json.Linq.JToken,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="sbYaml"></param>
            <param name="jToken"></param>
            <param name="nesting"></param>
            <param name="isArrayElement"></param>
        </member>
        <member name="M:Neon.Common.NeonHelper.GetYamlValue(Newtonsoft.Json.Linq.JValue)">
            <summary>
            Returns the serialized YAML value for a <see cref="T:Newtonsoft.Json.Linq.JValue"/>.
            </summary>
            <param name="jValue">The value.</param>
            <returns>The serialized value.</returns>
        </member>
        <member name="T:Neon.Common.SpecialUtf8EncodingProvider">
            <summary>
            This is a special class used by <see cref="M:Neon.Common.NeonHelper.RegisterMisspelledUtf8Provider"/>
            to implement UTF-8 encodings with the name <b>utf8</b> misspelled (no dash).
            </summary>
        </member>
        <member name="T:Neon.Common.ByteEncoding">
            <summary>
            Implements a text encoding that simply reads and writes bytes without
            any changes.  This corresponds to the Windows codepage <b>1252</b>.
            </summary>
        </member>
        <member name="P:Neon.Common.ByteEncoding.Instance">
            <summary>
            Returns a <see cref="T:Neon.Common.ByteEncoding"/> instance.
            </summary>
        </member>
        <member name="M:Neon.Common.ByteEncoding.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetMaxByteCount(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Common.ByteEncoding.GetMaxCharCount(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Common.ByteUnits">
            <summary>
            <para>
            Converts a byte count string with optional units into a count.
            </para>
            <list type="table">
            <item>
                <term><b>KB</b></term>
                <description>1,000</description>
            </item>
            <item>
                <term><b>KiB</b></term>
                <description>1,024</description>
            </item>
            <item>
                <term><b>MB</b></term>
                <description>1000000</description>
            </item>
            <item>
                <term><b>MiB</b></term>
                <description>1,048,576</description>
            </item>
            <item>
                <term><b>GB</b></term>
                <description>1,000,000,000</description>
            </item>
            <item>
                <term><b>GiB</b></term>
                <description>1,073,741,824</description>
            </item>
            <item>
                <term><b>TB</b></term>
                <description>1,000,000,000,000</description>
            </item>
            <item>
                <term><b>TiB</b></term>
                <description>1,099,511,627,776</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.KiloBytes">
            <summary>
            One KB: 1,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.MegaBytes">
            <summary>
            One MB: 1,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.GigaBytes">
            <summary>
            One GB: 1,000,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.TeraBytes">
            <summary>
            The constant 1,000,000,000
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.KibiBytes">
            <summary>
            One KiB: 1,024 (2^10)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.MebiBytes">
            <summary>
            One MiB: 1,048,576 (2^20)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.GibiBytes">
            <summary>
            One GiB: 1,073,741,824 (2^30)
            </summary>
        </member>
        <member name="F:Neon.Common.ByteUnits.TebiBytes">
            <summary>
            The constant 1,099,511,627,776 (2^40)
            </summary>
        </member>
        <member name="M:Neon.Common.ByteUnits.TryParse(System.String,System.Int64@)">
            <summary>
            Parses a floating point count string that may include one of the optional
            unit suffixes described here <see cref="T:Neon.Common.ByteUnits"/>.
            </summary>
            <param name="input">The input string.</param>
            <param name="value">Returns as the output value.</param>
            <returns><b>true</b> on success</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.Parse(System.String)">
            <summary>
            Parses a byte count and returns a <c>long</c>.
            </summary>
            <param name="text">The value being parsed.</param>
            <returns>The parsed value.</returns>
            <exception cref="T:System.FormatException">Thrown if the value cannot be parsed.</exception>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToByteString(System.Int64)">
            <summary>
            Converts a byte count to a string using byte units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in bytes.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToDoubleString(System.Int64,System.Int64)">
            <summary>
            Converts the size to the specified units and then renders this
            as an invariant culture fixed point string.
            </summary>
            <param name="size">The byte size.</param>
            <param name="units">The units.</param>
            <returns>The floating point string.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToKBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>KB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in KB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToKiBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>KiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in KiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToMBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>MB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in MB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToMiBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>MiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in MiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToGBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>GB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in GB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToGiBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>GiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in GiB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToTBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>TB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in TB.</returns>
        </member>
        <member name="M:Neon.Common.ByteUnits.ToTiBString(System.Int64)">
            <summary>
            Converts a byte count to a string using <b>TiB</b> units.
            </summary>
            <param name="size">The size.</param>
            <returns>The size in TiB.</returns>
        </member>
        <member name="T:Neon.Common.ProgramEntrypoint">
            <summary>
            Program main entry point method signature.
            </summary>
            <param name="args">The command line arguments.</param>
            <returns>The exit code.</returns>
        </member>
        <member name="T:Neon.Common.ProgramRunner">
            <summary>
            Used to implement unit tests on command line tools by simulating
            their execution on a thread rather than forking the tool as a process.
            This is makes debugging easier and also deals with the fact that
            unit tests may leave orphan processes running.
            </summary>
            <remarks>
            <para>
            This class is designed to simulate running a single executable
            by calling its main entrypoint.  To accomplish this, use the
            default constructor to create a <see cref="T:Neon.Common.ProgramRunner"/> 
            instance.  The constructor will set <see cref="P:Neon.Common.ProgramRunner.Current"/> to
            itself and then you can call <see cref="M:Neon.Common.ProgramRunner.Execute(Neon.Common.ProgramEntrypoint,System.String[])"/>
            to execute the program synchronously (waiting for it to return),
            or <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/> to simulate 
            forking the program by running it on a new thread.
            </para>
            <para>
            <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/> waits to return
            until the program calls <see cref="M:Neon.Common.ProgramRunner.ProgramReady"/>.  This is used
            to ensure that program has completed the activities required 
            by the unit tests before the tests are executed.
            </para>
            <note>
            Only one <see cref="T:Neon.Common.ProgramRunner"/> instance can active at any
            particular time.
            </note>
            <para>
            Simulated program entry points that will be called by <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>
            and that run indefinitely, need to call <see cref="M:Neon.Common.ProgramRunner.WaitForExit"/> when
            after its started the operation.  This returns when the <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/>
            is called.  The simulated program should stop any operations being
            performed, release any important resources and exit cleanly its <c>Main</c>
            method cleanly.
            </para>
            <para>
            The <see cref="P:Neon.Common.ProgramRunner.Arguments"/> dictionary can be used to pass additional
            arguments into the program being tested.  This maps case insensitve keys
            to <c>object</c> values.
            </para>
            <note>
            You should call <see cref="M:Neon.Common.ProgramRunner.Dispose"/> when you're finished with
            the runner.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Common.ProgramRunner.Current">
            <summary>
            Returns the current <see cref="T:Neon.Common.ProgramRunner"/> or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.#ctor(System.TimeSpan)">
            <summary>
            Constructor.
            </summary>
            <param name="forkTimeout">
            Specifies the maximum time for <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>
            to wait for the program to signal that it's ready by calling <see cref="M:Neon.Common.ProgramRunner.ProgramReady"/>.
            This defaults to <b>30 seconds</b>.
            </param>
        </member>
        <member name="M:Neon.Common.ProgramRunner.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Common.ProgramRunner.Arguments">
            <summary>
            Returns a case insensitve dictionary of additional unit test related arguments
            that can be passed to the program being tested.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.Execute(Neon.Common.ProgramEntrypoint,System.String[])">
            <summary>
            Executes a program entry point synchronously, passing arguments and returning the result.
            </summary>
            <param name="main">The program entry point.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.OpenStandardInput">
            <summary>
            Opens the standard input stream.  This will return a stream with the
            input specified when <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.Byte[],System.String[])"/>
            or <see cref="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.String,System.String[])"/> were called
            or else it will simply return the result of <see cref="M:System.Console.OpenStandardInput"/>.
            </summary>
            <returns>The input <see cref="T:System.IO.Stream"/>.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.Byte[],System.String[])">
            <summary>
            Executes a program entry point synchronously, streaming some bytes as standard input,
            passing arguments and returning the result.
            </summary>
            <param name="main">The program entry point.</param>
            <param name="inputBytes">The bytes to be passed as standard input.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ExecuteWithInput(Neon.Common.ProgramEntrypoint,System.String,System.String[])">
            <summary>
            Executes a program entry point synchronously, streaming some text as standard input,
            passing arguments and returning the result.
            </summary>
            <param name="main">The program entry point.</param>
            <param name="inputText">The text to be passed as standard input.</param>
            <param name="args">The arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/> returned by the simulated program run.</returns>
        </member>
        <member name="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])">
            <summary>
            <para>
            Executes a program entry point asynchronously, without waiting for the command to complete.
            This is useful for commands that don't terminate by themselves.  Call <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/>
            to kill the running command.
            </para>
            <note>
            <b>IMPORTANT:</b> The <paramref name="main"/> simulated entry point must call
            <see cref="M:Neon.Common.ProgramRunner.WaitForExit"/>.  This will block until the <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/>
            is called, returning when the program is expected to terminate itself.
            </note>
            </summary>
            <param name="main">The program entry point.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Neon.Common.ProgramRunner.ProgramReady">
            <summary>
            <para>
            Called by programs executed via <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>
            when the program has initialized itself enough to be ready for testing.
            </para>
            <note>
            This must be called or else <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/> will
            never return.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.TerminateFork">
            <summary>
            Terminates the forked program if one is running.
            </summary>
        </member>
        <member name="M:Neon.Common.ProgramRunner.WaitForExit">
            <summary>
            Called by the emulated program entry point for operations that are
            initiated via <see cref="M:Neon.Common.ProgramRunner.Fork(Neon.Common.ProgramEntrypoint,System.String[])"/>.  This
            method will block until <see cref="M:Neon.Common.ProgramRunner.TerminateFork"/> is called.  The
            emulated program must exit cleanly when this returns.
            </summary>
        </member>
        <member name="T:Neon.Csv.CsvReader">
            <summary>
            Parses CSV encoded rows from text.
            </summary>
            <remarks>
            <para>
            Use this class to parse CSV encoded tables.  Use one of the constructors
            to initialize in instance to read from a file, <see cref="T:System.IO.Stream" /> , string, or 
            a <see cref="T:System.IO.TextReader" /> and then call <see cref="M:Neon.Csv.CsvReader.Read" /> to read each
            row of the table.
            </para>
            <para>
            This class handles the all special cases for CSV parsing including quoted
            fields, escaped double quotes, and fields that include CR and LF characters.
            </para>
            <para>
            Be sure to call <see cref="M:Neon.Csv.CsvReader.Close" /> or <see cref="M:Neon.Csv.CsvReader.Dispose" /> when you
            are finished with the class to release any underlying resources.
            </para>
            <note>
            The underlying stream must support seeking for this class to work properly.
            </note>
            </remarks>
            <threadsafety instance="false" />
        </member>
        <member name="M:Neon.Csv.CsvReader.#ctor(System.String)">
            <summary>
            Constructs a reader to parse a string.
            </summary>
            <param name="text">The text string.</param>
        </member>
        <member name="M:Neon.Csv.CsvReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a reader to parse a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The stream's character <see cref="T:System.Text.Encoding" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs a reader to parse text from a <see cref="T:System.IO.TextReader" />.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvReader.Close">
            <summary>
            Closes the reader if it is still open.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvReader.Dispose">
            <summary>
            Releases any resources associated with the reader.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvReader.Read">
            <summary>
            Parses and returns the next row of fields.
            </summary>
            <returns>
            A list of parsed field strings or <c>null</c> if the end of the input stream
            has been reached.
            </returns>
        </member>
        <member name="M:Neon.Csv.CsvReader.Rows">
            <summary>
            Returns an enumerator that returns the data rows from a <see cref="T:Neon.Csv.CsvReader"/>.
            </summary>
            <returns>The next row as a <see cref="T:System.Collections.Generic.List`1"/>.</returns>
        </member>
        <member name="T:Neon.Csv.CsvTableReader">
            <summary>
            Used to read a CSV table that includes row headers.
            </summary>
            <remarks>
            <para>
            This class makes it easy to process tabular data loaded from a CSV file,
            where the first row of the file contains the row header strings that
            identify the table columns.
            </para>
            <para>
            Initialize an instance by passing a <see cref="T:Neon.Csv.CsvReader" />, stream, string, or file path to the 
            constructor.  The constructor will read the first row of the file and initialize the <see cref="P:Neon.Csv.CsvTableReader.ColumnMap" />
            dictionary which maps the case insensitive column name to the zero based index of the
            column in the table.
            </para>
            <para>
            You'll process each data row by calling <see cref="M:Neon.Csv.CsvTableReader.ReadRow" />.  This returns a list
            with the next row of data or <c>null</c> if the end of the table has been reached.  You can
            process the row data returned directly or use the <see cref="M:Neon.Csv.CsvTableReader.GetColumn(System.String)" /> method to
            access a column value on the current row directly.
            </para>
            <note>
            This class is tolerant of blank or duplicate column names.  In the case of duplicates, the
            first column matching the requested column name will be used when parsing data.
            </note>
            <para>
            Applications should call the reader's <see cref="M:Neon.Csv.CsvTableReader.Dispose" /> or <see cref="M:Neon.Csv.CsvTableReader.Close" />
            method when they are finished with the reader so that the underlying <see cref="T:Neon.Csv.CsvReader" />
            will be closed as well, promptly releasing any system resources (such as the stream).
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(Neon.Csv.CsvReader)">
            <summary>
            Constructs an instance to read from a <see cref="T:Neon.Csv.CsvReader" />.
            </summary>
            <param name="reader">The <see cref="T:Neon.Csv.CsvReader" /> to read from.</param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs an instance to read from a <see cref="T:System.IO.TextReader" />.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs an instance to read from a stream.
            </summary>
            <param name="stream">The input stream.</param>
            <param name="encoding">The stream's character <see cref="T:System.Text.Encoding" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.#ctor(System.String)">
            <summary>
            Constructs an instance to read from a CSV string.
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.Dispose">
            <summary>
            Releases any system resources held by the instance,
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.Close">
            <summary>
            Closes the reader if it is still open.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Reader">
            <summary>
            Returns the underlying <see cref="T:Neon.Csv.CsvReader" /> or <c>null</c> if the reader is closed.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Columns">
            <summary>
            Returns the list of table columns in the order read from the source.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.ColumnMap">
            <summary>
            Returns the dictionary that case insensitvely maps a column name to 
            the zero based index of the column.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.ReadRow">
            <summary>
            Reads the next row of table.
            </summary>
            <returns>The list of column values or <c>null</c> if the end of the table has been reached.</returns>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.Rows">
            <summary>
            Returns an enumerator that returns the data rows from a <see cref="T:Neon.Csv.CsvTableReader"/>.
            </summary>
            <returns>The next row as a <see cref="T:System.Collections.Generic.List`1"/>.</returns>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.GetColumn(System.String)">
            <summary>
            Returns the value for the named column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <returns>The column value or <c>null</c> if the column (or row) does not exist.</returns>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Item(System.String)">
            <summary>
            Indexer that returns the value for the named column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <returns>The column value or <c>null</c> if the column (or row) does not exist.</returns>
        </member>
        <member name="P:Neon.Csv.CsvTableReader.Item(System.Int32)">
            <summary>
            Indexer that returns the value for a column.
            </summary>
            <param name="column">The column index.</param>
            <returns>The column value or <c>null</c> if the column (or row) does not exist.</returns>
        </member>
        <member name="M:Neon.Csv.CsvTableReader.IsEmpty(System.String)">
            <summary>
            Determines whether a cell in a named column in the current row is empty or
            if the column does not exist.
            </summary>
            <param name="columnName">The column name.</param>
            <returns><c>true</c> if the cell is empty or the named column is not present.</returns>
        </member>
        <member name="T:Neon.Csv.CsvTableWriter">
            <summary>
            Used to generate a CSV table.
            </summary>
            <remarks>
            <para>
            This class is used to generate a CSV table with column headers with the class
            handling the mapping of column names to columns.  The class is easy to use.  Simply
            construct an instance, passing an array of case insensitive table column header names
            and then write table rows by calling <b>Set()</b> methods to set row cell values
            and then <see cref="M:Neon.Csv.CsvTableWriter.WriteRow" /> to write each row to the output.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.#ctor(System.String[],Neon.Csv.CsvWriter)">
            <summary>
            Constructs an instance to write to a <see cref="T:Neon.Csv.CsvWriter" />.
            </summary>
            <param name="columnHeaders">The table column names.</param>
            <param name="writer">The <see cref="T:Neon.Csv.CsvWriter" /> to write to.</param>
            <remarks>
            <note>
            This method writes the column headers passed to the writer so the
            application can begin writing rows of data.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.#ctor(System.String[],System.IO.TextWriter)">
            <summary>
            Constructs an instance to write to a <see cref="T:System.IO.TextWriter" />.
            </summary>
            <param name="columnHeaders">The table column names.</param>
            <param name="writer">The writer.</param>
            <remarks>
            <note>
            This method writes the column headers passed to the writer so the
            application can begin writing rows of data.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.#ctor(System.String[],System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs an instance to write to a stream.
            </summary>
            <param name="columnHeaders">The table column names.</param>
            <param name="stream">The output stream.</param>
            <param name="encoding">The file's character <see cref="T:System.Text.Encoding" />.</param>
            <remarks>
            <note>
            This method writes the column headers passed to the writer so the
            application can begin writing rows of data.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Dispose">
            <summary>
            Releases any system resources held by the instance,
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Close">
            <summary>
            Closes the reader if it is still open.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableWriter.Writer">
            <summary>
            Returns the underlying <see cref="T:Neon.Csv.CsvWriter" /> or <c>null</c> if the writer is closed.
            </summary>
        </member>
        <member name="P:Neon.Csv.CsvTableWriter.ColumnMap">
            <summary>
            Returns the dictionary that case insensitvely maps a column name to 
            the zero base index of the column.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.GetColumnIndex(System.String)">
            <summary>
            Returns the zero-based index of the specified column.
            </summary>
            <param name="columnName">The column name.</param>
            <returns>The index of the column or <b>-1</b> if the column does not exist.</returns>
        </member>
        <member name="P:Neon.Csv.CsvTableWriter.Row">
            <summary>
            Returns the current row array.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.WriteRow">
            <summary>
            Writes the current row of data to the output and then clears the row
            so the application can begin setting the next row. 
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Set(System.String,System.String)">
            <summary>
            Sets the value of a named table column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <param name="value">The column value.</param>
            <remarks>
            <note>
            This method will do nothing if the <paramref name="columnName" /> 
            passed does not map to a table column.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Csv.CsvTableWriter.Set(System.String,System.Object)">
            <summary>
            Sets the value of a named table column in the current row.
            </summary>
            <param name="columnName">The column name.</param>
            <param name="value">The column value.</param>
            <remarks>
            <note>
            This method will do nothing if the <paramref name="columnName" /> 
            passed does not map to a table column.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Csv.CsvWriter">
            <summary>
            Writes lines of CSV encoded columns to a file or <see cref="T:System.IO.TextWriter" />.
            </summary>
            <threadsafety instance="false" />
        </member>
        <member name="M:Neon.Csv.CsvWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a writer to a stream.
            </summary>
            <param name="stream">The output stream.</param>
            <param name="encoding">The stream's character <see cref="T:System.Text.Encoding" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Constructs a writer to a <see cref="T:System.IO.TextWriter" />.
            </summary>
            <param name="writer">The <see cref="T:System.IO.TextWriter" />.</param>
        </member>
        <member name="M:Neon.Csv.CsvWriter.Close">
            <summary>
            Closes the writer if it is still open.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvWriter.Dispose">
            <summary>
            Releases any resources associated with the reader.
            </summary>
        </member>
        <member name="M:Neon.Csv.CsvWriter.WriteLine(System.Object[])">
            <summary>
            Writes the arguments passed to the output, separating each argument
            with a comma and adding escape characters as necessary.
            </summary>
            <param name="args">The arguments.</param>
        </member>
        <member name="T:Neon.Data.IEnhancedJsonConverter">
            <summary>
            <para>
            Extends the standard <see cref="T:Newtonsoft.Json.JsonConverter"/> by returning the type
            handled by the converter.
            </para>
            <note>
            <see cref="T:Newtonsoft.Json.JsonConverter"/> classes need to implement this interface to be
            automatically supported by classes generated by <b>Neon.CodeGen</b>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Data.IEnhancedJsonConverter.Type">
            <summary>
            Returns the type handled by the converter.
            </summary>
        </member>
        <member name="T:Neon.Data.JsonExtensions">
            <summary>
            Newtonsoft related extension methods.
            </summary>
        </member>
        <member name="M:Neon.Data.JsonExtensions.CopyTo(Newtonsoft.Json.JsonSerializerSettings,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Copies the settings from one <see cref="T:Newtonsoft.Json.JsonSerializerSettings"/> instance to another.
            </summary>
            <param name="source">The source settings.</param>
            <param name="target">The target instance.</param>
        </member>
        <member name="T:Neon.Data.TimeSpanJsonConverter">
            <summary>
            <para>
            Implements a type converter for <see cref="T:System.TimeSpan"/> using the culture
            invariant <b>"c"</b> format.  This serializes <see cref="T:System.TimeSpan"/> instances
            as:
            </para>
            <code>
            [-][d'.']hh':'mm':'ss['.'fffffff]
            </code>
            </summary>
        </member>
        <member name="P:Neon.Data.TimeSpanJsonConverter.Type">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.TimeSpanJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.TimeSpan,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.TimeSpanJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.TimeSpan,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Data.VersionJsonConverter">
            <summary>
            Implements a type converter for <see cref="T:System.Version"/>.
            </summary>
        </member>
        <member name="P:Neon.Data.VersionJsonConverter.Type">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.VersionJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Version,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Data.VersionJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Version,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Data.IGeneratedServiceClient">
            <summary>
            Used to identify a generated ASP.NET service client.
            </summary>
        </member>
        <member name="P:Neon.Data.IGeneratedServiceClient.GeneratorVersion">
            <summary>
            <para>
            Returns the version of the <b>Neon.CodeGen</b> assembly that generated
            this code plus the generated code schema version.  This is formatted like:
            </para>
            <code>
            SEMANTIC-VERSION:SCHEMA
            </code>
            <para>
            where SCHEMA-VERSION is the <b>Neon.CodeGen</b> assembly version and
            SCHEMA is a simple integer schema version number.  The version will be
            incremented if or when the code generated by future versions of the
            <b>Neon.CodeGen</b> assembly changes enough to become incompatable
            with older versions of the <b>Neon.Xunit.XunitExtensions.ValidateController()</b>
            method.  This is likely to never change, but future proofing is always
            a good idea.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Data.IPersistableType">
            <summary>
            Non generic interface describing an entity that can be persisted to a database.
            See <see cref="T:Neon.Data.IPersistableType`1"/> for more information.
            </summary>
        </member>
        <member name="M:Neon.Data.IPersistableType.GetKey">
            <summary>
            <para>
            Returns the Couchbase or other database key to be used to persist or retrieve the entity.
            By convention for Couchbase, this key includes the entity type plus the unique key
            formatted like <b>entity-type</b>::<b>unique-key</b>.  For example:
            </para>
            <code>
            user::122330
            </code>
            <para>
            This identifies the document as a <b>user</b> with unique ID as <b>122330</b>.  Document
            IDs are formatted like this so that we'll be able to take advantage of document filtering
            by type when we've enabled Couchbase cross datacenter replication.
            </para>
            </summary>
            <returns>The database key for the entity.</returns>
        </member>
        <member name="M:Neon.Data.IPersistableType.__Load(Newtonsoft.Json.Linq.JObject,System.Boolean)">
            <summary>
            Loads the entity properties from the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>
            or from the optional <see cref="T:Newtonsoft.Json.Linq.JObject"/> passed.
            </summary>
            <param name="source">Optional source object.</param>
            <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        </member>
        <member name="M:Neon.Data.IPersistableType.__Save">
            <summary>
            Persists the object properties to the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <returns>The backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</returns>
        </member>
        <member name="P:Neon.Data.IPersistableType.__T">
            <summary>
            Identifies the entity type.
            </summary>
        </member>
        <member name="T:Neon.Data.IPersistableType`1">
            <summary>
            Generic interface describing an entity that can be persisted to a database.
            </summary>
            <remarks>
            <para>
            All entities must implement the <see cref="P:Neon.Data.IPersistableType.__T"/> property such that it returns
            the bucket unique string that identifies the entity type.  This string will be
            used to distinguish entity types within a Couchbase bucket.
            </para>
            <para>
            This interface supports the related concepts of entity <b>key</b> and <b>ref</b>.  The
            entity key is the string used to persist an entity instance to Couchbase.  By
            convention, this string is generally prefixed by the entity type and then is
            followed by instance specific properties, a UUID, or a singleton name.
            </para>
            <para>
            Entity <b>ref</b> is the value that other entities can use to reference an entity instance.
            This could be the same as the entity <b>key</b> but typically without the entity
            type prefix for brevity,
            </para>
            <para>
            As a convention, many <see cref="T:Neon.Data.IPersistableType`1"/> implementations also have a <c>static</c>
            <b>GetKey(...)</b> method that returns the Couchbase key for an entity based on parameters passed.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Data.IRoundtripData">
            <summary>
            Used by the <b>Neon.CodeGen</b> assembly to indicate that a class
            was generated as a round-trip data model.
            </summary>
        </member>
        <member name="M:Neon.Data.IRoundtripData.ToString(System.Boolean)">
            <summary>
            Renders the instance as JSON text, optionally formatting the output.
            </summary>
            <param name="indented">Optionally pass <c>true</c> to format the output.</param>
            <returns>The serialized JSON string.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.ToJObject(System.Boolean)">
            <summary>
            Renders the instance as a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <returns>The cloned <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.ToBytes">
            <summary>
            Renders the instance as UTF-8 encoded JSON.
            </summary>
            <returns>The serialized JSON bytes.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.__Load(Newtonsoft.Json.Linq.JObject,System.Boolean)">
            <summary>
            Loads the instance properties from the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/> or
            the optional <paramref name="source"/> parameter.
            </summary>
            <param name="source">The optional source <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <param name="isDerived">Optionally indicates that were deserializing a derived class.</param>
        </member>
        <member name="M:Neon.Data.IRoundtripData.__Save">
            <summary>
            Persists the instance properties to the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <returns>The backing <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</returns>
        </member>
        <member name="M:Neon.Data.IRoundtripData.WriteJsonTo(System.IO.Stream)">
            <summary>
            Writes the instance as JSON to a <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="M:Neon.Data.IRoundtripData.WriteJsonToAsync(System.IO.Stream)">
            <summary>
            Asynchronously writes the instance as JSON to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Data.NotifyPropertyChanged">
            <summary>
            A common implementation of <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            </summary>
        </member>
        <member name="E:Neon.Data.NotifyPropertyChanged.PropertyChanged">
            <summary>
            Raised when an instance property value has changed.
            </summary>
        </member>
        <member name="M:Neon.Data.NotifyPropertyChanged.RaisePropertyChanged(System.String)">
            <summary>
            Derived classes will call this when an property instance property value has changed.
            </summary>
            <param name="propertyName">
            The optional property name.  This defaults to the name of the caller, typically
            the property's setter.  This may also be passed as <c>null</c> signalling that
            all instance properties may have changed.
            </param>
        </member>
        <member name="T:Neon.Data.RoundtripDataFactory">
            <summary>
            Used to instantiate code generated classes that implement <see cref="T:Neon.Data.IRoundtripData"/>
            as generated by the <c>Neon.CodeGen</c> assembly.
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom``1(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Constructs an instance of <typeparamref name="TResult"/> from a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="jObject">The source <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <returns>The new <typeparamref name="TResult"/> instance.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom(System.Type,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Constructs an instance of <paramref name="resultType"/> from a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="jObject">The source <see cref="T:Newtonsoft.Json.Linq.JObject"/>.</param>
            <returns>The new instance as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom``1(System.Byte[])">
            <summary>
            Constructs an instance of <typeparamref name="TResult"/> from a byte array.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="bytes">The source bytes.</param>
            <returns>The new <typeparamref name="TResult"/> instance.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFrom(System.Type,System.Byte[])">
            <summary>
            Constructs an instance of <paramref name="resultType"/> from a byte array.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="bytes">The source bytes.</param>
            <returns>The new instance as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.CreateFromAsync(System.Type,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs an instance of <paramref name="resultType"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="stream">The source <see cref="T:System.IO.Stream"/>.</param>
            <param name="encoding">Optionally specifies the encoding (defaults to UTF-8).</param>
            <returns>The new instance as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataFactory.TryCreateFromAsync(System.Type,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Attempts to construct an instance of <paramref name="resultType"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="resultType">The result type.</param>
            <param name="stream">The source <see cref="T:System.IO.Stream"/>.</param>
            <param name="encoding">Optionally specifies the encoding (defaults to UTF-8).</param>
            <returns>
            <c>true</c> if the object type implements <see cref="T:Neon.Data.IRoundtripData"/> and the 
            object was successfully deserialized.
            </returns>
        </member>
        <member name="T:Neon.Data.RoundtripDataHelper">
            <summary>
            Serialization related helpers used by the code generated
            by the <b>Neon.CodeGen</b> library.
            </summary>
        </member>
        <member name="F:Neon.Data.RoundtripDataHelper.NoHashPropertiesError">
            <summary>
            The error message used when <see cref="M:System.Object.GetHashCode"/> is called on
            a generated data model that has bo properties tagged with [HashSource].
            </summary>
        </member>
        <member name="P:Neon.Data.RoundtripDataHelper.Serializer">
            <summary>
            Returns the Json global serializer.
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.PersistableInitialize">
            <summary>
            <para>
            This examines all loaded assemblies, looking for classes that implement <see cref="T:Neon.Data.IPersistableType"/>
            and then calling each matching type's <c>static PersistableInitialize()</c>  method to ensure that
            the class' type filter is registered with <b>Linq2Couchbase</b>.
            </para>
            <note>
            This method scans the assemblies only the first time the method is called.  Subsequent calls will
            jsut return without doing anything.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.Serialize(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            Serializes a value to JSON text.
            </summary>
            <param name="value">The the value to be serialized.</param>
            <param name="format">Optionally format the output.</param>
            <returns>The JSON text.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.Deserialize``1(System.String)">
            <summary>
            Deserializes a value from JSON text.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="jsonText">The JSON text.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.FromObject(System.Object,System.Type,System.String)">
            <summary>
            Used to convert a value into a <see cref="T:Newtonsoft.Json.Linq.JToken"/> suitable for
            assigning as a property to the backing <see cref="T:Newtonsoft.Json.Linq.JObject"/> of
            a generated data model
            </summary>
            <param name="value">The value being assigned.</param>
            <param name="objectType">The generated data model type.</param>
            <param name="propertyName">The property name.</param>
            <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken"/>.</returns>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.GetPersistedKey(System.String,System.Object[])">
            <summary>
            Generates an database key for a persisted entity.
            </summary>
            <param name="persistedType">The entity type string.</param>
            <param name="args">Arguments identifying the entity.</param>
        </member>
        <member name="M:Neon.Data.RoundtripDataHelper.DeepClone(Newtonsoft.Json.Linq.JObject)">
            <summary>
            Returns a deep clone of a <see cref="T:Newtonsoft.Json.Linq.JObject"/>.
            </summary>
            <param name="jObject">The <see cref="T:Newtonsoft.Json.Linq.JObject"/> or <c>null</c>.</param>
            <returns>The cloned instance.</returns>
        </member>
        <member name="T:Neon.Diagnostics.AssertException">
            <summary>
            Thrown by <see cref="M:System.Diagnostics.Contracts.Covenant.Assert(System.Boolean,System.String)"/> to signal logic failures.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.AssertException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.AssertException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs an assertion with a specific message and optional inner exception.
            </summary>
            <param name="message">The custom message.</param>
            <param name="innerException">Optional inner exception.</param>
        </member>
        <member name="T:Neon.Diagnostics.ILogManager">
            <summary>
            Describes Log Manager implementations.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ILogManager.LogLevel">
            <summary>
            Specifies the level of events to be actually recorded.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.ILogManager.SetLogLevel(System.String)">
            <summary>
            Sets the log level by safely parsing a string.
            </summary>
            <param name="level">The level string or <c>null</c>.</param>
            <remarks>
            <para>
            This method recognizes the following case insensitive values: <b>CRITICAL</b>,
            <b>SERROR</b>, <b>ERROR</b>, <b>WARN</b>, <b>WARNING</b>, <b>INFO</b>, <b>SINFO</b>,
            <b>INFORMATION</b>, <b>DEBUG</b>, or <b>NONE</b>.
            </para>
            <note>
            <b>INFO</b> will be assumed if the parameter doesn't match any of the
            values listed above.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Diagnostics.ILogManager.EmitTimestamp">
            <summary>
            Controls whether timestamps are emitted.  This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.ILogManager.EmitIndex">
            <summary>
            Controls whether the <b>index</b> field is emitted.  This is a counter start
            starts at zero for each application instance and is incremented for each event 
            emitted to help reconstruct exactly what happened when the system time resolution
            isn't fine enough.  This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.ILogManager.GetLogger(System.String)">
            <summary>
            Returns a named logger.
            </summary>
            <param name="sourceModule">The case sensitive logger event source module (defaults to <c>null</c>).</param>
            <returns>The <see cref="T:Neon.Diagnostics.INeonLogger"/> instance.</returns>
        </member>
        <member name="M:Neon.Diagnostics.ILogManager.GetLogger(System.Type)">
            <summary>
            Returns a logger to be associated with a specific type.  This method
            supports both <c>static</c> and normal types.
            </summary>
            <param name="type">The type.</param>
            <returns>The <see cref="T:Neon.Diagnostics.INeonLogger"/> instance.</returns>
        </member>
        <member name="M:Neon.Diagnostics.ILogManager.GetLogger``1">
            <summary>
            Returns a logger to be associated with a specific type.  This
            method works only for non-<c>static</c> types.
            </summary>
            <typeparam name="T">The type.</typeparam>
            <returns>The <see cref="T:Neon.Diagnostics.INeonLogger"/> instance.</returns>
        </member>
        <member name="T:Neon.Diagnostics.INeonLogger">
            <summary>
            Defines the methods and properties for a diagnostics logger. 
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.INeonLogger.IsLogDebugEnabled">
            <summary>
            Returns <c>true</c> if <b>debug</b> logging is enabled.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.INeonLogger.IsLogSInfoEnabled">
            <summary>
            Returns <c>true</c> if <b>sinfo</b> logging is enabled.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.INeonLogger.IsLogInfoEnabled">
            <summary>
            Returns <c>true</c> if <b>info</b> logging is enabled.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.INeonLogger.IsLogWarnEnabled">
            <summary>
            Returns <c>true</c> if <b>warn</b> logging is enabled.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.INeonLogger.IsLogErrorEnabled">
            <summary>
            Returns <c>true</c> if <b>error</b> logging is enabled.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.INeonLogger.IsLogSErrorEnabled">
            <summary>
            Returns <c>true</c> if <b>serror</b> logging is enabled.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.INeonLogger.IsLogCriticalEnabled">
            <summary>
            Returns <c>true</c> if <b>critical</b> logging is enabled.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.IsLogLevelEnabled(Neon.Diagnostics.LogLevel)">
            <summary>
            Indicates whether logging is enabled for a specific log level.
            </summary>
            <param name="logLevel">The log level.</param>
            <returns><c>true</c> if logging is enabled for <paramref name="logLevel"/>.</returns>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogDebug(System.Object,System.String)">
            <summary>
            Logs a <b>debug</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogSInfo(System.Object,System.String)">
            <summary>
            Logs an <b>sinfo</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogInfo(System.Object,System.String)">
            <summary>
            Logs an <b>info</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogWarn(System.Object,System.String)">
            <summary>
            Logs a <b>warn</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogSError(System.Object,System.String)">
            <summary>
            Logs an <b>serror</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogError(System.Object,System.String)">
            <summary>
            Logs an <b>error</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogCritical(System.Object,System.String)">
            <summary>
            Logs a <b>critical</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogDebug(System.Object,System.Exception,System.String)">
            <summary>
            Logs a <b>debug</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogSInfo(System.Object,System.Exception,System.String)">
            <summary>
            Logs an <b>sinfo</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogInfo(System.Object,System.Exception,System.String)">
            <summary>
            Logs an <b>info</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogWarn(System.Object,System.Exception,System.String)">
            <summary>
            Logs a <b>warn</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogError(System.Object,System.Exception,System.String)">
            <summary>
            Logs an <b>error</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogSError(System.Object,System.Exception,System.String)">
            <summary>
            Logs an <b>serror</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogCritical(System.Object,System.Exception,System.String)">
            <summary>
            Logs a <b>critical</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogMetrics(Neon.Diagnostics.LogLevel,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Logs text and numeric metrics.
            </summary>
            <param name="level">The log level.</param>
            <param name="textFields">The text fields (or <c>null</c>).</param>
            <param name="numFields">The numeric fields (or <c>null</c>).</param>
            <exception cref="T:System.ArgumentException">
            Thrown if either of <paramref name="textFields"/> or <paramref name="numFields"/> 
            includes more than 10 items.
            </exception>
            <remarks>
            <para>
            This can be used to log text and/or numeric metrics in a log event.
            Text fields will be written to the logged event like <b>[txt.#=VALUE]</b>
            where <b>#</b> is the field index [0-9].  Numeric fields will be
            written as <b>[num.#=VALUE]</b>.
            </para>
            <para>
            The <b>neon-log-collector</b> service will recognizes these and
            persist them as <b>txt.#=VALUE</b> and <b>num.#=VALUE</b> fields
            in the Elasticsearch <b>logstash-*</b> index.
            </para>
            <note>
            Up to 10 of each type of metric can be passed.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogMetrics(Neon.Diagnostics.LogLevel,System.String[])">
            <summary>
            Logs text metrics.
            </summary>
            <param name="level">The log level.</param>
            <param name="textFields">The text fields (or <c>null</c>).</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="textFields"/> includes more than 10 items.
            </exception>
            <remarks>
            <para>
            This can be used to log text metrics in a log event.  Text fields will 
            be written to the logged event like <b>[txt.#=VALUE]</b> where
            <b>#</b> is the field index [0-9].
            </para>
            <para>
            The <b>neon-log-collector</b> service will recognizes these and
            persist them as <b>txt.#=VALUE</b> fields in the Elasticsearch 
            <b>logstash-*</b> index.
            </para>
            <note>
            Up to 10 metrics can be passed.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.INeonLogger.LogMetrics(Neon.Diagnostics.LogLevel,System.Double[])">
            <summary>
            Logs numeric metrics.
            </summary>
            <param name="level">The log level.</param>
            <param name="numFields">The numeric fields (or <c>null</c>).</param>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="numFields"/> includes more than 10 items.
            </exception>
            <remarks>
            <para>
            This can be used to log numeric metrics in a log event.  Numeric fields
            will  be written to the logged event like <b>[num.#=VALUE]</b> where
            <b>#</b> is the field index [0-9].
            </para>
            <para>
            The <b>neon-log-collector</b> service will recognizes these and
            persist them as <b>num.#=VALUE</b> fields in the Elasticsearch 
            <b>logstash-*</b> index.
            </para>
            <note>
            Up to 10 metrics can be passed.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Diagnostics.LogActivity">
            <summary>
            Used to help log correlate lower-level operations with a higher-level activity.
            </summary>
            <remarks>
            <para>
            This structure is intended to help operators and developers correlate lower-level
            operations with higher level activities that may span multiple systems and services.
            </para>
            <para>
            The essential idea is to associate a globally unique ID with a high-level activity
            and then include this ID along with events logged by the various systems and
            services that participate in the activity.  Ultimately, the logged events with
            the activity IDs will make it to Elasticsearch or some other log database where
            activaty events potentially spanning many systems can be correlated and analyzed.
            </para>
            <para>
            An activity ID is simply a globally unique ID string.  IDs generated by this class
            are a currently stringified <see cref="T:System.Guid"/> but IDs may take other forms so,
            don't depend on this.
            </para>
            <para>
            In general, activity IDs are passed from service to service via the HTTP <b>X-Request-ID</b>
            request header (defined by <see cref="F:Neon.Diagnostics.LogActivity.HttpHeader"/>).
            </para>
            <para>
            To use this type, call the static <see cref="M:Neon.Diagnostics.LogActivity.Create(Neon.Diagnostics.INeonLogger)"/> method to create a new activity
            or <see cref="M:Neon.Diagnostics.LogActivity.From(System.String,Neon.Diagnostics.INeonLogger)"/> to associate an instance with an existing activity.
            Then use the various logging methods to emit log events what will include the activity ID.
            </para>
            </remarks>
        </member>
        <member name="F:Neon.Diagnostics.LogActivity.HttpHeader">
            <summary>
            Names the HTTP header used to hold the activity ID used to correlate 
            operation requests with a higher-level activity.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Create(Neon.Diagnostics.INeonLogger)">
            <summary>
            Creates a log activity with a new globally unique ID.
            </summary>
            <param name="log">The optional associated <see cref="T:Neon.Diagnostics.INeonLogger"/>.</param>
            <returns>The created <see cref="T:Neon.Diagnostics.LogActivity"/>.</returns>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.From(System.String,Neon.Diagnostics.INeonLogger)">
            <summary>
            Creates a log activity with the ID specified.
            </summary>
            <param name="activityId">The activity ID or <c>null</c>,</param>
            <param name="log">The optional associated <see cref="T:Neon.Diagnostics.INeonLogger"/>.</param>
            <returns>The created <see cref="T:Neon.Diagnostics.LogActivity"/>.</returns>
        </member>
        <member name="P:Neon.Diagnostics.LogActivity.Id">
            <summary>
            Returns the activity ID.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Debug(System.Object)">
            <summary>
            Logs a <b>debug</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Info(System.Object)">
            <summary>
            Logs an <b>info</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Warn(System.Object)">
            <summary>
            Logs a <b>warn</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Error(System.Object)">
            <summary>
            Logs an <b>error</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Critical(System.Object)">
            <summary>
            Logs a <b>critical</b> message.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Debug(System.Object,System.Exception)">
            <summary>
            Logs a <b>debug</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Info(System.Object,System.Exception)">
            <summary>
            Logs an <b>info</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Warn(System.Object,System.Exception)">
            <summary>
            Logs a <b>warn</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Error(System.Object,System.Exception)">
            <summary>
            Logs an <b>error</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogActivity.Critical(System.Object,System.Exception)">
            <summary>
            Logs a <b>critical</b> message along with exception information.
            </summary>
            <param name="message">The object that will be serialized into the message.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="T:Neon.Diagnostics.LogExtensions">
            <summary>
            Extends the <see cref="T:Neon.Diagnostics.INeonLogger"/> types.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogDebug(Neon.Diagnostics.INeonLogger,System.Func{System.Object})">
            <summary>
            Logs a debug message retrieved via a message function.
            </summary>
            <param name="log">The log.</param>
            <param name="messageFunc">The message function.</param>
            <remarks>
            This method is intended mostly to enable the efficient use of interpolated C# strings.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogInfo(Neon.Diagnostics.INeonLogger,System.Func{System.Object})">
            <summary>
            Logs an informational message retrieved via a message function.
            </summary>
            <param name="log">The log.</param>
            <param name="messageFunc">The message function.</param>
            <remarks>
            This method is intended mostly to enable the efficient use of interpolated C# strings.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogWarn(Neon.Diagnostics.INeonLogger,System.Func{System.Object})">
            <summary>
            Logs a warning message retrieved via a message function.
            </summary>
            <param name="log">The log.</param>
            <param name="messageFunc">The message function.</param>
            <remarks>
            This method is intended mostly to enable the efficient use of interpolated C# strings.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogError(Neon.Diagnostics.INeonLogger,System.Func{System.Object})">
            <summary>
            Logs an error message retrieved via a message function.
            </summary>
            <param name="log">The log.</param>
            <param name="messageFunc">The message function.</param>
            <remarks>
            This method is intended mostly to enable the efficient use of interpolated C# strings.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogCritical(Neon.Diagnostics.INeonLogger,System.Func{System.Object})">
            <summary>
            Logs a critical message retrieved via a message function.
            </summary>
            <param name="log">The log.</param>
            <param name="messageFunc">The message function.</param>
            <remarks>
            This method is intended mostly to enable the efficient use of interpolated C# strings.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogDebug(Neon.Diagnostics.INeonLogger,System.Exception)">
            <summary>
            Logs a debug exception.
            </summary>
            <param name="log">The log.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogInfo(Neon.Diagnostics.INeonLogger,System.Exception)">
            <summary>
            Logs an info exception.
            </summary>
            <param name="log">The log.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogWarn(Neon.Diagnostics.INeonLogger,System.Exception)">
            <summary>
            Logs a warning exception.
            </summary>
            <param name="log">The log.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogError(Neon.Diagnostics.INeonLogger,System.Exception)">
            <summary>
            Logs an error exception.
            </summary>
            <param name="log">The log.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogExtensions.LogCritical(Neon.Diagnostics.INeonLogger,System.Exception)">
            <summary>
            Logs a critical exception.
            </summary>
            <param name="log">The log.</param>
            <param name="e">The exception.</param>
        </member>
        <member name="T:Neon.Diagnostics.LogLevel">
            <summary>
            Enumerates the possible log levels.  Note that the relative
            ordinal values of  these definitions are used when deciding
            to log an event when a specific <see cref="T:Neon.Diagnostics.LogLevel"/> is 
            set.  Only events with log levels less than or equal to the
            current level will be logged.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.None">
            <summary>
            Logging is disabled.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.Critical">
            <summary>
            A critical or fatal error has been detected.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.SError">
            <summary>
            A security related error has occurred.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.Error">
            <summary>
            An error has been detected. 
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.Warn">
            <summary>
            An unusual condition has been detected that may ultimately lead to an error.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.Info">
            <summary>
            Describes a normal operation or condition.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.SInfo">
            <summary>
            Describes a non-error security operation or condition, such as a 
            a login or authentication.
            </summary>
        </member>
        <member name="F:Neon.Diagnostics.LogLevel.Debug">
            <summary>
            Describes detailed debug or diagnostic information.
            </summary>
        </member>
        <member name="T:Neon.Diagnostics.LogManager">
            <summary>
            Global class used to manage application logging.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogManager.Default">
            <summary>
            <para>
            The default <see cref="T:Neon.Diagnostics.ILogManager"/> that can be used by applications that don't
            use dependency injection.  This defaults to an instance of <see cref="T:Neon.Diagnostics.LogManager"/>
            but can be set to something else for unit tests or early in application startup.
            </para>
            <para>
            Applications that do use dependency injection can obtain this by default via
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/>.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogManager.Disabled">
            <summary>
            Returns a <b>log-nothing</b> log manager.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.#ctor(System.Boolean,System.IO.TextWriter)">
            <summary>
            Default constructor.
            </summary>
            <param name="parseLogLevel">Indicates that the <b>LOG-LEVEL</b> environment variable should be parsed (defaults to <c>true</c>).</param>
            <param name="writer">Optionally specifies the output writer.  This defaults to <see cref="P:System.Console.Error"/>.</param>
        </member>
        <member name="P:Neon.Diagnostics.LogManager.LogLevel">
            <summary>
            Specifies the level of events to be actually recorded.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.SetLogLevel(System.String)">
            <summary>
            Sets the log level by safely parsing a string.
            </summary>
            <param name="level">The level string or <c>null</c>.</param>
            <remarks>
            <para>
            This method recognizes the following case insensitive values: <b>CRITICAL</b>,
            <b>SERROR</b>, <b>ERROR</b>, <b>WARN</b>, <b>WARNING</b>, <b>INFO</b>, <b>SINFO</b>,
            <b>INFORMATION</b>, <b>DEBUG</b>, or <b>NONE</b>.
            </para>
            <note>
            <b>INFO</b> will be assumed if the parameter doesn't match any of the
            values listed above.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Diagnostics.LogManager.EmitTimestamp">
            <summary>
            Controls whether timestamps are emitted.  This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.Diagnostics.LogManager.EmitIndex">
            <summary>
            Controls whether the <b>index</b> field is emitted.  This is a counter start
            starts at zero for each application instance and is incremented for each event 
            emitted to help reconstruct exactly what happened when the system time resolution
            isn't fine enough.  This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.InternalGetLogger(System.String,System.IO.TextWriter)">
            <summary>
            Returns the logger for the existing name.
            </summary>
            <param name="name">The case sensitive logger name.</param>
            <param name="writer">Optionally specifies the output writer.  This defaults to <see cref="P:System.Console.Error"/>.</param>
            <returns>The <see cref="T:Neon.Diagnostics.INeonLogger"/> instance.</returns>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.GetLogger(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.GetLogger(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.GetLogger``1">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogManager.CreateLogger(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.LogRecorder">
            <summary>
            Simple class that can be used to capture log entries while also passing them
            through to a base <see cref="T:Neon.Diagnostics.INeonLogger"/> implementation.
            </summary>
            <remarks>
            <para>
            Instantiate by passing a base <see cref="T:Neon.Diagnostics.INeonLogger"/> implementation to the constructor.
            All of the logging properties and methods calls to this class will pass through
            to the base implementation and enabled log methods will also be collected by the
            instance.  Use <see cref="M:Neon.Diagnostics.LogRecorder.ToString"/> to return the captured text and <see cref="M:Neon.Diagnostics.LogRecorder.Clear"/>
            to clear it.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.#ctor(Neon.Diagnostics.INeonLogger)">
            <summary>
            Constructor.
            </summary>
            <param name="log">The inderlying <see cref="T:Neon.Diagnostics.INeonLogger"/> implementation.</param>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.Clear">
            <summary>
            Clears the captured text.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.ToString">
            <summary>
            Returns the captured log text.
            </summary>
            <returns>The text.</returns>
        </member>
        <member name="P:Neon.Diagnostics.LogRecorder.IsLogDebugEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.LogRecorder.IsLogSInfoEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.LogRecorder.IsLogInfoEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.LogRecorder.IsLogWarnEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.LogRecorder.IsLogErrorEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.LogRecorder.IsLogSErrorEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.LogRecorder.IsLogCriticalEnabled">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.IsLogLevelEnabled(Neon.Diagnostics.LogLevel)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogDebug(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogSInfo(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogInfo(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogWarn(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogError(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogSError(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogCritical(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogDebug(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogSInfo(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogInfo(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogWarn(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogError(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogSError(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogCritical(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogMetrics(Neon.Diagnostics.LogLevel,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogMetrics(Neon.Diagnostics.LogLevel,System.String[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.LogMetrics(Neon.Diagnostics.LogLevel,System.Double[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.LogRecorder.Record(System.String)">
            <summary>
            Logs a line of text directly to the log recorder without also logging it to
            to the underlying <see cref="T:Neon.Diagnostics.INeonLogger"/> implementation.
            </summary>
            <param name="message">The optional message to be recorded.</param>
        </member>
        <member name="T:Neon.Diagnostics.NeonLogger">
            <summary>
            A general purpose implementation of <see cref="T:Neon.Diagnostics.INeonLogger"/> and <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.FormatMetrics(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Formats metric fields into a message.
            </summary>
            <param name="txtFields">The text fields (or <c>null</c>).</param>
            <param name="numFields">The numeric fields (or <c>null</c>).</param>
            <exception cref="T:System.ArgumentException">
            Thrown if either of <paramref name="txtFields"/> or <paramref name="numFields"/> 
            includes more than 10 items.
            </exception>
            <returns>The formatted message.</returns>
        </member>
        <member name="P:Neon.Diagnostics.NeonLogger.IsLogDebugEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLogger.IsLogErrorEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLogger.IsLogSErrorEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLogger.IsLogCriticalEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLogger.IsLogInfoEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLogger.IsLogSInfoEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLogger.IsLogWarnEnabled">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.#ctor(Neon.Diagnostics.ILogManager,System.String,System.Boolean,System.IO.TextWriter)">
            <summary>
            Constructs a named instance.
            </summary>
            <param name="logManager">The parent log manager or <c>null</c>.</param>
            <param name="sourceModule">Optionally identifies the event source module or <c>null</c>.</param>
            <param name="noisyAspNet">Optionally enables normal (noisy) logging of ASP.NET <b>INFO</b> events (see note in remarks).</param>
            <param name="writer">Optionally specifies the output writer.  This defaults to <see cref="P:System.Console.Error"/>.</param>
            <remarks>
            <para>
            The instances returned will log nothing if <paramref name="logManager"/>
            is passed as <c>null</c>.
            </para>
            <note>
            <para>
            ASP.NET is super noisy, logging three or four <b>INFO</b> events per request.  There
            doesn't appear to an easy way to change this behavior, I'd really like to recategorize
            these as <b>DEBUG</b> to reduce pressure on the logs.
            </para>
            <para>
            We accomplish this by default when <paramref name="noisyAspNet"/> is passed as
            <c>false</c>.  This is used to signal that the instance should perform special 
            ASP.NET level filtering.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.IsLogLevelEnabled(Neon.Diagnostics.LogLevel)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.Normalize(System.String)">
            <summary>
            Normalizes a log message by escaping any backslashes and replacing any line
            endings with "\n".  This converts multi-line message to a single line.
            </summary>
            <param name="message">The message.</param>
            <returns>The normalized message.</returns>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.Log(Neon.Diagnostics.LogLevel,System.String,System.String)">
            <summary>
            Logs an event.
            </summary>
            <param name="logLevel">The event level.</param>
            <param name="message">The event message.</param>
            <param name="activityId">The optional activity ID.</param>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogDebug(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogDebug(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogError(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogError(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogSError(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogSError(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogCritical(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogCritical(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogInfo(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogInfo(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogSInfo(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogSInfo(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogWarn(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogWarn(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.NeonLogger.Scope">
            <summary>
            Do-nothing disposable returned by <see cref="M:Neon.Diagnostics.NeonLogger.BeginScope``1(``0)"/>.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.Scope.#ctor">
            <summary>
            Internal connstructor.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.Scope.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.ToNeonLevel(Microsoft.Extensions.Logging.LogLevel)">
            <summary>
            Converts a Microsoft log level into the corresponding Neon level.
            </summary>
            <param name="logLevel">The Microsoft log level.</param>
            <returns>The Neon <see cref="T:Neon.Diagnostics.LogLevel"/>.</returns>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogMetrics(Neon.Diagnostics.LogLevel,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogMetrics(Neon.Diagnostics.LogLevel,System.String[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.LogMetrics(Neon.Diagnostics.LogLevel,System.Double[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLogger.BeginScope``1(``0)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Diagnostics.NeonLoggerShim">
            <summary>
            Wraps a standard <see cref="T:Microsoft.Extensions.Logging.ILogger"/> adding <see cref="T:Neon.Diagnostics.INeonLogger"/> capabilities.
            </summary>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.WrapLogger(Microsoft.Extensions.Logging.ILogger,System.IO.TextWriter)">
            <summary>
            Converts an <see cref="T:Microsoft.Extensions.Logging.ILogger"/> into an instance that implements <see cref="T:Neon.Diagnostics.INeonLogger"/>,
            wrapping the instance passed with a <see cref="T:Neon.Diagnostics.NeonLoggerShim"/> if required.
            </summary>
            <param name="logger">The <see cref="T:Microsoft.Extensions.Logging.ILogger"/> to be converted.</param>
            <param name="writer">Optionally specifies the output writer.  This defaults to <see cref="P:System.Console.Error"/>.</param>
            <returns>The <see cref="T:Neon.Diagnostics.INeonLogger"/>.</returns>
            <remarks>
            This method will return a <b>log-nothing</b> instance is <paramref name="logger"/> is <c>null</c>.
            </remarks>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.#ctor(Microsoft.Extensions.Logging.ILogger)">
            <summary>
            Constructor.
            </summary>
            <param name="logger">The <see cref="T:Microsoft.Extensions.Logging.ILogger"/> to be wrapped.</param>
        </member>
        <member name="P:Neon.Diagnostics.NeonLoggerShim.IsLogDebugEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLoggerShim.IsLogErrorEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLoggerShim.IsLogSErrorEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLoggerShim.IsLogCriticalEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLoggerShim.IsLogInfoEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLoggerShim.IsLogSInfoEnabled">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Diagnostics.NeonLoggerShim.IsLogWarnEnabled">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.IsLogLevelEnabled(Neon.Diagnostics.LogLevel)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.Normalize(System.String)">
            <summary>
            Normalizes a log message by escaping any backslashes and replacing any line
            endings with "\n".  This converts multi-line message to a single line.
            </summary>
            <param name="text">The message text.</param>
            <returns>The normalized message.</returns>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.FormatMessage(System.Object,System.String)">
            <summary>
            Formats the log message.
            </summary>
            <param name="message">The message object.</param>
            <param name="activityId">The optional activiity ID.</param>
            <returns></returns>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogDebug(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogSInfo(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogInfo(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogWarn(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogSError(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogError(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogCritical(System.Object,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogDebug(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogSInfo(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogInfo(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogWarn(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogError(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogSError(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogCritical(System.Object,System.Exception,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogMetrics(Neon.Diagnostics.LogLevel,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogMetrics(Neon.Diagnostics.LogLevel,System.String[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.LogMetrics(Neon.Diagnostics.LogLevel,System.Double[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.Log``1(Microsoft.Extensions.Logging.LogLevel,Microsoft.Extensions.Logging.EventId,``0,System.Exception,System.Func{``0,System.Exception,System.String})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Diagnostics.NeonLoggerShim.BeginScope``1(``0)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.BlockStream">
            <summary>
            Implements an in-memory stream based on a collection of <see cref="T:Neon.Common.Block"/> 
            buffers rather than a single byte buffer.  This is more efficient than
            <see cref="T:System.IO.MemoryStream"/> for large streams and also avoids allocations
            in the large object heap.
            </summary>
            <remarks>
            <note>
            Buffer array streams cannot be greater than or equal to 2GiB in length.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor">
            <summary>
            Constructs a zero length stream with default block size.
            </summary>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Int32)">
            <summary>
            Constructs a stream of the specified size using the default
            block size.
            </summary>
            <param name="size">The stream size in bytes.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a stream of the specified size using the 
            specified block size.
            </summary>
            <param name="size">The stream size in bytes.</param>
            <param name="blockSize">The block size in bytes.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a stream of the specified size using the 
            specified block size and offset.
            </summary>
            <param name="size">The stream size in bytes.</param>
            <param name="blockSize">The block size in bytes.</param>
            <param name="blockOffset">Bytes to be reserved at the beginning of each new block.</param>
            <remarks>
            See <see cref="T:Neon.Common.BlockArray"/> for more information on
            the value and use of the blockOffset prarmeter.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(Neon.Common.BlockArray)">
            <summary>
            Constructs a stream from the blocks passed.
            </summary>
            <param name="blocks">The blocks.</param>
            <remarks>
            The stream size will be set to the size of the blocks.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(Neon.Common.Block[])">
            <summary>
            Constructs a stream from the blocks passed.
            </summary>
            <param name="blocks">The blocks.</param>
            <remarks>
            The stream size will be set to the size of the blocks.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.#ctor(System.Byte[])">
            <summary>
            Constructs a stream from a byte array.
            </summary>
            <param name="buffer">The byte array.</param>
        </member>
        <member name="P:Neon.IO.BlockStream.CanRead">
            <summary>
            Returns <c>true</c> if the stream supports read operations.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.CanWrite">
            <summary>
            Returns <c>true</c> if the stream supports write operations.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.CanSeek">
            <summary>
            Returns <c>true</c> if the stream supports seek operations.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.Length">
            <summary>
            Returns the current size of the stream in bytes.
            </summary>
        </member>
        <member name="P:Neon.IO.BlockStream.Position">
            <summary>
            The current stream position.
            </summary>
            <remarks>
            <note>
            It is valid to set a stream position beyond the current
            end of the stream.  The stream will be extended to this position.
            The contents of the extended portion will be undefined.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream.
            </summary>
            <param name="value">The new length in bytes.</param>
            <remarks>
            The stream will be truncated if the new length is less than
            the current length.  The stream will be extended if the new
            length is greater than the current length.  In this case,
            the contents of the extended portion will be undefined.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.SetLength(System.Int64,System.Boolean)">
            <summary>
            Sets the length of the stream.
            </summary>
            <param name="value">The new length in bytes.</param>
            <param name="modifyBlocks"><c>true</c> to modify the underlying block array if necessary.</param>
            <remarks>
            The modifyBlocks parameter specifies whether the underlying
            block array will be truncated or extended to the length
            specified.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.ReadByte">
            <summary>
            Reads a byte from the current stream position, advancing
            the position by 1.
            </summary>
            <returns>The byte read or <b>-1</b> if the end of the stream has been reached.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from the current stream position, advancing the
            position past the data read.
            </summary>
            <param name="buffer">The destination buffer.</param>
            <param name="offset">Offset where the read data is to be copied.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>The number of bytes actually read.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously reads from the stream.
            </summary>
            <param name="buffer">The destination buffer.</param>
            <param name="offset">Offset where the read data is to be copied.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The number of bytes actually read.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current stream position, advancing the
            position by 1.
            </summary>
            <param name="value">The byte to write.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes to the stream at the current position, advancing
            the position past the data written.
            </summary>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Offset of the first byte to write.</param>
            <param name="count">Number of bytes to read.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Asynchronously writes bytes to the stream at the current position, advancing
            the position past the data written.
            </summary>
            <param name="buffer">The source buffer.</param>
            <param name="offset">Offset of the first byte to write.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Neon.IO.BlockStream.Flush">
            <summary>
            Flushes any stream buffers.
            </summary>
            <remarks>
            This is a NOP for this implementation.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Moves the current stream position relative to the specified origin.
            </summary>
            <param name="offset">The positional offset.</param>
            <param name="origin">Specifies the seek origin.</param>
            <returns>The stream position after the seek.</returns>
            <remarks>
            It is valid to seek past the current stream length.  In this
            case, the stream will be extended with the contents of the
            extended portion being undefined.
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.Append(Neon.Common.Block)">
            <summary>
            Appends a block to the end of the underlying BlockArray.
            </summary>
            <param name="block">The block to append.</param>
            <remarks>
            <para>
            The underyling block array's SetExactSize() method will be
            called before appending the block.  The stream position will
            be set to the end of the stream before the method returns.
            </para>
            <para>
            This method is a performance improvement over writing the
            a buffer to the stream via one of the write methods.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.IO.BlockStream.Append(Neon.Common.BlockArray)">
            <summary>
            Appends a block array to the end of the underlying BlockArray.
            </summary>
            <param name="blocks">The array to append.</param>
            <remarks>
            The underyling block array's SetExactSize() method will be
            called before appending the block.  The stream position will
            be set to the end of the stream before the method returns.
            
            This method is a performance improvement over writing the
            a buffer to the stream via one of the write methods.
            </remarks>
        </member>
        <member name="P:Neon.IO.BlockStream.RawBlockArray">
            <summary>
            Returns the underlying block array without modification.
            </summary>
        </member>
        <member name="M:Neon.IO.BlockStream.ToBlocks(System.Boolean)">
            <summary>
            Returns the underlying buffer array.
            </summary>
            <param name="truncate">
            <c>true</c> if the method will truncate the underlying BlockArray
            to the actual length of the stream before returning the array.
            </param>
        </member>
        <member name="M:Neon.IO.BlockStream.ToArray">
            <summary>
            Assembles a contiguous a byte array from the underlying
            buffer array.
            </summary>
            <returns>The assembled byte array.</returns>
        </member>
        <member name="M:Neon.IO.BlockStream.ReadBlocks(System.Int32)">
            <summary>
            Returns requested bytes from the underlying block array as
            as a new block array.
            </summary>
            <param name="cb">The nunber of bytes to read.</param>
            <returns>
            A new block array referencing the requested bytes in the
            same underlying buffers as managed by then stream.
            </returns>
            <remarks>
            This provides a high performance way for code that knows
            how to handle block arrays to extract a portion of a stream.
            
            The array returned will be truncated to the length of the
            underlying stream.  The stream position will be advanced
            past the requested bytes.
            </remarks>
        </member>
        <member name="T:Neon.IO.LineEnding">
            <summary>
            Enumerates the possible line ending modes.
            </summary>
        </member>
        <member name="F:Neon.IO.LineEnding.Platform">
            <summary>
            Use platform specific line endings.
            </summary>
        </member>
        <member name="F:Neon.IO.LineEnding.CRLF">
            <summary>
            Windows style line endings using carriage return and line feed characters.
            </summary>
        </member>
        <member name="F:Neon.IO.LineEnding.LF">
            <summary>
            Unix/Linux style line endings using just a line feed.
            </summary>
        </member>
        <member name="T:Neon.IO.LinuxPath">
            <summary>
            Implements functionality much like <see cref="T:System.IO.Path"/>, except for
            this class is oriented towards handling Linux-style paths on
            a remote (possibly a Windows) machine.
            </summary>
        </member>
        <member name="M:Neon.IO.LinuxPath.ToLinux(System.String)">
            <summary>
            Converts a Windows style path to Linux.
            </summary>
            <param name="path">The source path.</param>
            <returns>The converted path.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.ChangeExtension(System.String,System.String)">
            <summary>
            Changes the file extension.
            </summary>
            <param name="path">The file path.</param>
            <param name="extension">The new extension.</param>
            <returns>The modified path.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.Combine(System.String[])">
            <summary>
            Combines an array of strings into a path.
            </summary>
            <param name="paths">The paths.</param>
            <returns>The combined paths.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetDirectoryName(System.String)">
            <summary>
            Extracts the directory portion of a path.
            </summary>
            <param name="path">The path.</param>
            <returns>The directory portion.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetExtension(System.String)">
            <summary>
            Returns the file extension from a path.
            </summary>
            <param name="path">The path.</param>
            <returns>The file extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetFileName(System.String)">
            <summary>
            Returns the file name and extension from a path.
            </summary>
            <param name="path">The path.</param>
            <returns>The file name and extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.GetFileNameWithoutExtension(System.String)">
            <summary>
            Returns the file name from a path without the extension.
            </summary>
            <param name="path">The path.</param>
            <returns>The file name without the extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.HasExtension(System.String)">
            <summary>
            Determines whether a path has a file extension.
            </summary>
            <param name="path">The path.</param>
            <returns><c>true</c> if the path has an extension.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPath.IsPathRooted(System.String)">
            <summary>
            Determines whether the path is rooted.
            </summary>
            <param name="path">The path.</param>
            <returns><c>true</c> ifc the path is rooted.</returns>
        </member>
        <member name="T:Neon.IO.LinuxPermissions">
            <summary>
            Manipulates Linux style file permissions.
            </summary>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.IsValidDigit(System.Char)">
            <summary>
            Verifies that the character passed is a valid permissions digit.
            </summary>
            <param name="digit">The permissions digit.</param>
            <returns><c>true</c> if the digit is valid.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.TryParse(System.String,Neon.IO.LinuxPermissions@)">
            <summary>
            Attempts to parse permissions from an octal string.
            </summary>
            <param name="input">The input string.</param>
            <param name="permissions">Returns as the parsed permissions.</param>
            <returns><c>true</c> if valid permissions were parsed.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.Set(System.String,System.String,System.Boolean)">
            <summary>
            Sets the Linux file permissions.
            </summary>
            <param name="path">Path to the target file or directory.</param>
            <param name="mode">Linux file permissions.</param>
            <param name="recursive">Optionally apply the permissions recursively.</param>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.#ctor(System.String)">
            <summary>
            Constructs permissions from an octal string.
            </summary>
            <param name="input">The permissions string encoded in their octal form.</param>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.OwnerRead">
            <summary>
            The owner can read the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.OwnerWrite">
            <summary>
            The owner can modify the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.OwnerExecute">
            <summary>
            The owner can execute the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.GroupRead">
            <summary>
            The group can read the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.GroupWrite">
            <summary>
            The group can modify the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.GroupExecute">
            <summary>
            The group can execute the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.AllRead">
            <summary>
            Everyone can read the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.AllWrite">
            <summary>
            Everyone can modify the file.
            </summary>
        </member>
        <member name="P:Neon.IO.LinuxPermissions.AllExecute">
            <summary>
            Everyone can execute the file.
            </summary>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.ToOctal(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Converts the permissions passed into the equivalent octal character.
            </summary>
            <param name="read">Read flag.</param>
            <param name="write">Write flag.</param>
            <param name="execute">Execute flag.</param>
            <returns>The octal character.</returns>
        </member>
        <member name="M:Neon.IO.LinuxPermissions.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.PreprocessReader">
            <summary>
            Preprocesses text returned by a <see cref="T:System.IO.TextReader"/> by removing comments,
            expanding variables, and implementing simple conditionals.
            </summary>
            <remarks>
            <note>
            This class only implements <see cref="M:Neon.IO.PreprocessReader.ReadLine"/>, <see cref="M:Neon.IO.PreprocessReader.ReadLineAsync"/>,
            <see cref="M:Neon.IO.PreprocessReader.ReadToEnd"/>, and <see cref="M:Neon.IO.PreprocessReader.ReadToEndAsync"/>.  The other methods
            will throw a <see cref="T:System.NotImplementedException"/>.
            </note>
            <para>
            The processor removes comment lines from the text returned.  A comment line 
            starts with zero or more whitespace characters followed by "<b>//</b>".
            </para>
            <para>
            The processor implements simple macro definition and conditional statements.
            These statements are identifying by a line with the pound sign (<b>#</b>) as
            the first non-whitespace character.
            </para>
            <note>
            The processor statement character can be changed by setting <see cref="P:Neon.IO.PreprocessReader.StatementMarker"/>.
            </note>
            <para>
            The following processing statements are supported:
            </para>
            <list type="table">
            <item>
                <term><b>#define NAME [=VALUE]</b></term>
                <description>
                <para>
                Defines a normal variable and setting an optional value.  The empty
                string will be set by default.  These variables can be referenced
                in processing statements or normal text lines as <b>$&lt;name&gt;</b>.
                </para>
                <para>
                Variable names are case sensitive and may include letter, number, dash,
                period, and underscore characters.
                </para>
                <para>
                By default, defined variables may be referenced like <b>$&lt;name&gt;</b> and
                environment variables like <b>$&lt;&lt;name&gt;&gt;</b>.
                </para>
                </description>
            </item>
            <item>
                <term><b>#if EXPRESSION</b></term>
                <description>
                <para>
                Conditionally includes text up to the next <b>#else</b> or
                <b>#endif</b> statement.  The following expressions are
                supported:
                </para>
                <list type="bullet">
                    <item><b>VALUE1 == VALUE2</b></item>
                    <item><b>VALUE1 != VALUE2</b></item>
                    <item><b>defined(NAME)</b></item>
                    <item><b>undefined(NAME)</b></item>
                </list>
                <para>
                The comparisions are performed after any variables are expanded.  The
                values are trimmed on bothe ends and the string comparision is case
                sensitive.
                </para>
                </description>
            </item>
            <item>
                <term><b>#else</b></term>
                <description>
                This can optionally be used within an <b>#if</b> statement to include lines
                when the condition is false.
                </description>
            </item>
            <item>
                <term><b>#endif</b></term>
                <description>
                This terminates an <b>#if</b> statement.
                </description>
            </item>
            <item>
                <term><b>#switch VALUE</b></term>
                <description>
                Provides an easy to conditionally include statements for multiple conditions.
                The subsequent  <b>#case</b> and <b>#default</b> statements up to the next 
                <b>#endswitch</b> statement will be processed.
                </description>
            </item>
            <item>
                <term><b>#case VALUE</b></term>
                <description>
                This command causes the lines up to the next <b>#case</b>, <b>#default</b>,
                or <b>#endswitch</b> to be outputed if the value matches that specified for
                the parent <b>#switch</b> statement.
                </description>
            </item>
            <item>
                <term><b>#default</b></term>
                <description>
                This command causes the lines up to the next <b>#endswitch</b> to be outputed
                if the value wasn't matched by any of the previous <b>case</b> statements.
                <note>
                <b>#default</b> must appear after all <b>#case</b> statements.
                </note>
                </description>
            </item>
            <item>
                <term><b>#endswitch</b></term>
                <description>
                This command terminates a <b>#switch</b> statement.
                </description>
            </item>
            </list>
            <para>
            Normal variables can be defined within the source text itself using the 
            <b>#define</b> command described above and variables may also be added 
            in code using <see cref="M:Neon.IO.PreprocessReader.Set(System.String,System.String)"/>.  These variables can be 
            referenced as <b>$&lt;name&gt;</b>.  Environment variables are also supported. 
            These are referenced as <b>$&lt;$lt;name&gt;&gt;</b>.
            </para>
            <note>
            You may encounter situations where the default was of referencing variables
            conflicts with the syntax of the underlying source text being processed.
            In these cases, you can set <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> to 
            <see cref="P:Neon.IO.PreprocessReader.CurlyVariableExpansionRegex"/> or <see cref="P:Neon.IO.PreprocessReader.ParenVariableExpansionRegex"/>
            to change the format.
            </note>
            <para>
            Variables are always expanded in <b>#if</b> and <b>switch</b> statements and
            are expanded by default in the other source lines.  Variables are expanded
            using the <b>${NAME}</b> syntax by default.  The syntax can be modified
            by setting <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/>.  Variable expansion can be disabled
            by setting <see cref="P:Neon.IO.PreprocessReader.ExpandVariables"/>=<c>false</c>.
            </para>
            <note>
            By default, the reader will throw a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if an
            undefined normal variable is encountered.  This behavior can be modified by setting
            <see cref="P:Neon.IO.PreprocessReader.DefaultVariable"/> to a non-<c>null</c> string.  In this case,
            undefined variable references will always be replaced by the value set.
            <see cref="P:Neon.IO.PreprocessReader.DefaultVariable"/> defaults to <c>null</c>.
            </note>
            <note>
            By default, the reader will throw a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> if an
            undefined environment variable is encountered.  This behavior can be modified by setting
            <see cref="P:Neon.IO.PreprocessReader.DefaultEnvironmentVariable"/> to a non-<c>null</c> string.  In this case,
            undefined environment variable references will always be replaced by the value set.
            <see cref="P:Neon.IO.PreprocessReader.DefaultEnvironmentVariable"/> defaults to <c>null</c>.
            </note>
            <para>
            Processing can also be customized via the <see cref="P:Neon.IO.PreprocessReader.StripComments"/>, <see cref="P:Neon.IO.PreprocessReader.RemoveComments"/>,
            <see cref="P:Neon.IO.PreprocessReader.RemoveBlank"/>,  <see cref="P:Neon.IO.PreprocessReader.ProcessStatements"/>, <see cref="P:Neon.IO.PreprocessReader.Indent"/>, <see cref="P:Neon.IO.PreprocessReader.TabStop"/>, 
            and <see cref="P:Neon.IO.PreprocessReader.StatementMarker"/>
            properties.
            </para>
            </remarks>
            <threadsafety instance="false"/>
        </member>
        <member name="T:Neon.IO.PreprocessReader.ConditionalType">
            <summary>
            Used to identify the current conditional statement.
            </summary>
        </member>
        <member name="T:Neon.IO.PreprocessReader.State">
            <summary>
            Holds the current processing state.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.AngleVariableExpansionRegex">
            <summary>
            A variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/> that matches normal variables like <b>$&lt;test&gt;</b> and environment
            variables like <b>&lt;&lt;test&gt;&gt;&gt;</b>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.CurlyVariableExpansionRegex">
            <summary>
            A variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/> that matches normal variables like <b>${test}</b> and environment 
            variables like <b>${{test}}</b>. You can set the <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> property to this value 
            to change the <see cref="T:Neon.IO.PreprocessReader"/> behavior.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.DefaultVariableExpansionRegex">
            <summary>
            The default variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/>.  This defaults to <see cref="P:Neon.IO.PreprocessReader.AngleVariableExpansionRegex"/> 
            that matches normal variables like <b>$&lt;test&gt;</b> and environment variables like <b>$$lt;&lt;test&gt;&gt;</b>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.ParenVariableExpansionRegex">
            <summary>A alternate variable expansion <see cref="T:System.Text.RegularExpressions.Regex"/> that matches normal variables like <b>$(test)</b>
            and environment variables like <b>$((test))</b>.. You can set the <see cref="P:Neon.IO.PreprocessReader.VariableExpansionRegex"/> 
            property to this value to change the <see cref="T:Neon.IO.PreprocessReader"/> behavior.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.VariableValidationRegex">
            <summary>
            <b>INTERNAL USE ONLY:</b> The <see cref="T:System.Text.RegularExpressions.Regex"/> used to validate variable names.
            </summary>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.IO.TextReader)">
            <summary>
            Constructs an over another <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="reader">The source <see cref="T:System.IO.TextReader"/>.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.IO.TextReader,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance over another <see cref="T:System.IO.TextReader"/>, initializing some variables.
            </summary>
            <param name="reader">The source <see cref="T:System.IO.TextReader"/>.</param>
            <param name="variables">The variables.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.String)">
            <summary>
            Constructs an instance from a string.
            </summary>
            <param name="input">The input string.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance from a string, initializing some variables.
            </summary>
            <param name="input">The input string.</param>
            <param name="variables">The variables.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.Byte[])">
            <summary>
            Constructs an instance from UTF-8 encoded bytes.
            </summary>
            <param name="bytes">The input data.</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.#ctor(System.Byte[],System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Constructs an instance from  UTF-8 encoded bytes, initializing some variables.
            </summary>
            <param name="bytes">The input data.</param>
            <param name="variables">The variables.</param>
        </member>
        <member name="P:Neon.IO.PreprocessReader.StatementMarker">
            <summary>
            The leading character used to identify a preprocessing statement.
            This defaults to the pound sign (<b>#</b>).
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.VariableExpansionRegex">
            <summary>
            The <see cref="T:System.Text.RegularExpressions.Regex"/> used to match variable expansions.  This defaults
            to matching variables of the form: <b>${NAME}</b>.
            </summary>
            <remarks>
            <note>
            You may use set encounter situations where the default syntax would
            conflict with the source text being processed.  You map use the
            <see cref="P:Neon.IO.PreprocessReader.CurlyVariableExpansionRegex"/> or <see cref="P:Neon.IO.PreprocessReader.ParenVariableExpansionRegex"/>
            patterns as an alternative.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.IO.PreprocessReader.ExpandVariables">
            <summary>
            Controls whether variables in the source are expanded.  This defaults
            to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.DefaultVariable">
            <summary>
            The default value to use for an undefined normal variable or <c>null</c>
            if a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> is to be thrown when a
            undefined non-environment variable is referenced.  This defaults to 
            <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.DefaultEnvironmentVariable">
            <summary>
            The default value to use for an undefined environment variable or <c>null</c>
            if a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> is to be thrown when a
            undefined environment variable is referenced.  This defaults to 
            <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.StripComments">
            <summary>
            Controls whether comments are stripped out while reading.  This defaults
            to <c>true</c>.
            </summary>
            <remarks>
            <note>
            <see cref="P:Neon.IO.PreprocessReader.StripComments"/> returns a blank line for comments and
            <see cref="P:Neon.IO.PreprocessReader.RemoveComments"/> doesn't return a comment line at all.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.IO.PreprocessReader.RemoveComments">
            <summary>
            Controls whether comments are removed while reading.  This defaults
            to <c>false</c>.
            </summary>
            <remarks>
            <note>
            <see cref="P:Neon.IO.PreprocessReader.StripComments"/> returns a blank line for comments and
            <see cref="P:Neon.IO.PreprocessReader.RemoveComments"/> doesn't return a comment line at all.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.IO.PreprocessReader.RemoveBlank">
            <summary>
            Controls whether blank lines or lines with only whitespace are to
            be removed while reading.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.ProcessStatements">
            <summary>
            Controls whether preprocessor statements are processed.  This defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.TabStop">
            <summary>
            Controls whether embedded TAB <b>(\t)</b> characters will be converted into
            spaces to format tab stops correctly.  This defaults to <b>zero</b> which
            will not process any tabs.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.Indent">
            <summary>
            The number of spaces to indent the output.  This defaults to <b>0</b>.
            </summary>
        </member>
        <member name="P:Neon.IO.PreprocessReader.LineEnding">
            <summary>
            Determines the line ending <see cref="M:Neon.IO.PreprocessReader.ReadToEnd"/> and <see cref="M:Neon.IO.PreprocessReader.ReadToEndAsync"/>
            will append to the lines they read.  This defaults to <see cref="F:Neon.IO.LineEnding.Platform"/>
            but may be changed to <see cref="F:Neon.IO.LineEnding.CRLF"/> or <see cref="F:Neon.IO.LineEnding.LF"/>.
            </summary>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Set(System.String,System.String)">
            <summary>
            Sets a variable to a string value.
            </summary>
            <param name="name">The case sensitive variable name.</param>
            <param name="value">The option value (defaults to the empty string).</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Set(System.String,System.Object)">
            <summary>
            Sets a variable to an object value.
            </summary>
            <param name="name">The case sensitive variable name.</param>
            <param name="value">The option value (defaults to the null).</param>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Set(System.String,System.Boolean)">
            <summary>
            Sets a variable to an boolean value.
            </summary>
            <param name="name">The case sensitive variable name.</param>
            <param name="value">The option value.</param>
            <remarks>
            <note>
            The value set will be lower case <b>true</b> or <b>false</b>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadLine">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadLineAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadToEnd">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadToEndAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.IsComment(System.String)">
            <summary>
            Determines whether the line passed is a comment.
            </summary>
            <param name="line"></param>
            <returns><b>true</b> if the line is a comment.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Expand(System.String)">
            <summary>
            Expands any variables and TABs in the string passed.
            </summary>
            <param name="input">The input text.</param>
            <returns>The expanded result.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.IndentLine(System.String)">
            <summary>
            Adds indentation to the input.
            </summary>
            <param name="input">The inpur string.</param>
            <returns>The indented input.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.IsStatement(System.String)">
            <summary>
            Determines whether the line passed is a statement.
            </summary>
            <param name="line"></param>
            <returns><b>true</b> if the line is a statement.</returns>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ProcessStatement(System.String)">
            <summary>
            Processes a statement line.
            </summary>
            <param name="line">The statement.</param>
            <exception cref="T:System.FormatException">Thrown for malformed statements.</exception>
        </member>
        <member name="M:Neon.IO.PreprocessReader.VerifyStatementClosure">
            <summary>
            Verifies that all statements have been closed properly.
            </summary>
            <exception cref="T:System.FormatException">Thrown if an [#if] or {#switch] statement has not been closed.</exception>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Peek">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Read">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.Read(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.PreprocessReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.RelayStream">
            <summary>
            Implements a stream that passes operations to another stream.  This 
            is mainly useful for controlling whether <see cref="M:System.IO.Stream.Dispose"/>
            and <see cref="M:Neon.IO.RelayStream.Dispose(System.Boolean)"/> actually disposes the underlying
            stream or not when the stream is referenced by another class that 
            always disposes the stream.
            </summary>
        </member>
        <member name="M:Neon.IO.RelayStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="stream">The underlying stream being associated.</param>
            <param name="leaveOpen">Optionally leave the underlying stream open when this instance is disposed.</param>
        </member>
        <member name="M:Neon.IO.RelayStream.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.RelayStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.IO.RelayStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.IO.TempFile">
            <summary>
            Generates a globally unique temporary file name and then 
            ensures that the file is removed when the instance is 
            disposed.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFile.Root">
            <summary>
            Optionally specifies the root directory where the temporary files will
            be created.  This defaults to <see cref="M:System.IO.Path.GetTempPath"/>
            when this is <c>null</c> or empty and can be overridden for specific
            instances by passing a folder path the the constructor.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFile.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="suffix">
            Optionally specifies the file suffix (including the leading period) to be
            appended to the generated file name.  This defaults to <b>.tmp</b>.
            </param>
            <param name="folder">
            Optionally specifies the target folder.  This defaults to the standard
            temporary directory for the current user.
            </param>
        </member>
        <member name="M:Neon.IO.TempFile.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.IO.TempFile.Path">
            <summary>
            Returns the fully qualified path to the temporary file.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFile.Name">
            <summary>
            Returns the file name only.
            </summary>
        </member>
        <member name="T:Neon.IO.TempFolder">
            <summary>
            Manages a temporary file system folder to be used for the duration of a unit test.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFolder.Root">
            <summary>
            Optionally specifies the root directory where the temporary folders will
            be created.  This defaults to <see cref="M:System.IO.Path.GetTempPath"/>
            when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFolder.#ctor">
            <summary>
            Creates a temporary folder.
            </summary>
        </member>
        <member name="P:Neon.IO.TempFolder.Path">
            <summary>
            Returns the fully qualifed path to the temporary folder.
            </summary>
        </member>
        <member name="M:Neon.IO.TempFolder.Dispose">
            <summary>
            Deletes the temporary folder and all of its contents.
            </summary>
        </member>
        <member name="T:Neon.Net.HttpException">
            <summary>
            Describes an HTTP error.
            </summary>
        </member>
        <member name="M:Neon.Net.HttpException.GetMessage(System.String,System.Exception)">
            <summary>
            Constructs an exception message using an inner exception.
            </summary>
            <param name="message">The base message.</param>
            <param name="innerException">The inner exception or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Net.HttpException.#ctor(System.String,System.Exception,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Exception message.</param>
            <param name="innerException">Optional inner exception.</param>
            <param name="requestUri">The optional request URL.</param>
        </member>
        <member name="M:Neon.Net.HttpException.#ctor(System.Exception,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="innerException">The inner exception.</param>
            <param name="requestUri">The optional request URL.</param>
        </member>
        <member name="M:Neon.Net.HttpException.#ctor(System.Net.HttpStatusCode,System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="statusCode">The HTTP response status code.</param>
            <param name="reasonPhrase">The HTTP response peason phrase (or <c>null</c>).</param>
            <param name="requestUri">The optional request URL.</param>
        </member>
        <member name="P:Neon.Net.HttpException.StatusCode">
            <summary>
            Returns the HTTP response status code.
            </summary>
        </member>
        <member name="P:Neon.Net.HttpException.RequestUri">
            <summary>
            Returns the request URI.
            </summary>
        </member>
        <member name="P:Neon.Net.HttpException.ReasonPhrase">
            <summary>
            Returns the HTTP response status message.
            </summary>
        </member>
        <member name="T:Neon.Net.JsonClient">
            <summary>
            Implements a light-weight JSON oriented HTTP client.
            </summary>
            <remarks>
            <para>
            Use <see cref="M:Neon.Net.JsonClient.GetAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, 
            <see cref="M:Neon.Net.JsonClient.PutAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, 
            <see cref="M:Neon.Net.JsonClient.PostAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, 
            <see cref="M:Neon.Net.JsonClient.DeleteAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>,
            <see cref="M:Neon.Net.JsonClient.OptionsAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>,
            <see cref="M:Neon.Net.JsonClient.HeadAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, or
            <see cref="M:Neon.Net.JsonClient.PatchAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>
            to perform HTTP operations that ensure that a non-error HTTP status code is returned by the servers.
            </para>
            <para>
            Use <see cref="M:Neon.Net.JsonClient.GetUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, 
            <see cref="M:Neon.Net.JsonClient.PutUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, 
            <see cref="M:Neon.Net.JsonClient.PostUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, 
            <see cref="M:Neon.Net.JsonClient.DeleteUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>,
            <see cref="M:Neon.Net.JsonClient.OptionsUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>,
            <see cref="M:Neon.Net.JsonClient.HeadUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>, or
            <see cref="M:Neon.Net.JsonClient.PatchUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)"/>
            to perform an HTTP without ensuring a non-error HTTP status code.
            </para>
            <para>
            This class can also handle retrying operations when transient errors are detected.  Customize 
            <see cref="P:Neon.Net.JsonClient.SafeRetryPolicy"/> and/or <see cref="P:Neon.Net.JsonClient.UnsafeRetryPolicy"/> by setting a <see cref="T:Neon.Retry.IRetryPolicy"/> 
            implementation such as <see cref="T:Neon.Retry.LinearRetryPolicy"/> or <see cref="T:Neon.Retry.ExponentialRetryPolicy"/>.
            </para>
            <note>
            This class initializes <see cref="P:Neon.Net.JsonClient.SafeRetryPolicy"/> to a reasonable <see cref="T:Neon.Retry.ExponentialRetryPolicy"/> by default
            and <see cref="P:Neon.Net.JsonClient.UnsafeRetryPolicy"/> to <see cref="T:Neon.Retry.NoRetryPolicy"/>.  You can override the default
            retry policy for specific requests using the methods that take an <see cref="T:Neon.Retry.IRetryPolicy"/> as 
            their first parameter.
            </note>
            <note>
            <para>
            The <see cref="T:Neon.Net.JsonClientPayload"/> class can be used to customize both the <b>Content-Type</b> header
            and the actual payload uploaded with <b>POST</b> and <b>PUT</b> requests.  This can be used for those
            <i>special</i> REST APIs that don't accept JSON payloads.
            </para>
            <para>
            All you need to do is construct a <see cref="T:Neon.Net.JsonClientPayload"/> instance, specifying the value to
            be used as the <b>Content-Type</b> header and the payload data as text or a byte array and then pass
            this as the <b>document</b> parameter to the methods that upload content.  The methods will recognize
            this special type and just send the specified data rather than attempting to serailize the document
            to JSON.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.JsonClient.#ctor(System.Net.Http.HttpMessageHandler,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="handler">The optional message handler.</param>
            <param name="disposeHandler">Indicates whether the handler passed will be disposed automatically (defaults to <c>false</c>).</param>
        </member>
        <member name="M:Neon.Net.JsonClient.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClient.Dispose">
            <summary>
            Releases all resources associated with the instance.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClient.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="P:Neon.Net.JsonClient.BaseAddress">
            <summary>
            The default base <see cref="T:System.Uri"/> the client will use when relative
            URIs are specified for requests.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.Timeout">
            <summary>
            The default base <see cref="T:System.Uri"/> the client will use when relative
            URIs are specified for requests.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.DefaultRequestHeaders">
            <summary>
            Returns the base client's default request headers property to make it easy
            to customize request headers.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.DocumentType">
            <summary>
            Specifies the MIME type to use posting or putting documents to the endpoint.
            This defaults to the standard <b>application/json</b> but some services
            may require custom values.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.HttpClient">
            <summary>
            Returns the underlying <see cref="T:System.Net.Http.HttpClient"/>.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.SafeRetryPolicy">
            <summary>
            <para>
            The <see cref="T:Neon.Retry.IRetryPolicy"/> to be used to detect and retry transient network and HTTP
            errors for the <b>safe</b> methods.  This defaults to <see cref="T:Neon.Retry.ExponentialRetryPolicy"/> with 
            the transient detector function set to <see cref="M:Neon.Retry.TransientDetector.NetworkOrHttp(System.Exception)"/>.
            </para>
            <note>
            You may set this to <c>null</c> to disable safe transient error retry.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClient.UnsafeRetryPolicy">
            <summary>
            <para>
            The <see cref="T:Neon.Retry.IRetryPolicy"/> to be used to detect and retry transient network errors for the
            <b>unsafe</b> methods.  This defaults to <see cref="T:Neon.Retry.NoRetryPolicy"/>.
            </para>
            <note>
            You may set this to <c>null</c> to disable unsafe transient error retry.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClient.AbsoluteUri(System.String)">
            <summary>
            Converts a relative URI into an absolute URI if necessary.
            </summary>
            <param name="uri">The URI.</param>
            <returns>The absolute URI.</returns>
        </member>
        <member name="M:Neon.Net.JsonClient.FormatUri(System.String,Neon.Collections.ArgDictionary)">
            <summary>
            Formats the URI by appending query arguments as required.
            </summary>
            <param name="uri">The base URI.</param>
            <param name="args">The query arguments.</param>
            <returns>The formatted URI.</returns>
        </member>
        <member name="M:Neon.Net.JsonClient.CreateContent(System.Object)">
            <summary>
            <para>
            Converts the object passed into JSON content suitable for transmitting in
            an HTTP request.
            </para>
            <note>
            This method handles <see cref="T:Neon.Net.JsonClientPayload"/> documents specially 
            as described in the <see cref="T:Neon.Net.JsonClient"/> remarks.
            </note>
            </summary>
            <param name="document">The document object or JSON text.</param>
            <returns>Tne <see cref="T:System.Net.Http.HttpContent"/>.</returns>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>DELETE</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteAsync``1(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>DELETE</b> returning a specific type and ensuring that a success cxode was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>DELETE</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring 
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>DELETE</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.DeleteUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>DELETE</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring 
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>GET</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetAsync``1(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>GET</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>GET</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/>" and ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetUnsafeAsync(System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>GET</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.GetUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>GET</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and 
            without ensuring that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>HEAD</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>HEAD</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The URI</param>
            <param name="document">Optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>HEAD</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>HEAD</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.HeadUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>HEAD</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The URI</param>
            <param name="document">Optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.OptionsUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>OPTIONS</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PATCH</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PATCH</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The URI</param>
            <param name="document">Optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PATCH</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PATCH</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PatchUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PATCH</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>POST</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>POST</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The URI</param>
            <param name="document">Optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>POST</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and ensuring that
            a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>POST</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PostUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>POST</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/> and without ensuring
            that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PUT</b> ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutAsync``1(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PUT</b> returning a specific type and ensuring that a success code was returned.
            </summary>
            <typeparam name="TResult">The desired result type.</typeparam>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PUT</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/>" and ensuring that a 
            success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
            <exception cref="T:Neon.Net.HttpException">Thrown when the server responds with an HTTP error status code.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutUnsafeAsync(System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PUT</b> without ensuring that a success code was returned.
            </summary>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="M:Neon.Net.JsonClient.PutUnsafeAsync(Neon.Retry.IRetryPolicy,System.String,System.Object,Neon.Collections.ArgDictionary,Neon.Collections.ArgDictionary,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Performs an HTTP <b>PUT</b> using a specific <see cref="T:Neon.Retry.IRetryPolicy"/>" and without 
            ensuring that a success code was returned.
            </summary>
            <param name="retryPolicy">The retry policy or <c>null</c> to disable retries.</param>
            <param name="uri">The URI</param>
            <param name="document">The optional object to be uploaded as the request payload.</param>
            <param name="args">The optional query arguments.</param>
            <param name="headers">The Optional HTTP headers.</param>
            <param name="cancellationToken">The optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <param name="logActivity">The optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The <see cref="T:Neon.Net.JsonResponse"/>.</returns>
            <exception cref="T:System.Net.Sockets.SocketException">Thrown for network connectivity issues.</exception>
        </member>
        <member name="T:Neon.Net.JsonClientPayload">
            <summary>
            Passed as the <b>document</b> to be uploaded with a <see cref="T:Neon.Net.JsonClient"/> <b>POST</b>
            or <b>PUT</b> request to customize the payload data and content-type.  This can be used
            in special situations where a REST API needs to push <b>application/x-www-form-urlencoded</b>
            data or other formats.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonClientPayload.#ctor(System.String,System.String)">
            <summary>
            <para>
            Constructs an instance from the <b>Content-Type</b> header and text to be 
            included with the POST/PUT.
            </para>
            <note>
            The uploaded text will be <b>UTF-8</b> encoded.
            </note>
            </summary>
            <param name="contentType">The value to be passed as the request's <b>Content-Type</b> header.</param>
            <param name="text">The text payload.</param>
        </member>
        <member name="M:Neon.Net.JsonClientPayload.#ctor(System.String,System.Byte[])">
            <summary>
            Constructs an instance from the <b>Content-Type</b> header and byte data to be 
            included with the POST/PUT.
            </summary>
            <param name="contentType">The value to be passed as the request's <b>Content-Type</b> header.</param>
            <param name="bytes">The bytes to be uploaded.</param>
        </member>
        <member name="P:Neon.Net.JsonClientPayload.ContentType">
            <summary>
            Returns the HTTP <b>Content-Type</b> header to be included in the POST/PUT request.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonClientPayload.ContentBytes">
            <summary>
            Returns the payload bytes to be included in the POST/PUT request.
            </summary>
        </member>
        <member name="T:Neon.Net.JsonResponse">
            <summary>
            Encapsulates the response returned from a <see cref="T:Neon.Net.JsonClient"/> 
            server call.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonResponse.#ctor(System.String,System.Net.Http.HttpResponseMessage,System.String)">
            <summary>
            Constructs a <see cref="T:Neon.Net.JsonResponse"/> from a lower level <see cref="T:System.Net.Http.HttpResponseMessage"/>.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="httpRespose">The low-level response.</param>
            <param name="responseText">The response text.</param>
        </member>
        <member name="P:Neon.Net.JsonResponse.RequestUri">
            <summary>
            Returns the request URI.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonResponse.HttpResponse">
            <summary>
            Returns the low-level HTTP response.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonResponse.JsonText">
            <summary>
            Returns the response as JSON text or <c>null</c> if the server didn't
            respond with JSON.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonResponse.AsDynamic">
            <summary>
            Returns the dynamic JSON response document, array, value or <c>null</c> if the server didn't return
            JSON content.
            </summary>
            <returns>The dynamic document or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Net.JsonResponse.As``1">
            <summary>
            Converts the response document to a specified type or <c>null</c> if the server didn't 
            return JSON content.
            </summary>
            <typeparam name="TResult">The specified type.</typeparam>
            <returns>The converted document or its default value.</returns>
        </member>
        <member name="P:Neon.Net.JsonResponse.StatusCode">
            <summary>
            Returns the HTTP response status code.
            </summary>
        </member>
        <member name="P:Neon.Net.JsonResponse.IsSuccess">
            <summary>
            Returns <c>true</c> if the response status code indicates success.
            </summary>
        </member>
        <member name="M:Neon.Net.JsonResponse.EnsureSuccess">
            <summary>
            Ensures that the status code indicates success by throwing an 
            exception for any error related status codes.
            </summary>
            <exception cref="T:Neon.Net.HttpException">Thrown if the response doesn't indicate success.</exception>
        </member>
        <member name="T:Neon.Net.NetConst">
            <summary>
            Network related constants.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.DefaultMTU">
            <summary>
            <para>
            The default message transmission unit that is commonly configured
            across the internet.  This is the size in bytes of the largest
            packet including all of the protocol headers from OSI layers 3
            and above.  This does not include the data link (e.g. Ethernet)
            overhead.
            </para>
            <para>
            Packets larger than this may need to be fragmented (if allowed)
            to be transmitted end-to-end across several connected networks.
            </para>
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.VXLANHeader">
            <summary>
            The size of VXLAN headers in bytes.  <a href="VXLAN">https://en.wikipedia.org/wiki/Virtual_Extensible_LAN</a>
            is a protocol used in cloud and other virtualization environments
            to scale and separate network traffic between multiple tenants.
            Network traffic is empasulated in UDP packets with a header added
            to that identifies the virtual network.  This constant specifies
            the header overhead in bytes.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.IPHeader">
            <summary>
            The size in bytes of an IP packet header.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.TCPHeader">
            <summary>
            The size in bytes of all headers (IP and TCP) added to a TCP packet.
            </summary>
        </member>
        <member name="F:Neon.Net.NetConst.ICMPHeader">
            <summary>
            The size in bytes of an ICMP packet header.
            </summary>
        </member>
        <member name="T:Neon.Net.NetHelper">
            <summary>
            Useful network related utilities.
            </summary>
        </member>
        <member name="P:Neon.Net.NetHelper.DnsHostRegex">
            <summary>
            Regex for verifying DNS hostnames.
            </summary>
        </member>
        <member name="M:Neon.Net.NetHelper.IsValidHost(System.String)">
            <summary>
            Verifies that a string is a valid DNS hostname.
            </summary>
            <param name="host">The string being tested.</param>
            <returns><c>true</c> if the hostname is valid.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.AddressEquals(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Determines whether two IP addresses are equal.
            </summary>
            <param name="address1">Address 1.</param>
            <param name="address2">Address 2.</param>
            <returns><c>true</c> if the addresses are equal.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.AddressIncrement(System.Net.IPAddress,System.Int32)">
            <summary>
            Increments an IPv4 address by adding an integer value.
            </summary>
            <param name="address">The input IPv4 address.</param>
            <param name="incrementBy">The increment value (defaults to <b>+1</b>).</param>
            <returns>The next address or <b>0.0.0.0</b> when we wrap-around the address space.</returns>
            <exception cref="T:System.NotSupportedException">Thrown for non-IPv4 addresses.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.AddressToUint(System.Net.IPAddress)">
            <summary>
            Converts an IPv4 address into a32-bit unsigned integer equivalent.
            </summary>
            <param name="address">The input IPv4 address.</param>
            <returns>The 32-bit unsigned integer equivalent.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.UintToAddress(System.UInt32)">
            <summary>
            Converts an unsigned 32-bit integer into an IPv4 address.
            </summary>
            <param name="value">The input value.</param>
            <returns>The <see cref="T:System.Net.IPAddress"/>.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.IsValidPort(System.Int32)">
            <summary>
            Determines whether an integer is a valid network port number.
            </summary>
            <param name="port">The port.</param>
            <returns><c>true</c> if the port is valid.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.GetRandomAddress">
            <summary>
            Returns a usable random IP address for use for DNS reolutions.
            </summary>
            <returns>The generated <see cref="T:System.Net.IPAddress"/>.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.ModifyLocalHosts(System.Collections.Generic.Dictionary{System.String,System.Net.IPAddress},System.String)">
            <summary>
            <para>
            Used to temporarily modify the <b>hosts</b> file used by the DNS resolver
            for debugging or other purposes.
            </para>
            <note>
            <b>WARNING:</b> Modifying the <b>hosts</b> file will impact all processes
            on the system, not just the current one and this is designed to be used by
            a single process at a time.
            </note>
            </summary>
            <param name="hostEntries">A dictionary mapping the hostnames to an IP address or <c>null</c>.</param>
            <param name="section">
            <para>
            Optionally specifies the string to use to mark the hostnames section.  This
            defaults to <b>MODIFY</b> which will delimit the section with <b># NEON-BEGIN-MODIFY</b>
            and <b># NEON-END-MODIFY</b>.  You may pass a different string to identify a custom section.
            </para>
            <note>
            The string passed must be a valid DNS hostname label that must begin with a letter
            followed by letters, digits or dashes.  The maximum length is 63 characters.
            </note>
            </param>
            <remarks>
            <note>
            This method requires elevated administrative privileges.
            </note>
            <para>
            This method adds or removes a temporary section of host entry definitions
            delimited by special comment lines.  When <paramref name="hostEntries"/> is 
            non-null and non-empty, the section will be added or updated.  Otherwise, the
            section will be removed.
            </para>
            <para>
            You can remove all host sections by passing both <paramref name="hostEntries"/> 
            and <paramref name="section"/> as <c>null</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetHelper.ListLocalHostsSections">
            <summary>
            Lists the names of the local host sections.
            </summary>
            <returns>The section names converted to uppercase.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.RewriteOn20thRetry(System.String,System.Collections.Generic.List{System.String},System.Int32@)">
            <summary>
            Rewrites the hosts file on the 20th retry.
            </summary>
            <param name="hostsPath">Path to the hosts file.</param>
            <param name="lines">The host file lines.</param>
            <param name="retryCount">The retry count.</param>
        </member>
        <member name="M:Neon.Net.NetHelper.GetHostAddressesAsync(System.String)">
            <summary>
            Performs a DNS lookup.
            </summary>
            <param name="hostname">The target hostname.</param>
            <returns>The array of IP addresses resolved or an empty array if the hostname lookup failed.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.GetReachableHost(System.Collections.Generic.IEnumerable{System.String},Neon.Net.ReachableHostMode)">
            <summary>
            Pings one or more hostnames or IP addresses in parallel to identify one that
            appears to be online and reachable via the network (because it answers a ping).
            </summary>
            <param name="hosts">The hostname or IP addresses to be tested.</param>
            <param name="failureMode">
            Specifies what should happen when there are no reachable hosts.  
            This defaults to <see cref="F:Neon.Net.ReachableHostMode.ReturnFirst"/>.
            </param>
            <returns>A <see cref="T:Neon.Net.ReachableHost"/> instance describing the host or <c>null</c>.</returns>
            <exception cref="T:Neon.Net.NetworkException">
            Thrown if no hosts are reachable and <paramref name="failureMode"/> is 
            passed as <see cref="F:Neon.Net.ReachableHostMode.Throw"/>.
            </exception>
        </member>
        <member name="M:Neon.Net.NetHelper.GetReachableHosts(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Pings one or more hostnames or IP addresses in parallel to identify those that
            appear to be online and reachable via the network (because it answers a ping).
            </summary>
            <param name="hosts">The hostname or IP addresses to be tested.</param>
            <returns>The <see cref="T:Neon.Net.ReachableHost"/> instances describing the reachable hosts (if any).</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.ComputeMSS(System.Int32,System.Boolean)">
            <summary>
            Computes the TCP maximum segment size for a given MTU, optionally taking a
            VXLAN wrapper headers into account.
            </summary>
            <param name="mtu">Specifies the target MTU (defaults to 1500).</param>
            <param name="vxLan">Optionally indicates that traffic is routed via a VXLAN.</param>
            <returns>The maximum segment size in bytes.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.TryParseIPv4Endpoint(System.String,System.Net.IPEndPoint@)">
            <summary>
            Attempts to parse an IPv4 network endpoint.
            </summary>
            <param name="input">The input string.</param>
            <param name="endpoint">Returns as the parsed endpoint.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Net.NetHelper.ParseIPv4Endpoint(System.String)">
            <summary>
            Parses an IPv4 endpoint from a string.
            </summary>
            <param name="input">The input.</param>
            <returns>The parsed <see cref="T:System.Net.IPEndPoint"/>.</returns>
            <exception cref="T:System.FormatException">Thrown if the input is not valid.</exception>
        </member>
        <member name="M:Neon.Net.NetHelper.GetUnusedTcpPort(System.Net.IPAddress)">
            <summary>
            Returns a free TCP port for a local IP address.
            </summary>
            <param name="address">The IP address.</param>
            <returns>The free port number.</returns>
            <exception cref="T:Neon.Net.NetworkException">Thrown when there are no available ports.</exception>
        </member>
        <member name="T:Neon.Net.NetworkCidr">
            <summary>
            Describes a IP network subnet using Classless Inter-Domain Routing (CIDR) notation.
            </summary>
            <remarks>
            <para>
            This is generally used for describing an IP subnet.  See the following Wikipedia
            article for more information.
            </para>
            <para>
            https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation
            </para>
            <note>
            This class currently supports only IPv4 addresses.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Net.NetworkCidr.op_Equality(Neon.Net.NetworkCidr,Neon.Net.NetworkCidr)">
            <summary>
            Compares two <see cref="T:Neon.Net.NetworkCidr"/> instances for equality.
            </summary>
            <param name="v1">Value 1.</param>
            <param name="v2">Value 2</param>
            <returns><c>true</c> if the values are equal.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.op_Inequality(Neon.Net.NetworkCidr,Neon.Net.NetworkCidr)">
            <summary>
            Compares two <see cref="T:Neon.Net.NetworkCidr"/> instances for inequality.
            </summary>
            <param name="v1">Value 1.</param>
            <param name="v2">Value 2</param>
            <returns><c>true</c> if the values are not equal.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.op_Implicit(Neon.Net.NetworkCidr)~System.String">
            <summary>
            Implicitly casts a <see cref="T:Neon.Net.NetworkCidr"/> into a string.
            </summary>
            <param name="v">The value (or <c>null)</c>.</param>
        </member>
        <member name="P:Neon.Net.NetworkCidr.All">
            <summary>
            Returns the <b>0.0.0.0/0</b> subnet which includes all public and private
            IP addresses.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Parse(System.String)">
            <summary>
            Parses a subnet from CIDR notation in the form of <i>ip-address</i>/<i>prefix</i>,
            where <i>prefix</i> is the network prefix length in bits.
            </summary>
            <param name="input">The input string.</param>
            <returns>The parsed <see cref="T:Neon.Net.NetworkCidr"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the input is not correctly formatted.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.TryParse(System.String,Neon.Net.NetworkCidr@)">
            <summary>
            Attempts to parse a subnet from CIDR notation in the form of <i>ip-address</i>/<i>prefix</i>,
            where <i>prefix</i> is the network prefix length in bits.
            </summary>
            <param name="input">The input string.</param>
            <param name="cidr">The parsed <see cref="T:Neon.Net.NetworkCidr"/>.</param>
            <returns><c>true</c> if the operation was successful.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Normalize(System.String)">
            <summary>
            Attempts to normalize a network CIDR string by ensuring that the
            address actually fits the mask.
            </summary>
            <param name="input">The input string.</param>
            <returns>The normalizes CIDR converted back to a string.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the input is not a valid CIDR.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkCidr.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Creates a subnet from an IP address and prefix length.
            </summary>
            <param name="address">The IP address.</param>
            <param name="prefixLength">The network prefix mask length in bits.</param>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Initialize(System.Net.IPAddress,System.Int32)">
            <summary>
            Initializes the instance.
            </summary>
            <param name="address">The IP address.</param>
            <param name="prefixLength">The network prefix mask length in bits.</param>
        </member>
        <member name="P:Neon.Net.NetworkCidr.Address">
            <summary>
            Returns the CIDR address.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.Mask">
            <summary>
            Returns the subnet mask.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.PrefixLength">
            <summary>
            Returns the prefix length in bits.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.AddressCount">
            <summary>
            Returns the number of IP addresses within the subnet.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.FirstAddress">
            <summary>
            Returns the first IP address in the subnet.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.FirstUsableAddress">
            <summary>
            Returns the first usable IP address in the subnet.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.LastAddress">
            <summary>
            Returns the last IP address in the subnet.
            </summary>
        </member>
        <member name="P:Neon.Net.NetworkCidr.NextAddress">
            <summary>
            Returns the first address after the subnet.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Contains(System.Net.IPAddress)">
            <summary>
            Determines whether an IP address is within the subnet.
            </summary>
            <param name="address">The IP address.</param>
            <returns><c>true</c> if the address is within the subnet.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if for IPv6 addresses.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Contains(Neon.Net.NetworkCidr)">
            <summary>
            Determines whether a subnet is completely contained within the current subnet.
            </summary>
            <param name="subnet">The subnet being tested.</param>
            <returns><c>true</c> if <paramref name="subnet"/> is fully contained.</returns>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Overlaps(Neon.Net.NetworkCidr)">
            <summary>
            Determines whether this subnet overlaps another.
            </summary>
            <param name="subnet">The subnet being tested.</param>
            <returns><c>true</c> if the subnets overlap.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="subnet"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Neon.Net.NetworkCidr.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Net.NetworkCidr.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Net.NetworkCidr.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Net.NetworkException">
            <summary>
            Indicates network related problems.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkException.#ctor(System.String,System.Exception)">
            <summary>
            Constuctor.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The optional inner exception.</param>
        </member>
        <member name="T:Neon.Net.NetworkPorts">
            <summary>
            Defines some common network port numbers as well as the <see cref="M:Neon.Net.NetworkPorts.TryParse(System.String,System.Int32@)" /> method.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.HTTP">
            <summary>
            HyperText Transport Protocol port (<b>80</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.HTTPS">
            <summary>
            Secure HyperText Transport Protocol port (<b>443</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SSL">
            <summary>
            Secure Socket Layer port (<b>443</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.DNS">
            <summary>
            Domain Name System port (<b>53</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SMTP">
            <summary>
            Simple Message Transport Protocol port (<b>25</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.POP3">
            <summary>
            Post Office Protocol version 3 port (<b>110</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TELNET">
            <summary>
            Remote terminal protocol port (<b>23</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.FTP">
            <summary>
            File Transfer Protocol (control) port (<b>21</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.FTPDATA">
            <summary>
            File Transfer Protocol (data) port (<b>20</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SFTP">
            <summary>
            Secure File Transfer Protocol port (<b>22</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.RADIUS">
            <summary>
            RADIUS authentication and billing protocol (port <b>1812</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.AAA">
            <summary>
            Authentication, Authorization, and Accounting port.  This port was
            originally used by the RADIUS protocol and is still used
            fairly widely (<b>1645</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.ECHO">
            <summary>
            PING port (<b>7</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.DAYTIME">
            <summary>
            Daytime (RFC 867) port (<b>13</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TFTP">
            <summary>
            Trivial File Transfer Protocol port (<b>69</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SSH">
            <summary>
            Secure Shell port (<b>22</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TIME">
            <summary>
            TIME protocol port (<b>37</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.NTP">
            <summary>
            Network Time Protocol port (<b>123</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.IMAP">
            <summary>
            Internet Message Access Protocol port (<b>143</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SNMP">
            <summary>
            Simple Network Managenment Protocol (SNMP) port (<b>161</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SNMPTRAP">
            <summary>
            Simple Network Managenment Protocol (trap) port (<b>162</b>)
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.LDAP">
            <summary>
            Lightweight Directory Access Protocol port (<b>389</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.LDAPS">
            <summary>
            Lightweight Directory Access Protocol over TLS/SSL port (<b>636</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SIP">
            <summary>
            Session Initiation Protocol port (<b>5060</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SIPS">
            <summary>
            Secure Session Initiation Protocol (over TLS) port (<b>5061</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SQUID">
            <summary>
            The default port for the <a href="http://en.wikipedia.org/wiki/Squid_%28software%29">Squid</a>
            open source proxy project port (<b>3128</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SOCKS">
            <summary>
            The SOCKS (Socket Secure) proxy port (<b>1080</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Consul">
            <summary>
            The HashiCorp Consul service (RPC) port (<b>8500</b>).  The protocol
            will be HTTP or HTTPS depending on how Consul is configured.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Vault">
            <summary>
            The HashiCorp Vault service port (<b>8200</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Docker">
            <summary>
            The Docker API port (<b>2375</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.DockerSwarm">
            <summary>
            The Docker Swarm node advertise port (<b>2377</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Etcd">
            <summary>
            The Etcd API port (<b>2379</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.EtcdPeer">
            <summary>
            The internal Etcd cluster peer API port (<b>2380</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TDAgentForward">
            <summary>
            The Treasure Data <b>td-agent</b> <b>forward</b> port 
            to accept TCP and UDP traffic (<b>24224</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.TDAgentHttp">
            <summary>
            The Treasure Data <b>td-agent</b> <b>HTTP</b> port (<b>9880</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.ElasticSearchHttp">
            <summary>
            The ElasticSearch client HTTP port (<b>9200</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.ElasticSearchTcp">
            <summary>
            The ElasticSearch client TCP port (<b>9300</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Kibana">
            <summary>
            The Kibana website port (<b>5601</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.SysLog">
            <summary>
            The SysLog UDP port (<b>514</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseWebAdmin">
            <summary>
            The Couchbase Server web administration user interface port (<b>8091</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseApi">
            <summary>
            The Couchbase Server REST API port (<b>8092</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseSyncGatewayAdmin">
            <summary>
            The Couchbase Sync Gateway administration REST API port (<b>4985</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.CouchbaseSyncGatewayPublic">
            <summary>
            The Couchbase Sync Gateway public REST API port (<b>4984</b>).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.OpenVPN">
            <summary>
            The OpenVPN port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.AMQP">
            <summary>
            The Advanced Messaging Queue Protocol (AMQP) port (e.g. RabbitMQ).
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.RabbitMQAdmin">
            <summary>
            RabbitMQ Admin dashboard port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.AppCacherNg">
            <summary>
            <b>apt-cacher-ng</b> Debian/Ubuntu package proxy port.
            </summary>
        </member>
        <member name="F:Neon.Net.NetworkPorts.Cadence">
            <summary>
            Uber Cadence primary cluster port.
            </summary>
        </member>
        <member name="M:Neon.Net.NetworkPorts.TryParse(System.String,System.Int32@)">
            <summary>
            Attempts to parse an integer or well known port name from a string
            and return the integer TCP port number.
            </summary>
            <param name="input">The port number or name as as string.</param>
            <param name="port">Receives the parsed port number.</param>
            <returns><c>true</c> if a port was successfulyy parsed.</returns>
        </member>
        <member name="T:Neon.Net.Pinger">
            <summary>
            Implements a threadsafe subset of the .NET Framework <see cref="T:System.Net.NetworkInformation.Ping"/> class.
            </summary>
            <remarks>
            <para>
            Unfortunately, the .NET Framework <see cref="T:System.Net.NetworkInformation.Ping"/> class is not threadsafe (even
            the async methods).  So, we need to ensure that only one ping request
            is performed on any given instance.
            </para>
            <para>
            My original idea was to simply create and dispose <see cref="T:System.Net.NetworkInformation.Ping"/>] instances on 
            the fly for each request, but I changed my mind after thinking about
            the potential performance overhead as well as the potential for exhausting
            ephemeral socket ports.
            </para>
            <para>
            Instead, I'm going to maintain a queue of <see cref="T:System.Net.NetworkInformation.Ping"/> instances that that can
            be reused for subsequent queries.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Net.Pinger.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.Dispose">
            <summary>
            Releases all resources associated with the instance.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Net.Pinger.Clear">
            <summary>
            Disposes any unused underlying <see cref="T:System.Net.NetworkInformation.Ping"/> instances.
            </summary>
        </member>
        <member name="M:Neon.Net.Pinger.SendPingAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Pings a IP address.
            </summary>
            <param name="address">The target address.</param>
            <param name="timeoutMilliseconds">Optional timeout in milliseconds (defaults to 2000).</param>
            <returns>A <see cref="T:System.Net.NetworkInformation.PingReply"/>.</returns>
        </member>
        <member name="M:Neon.Net.Pinger.SendPingAsync(System.String,System.Int32)">
            <summary>
            Pings a IP address passed as a <c>string</c>.
            </summary>
            <param name="address">The target address.</param>
            <param name="timeoutMilliseconds">Optional timeout in milliseconds (defaults to 2000).</param>
            <returns>A <see cref="T:System.Net.NetworkInformation.PingReply"/>.</returns>
        </member>
        <member name="T:Neon.Net.ReachableHost">
            <summary>
            Holds information about a reachable host returned by <see cref="M:Neon.Net.NetHelper.GetReachableHost(System.Collections.Generic.IEnumerable{System.String},Neon.Net.ReachableHostMode)"/>.
            </summary>
        </member>
        <member name="M:Neon.Net.ReachableHost.#ctor(System.String,System.Net.IPAddress,System.TimeSpan,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="host">The target hostname.</param>
            <param name="address">The target IP address or <c>null</c> if the target is un reachable.</param>
            <param name="time">The ping and answer round trip time.</param>
            <param name="unreachable">Optionally specifies that the host was unrechable.</param>
        </member>
        <member name="M:Neon.Net.ReachableHost.#ctor(System.String,System.Net.NetworkInformation.PingReply,System.Boolean)">
            <summary>
            Internal constructor used to create an instance from a <see cref="T:System.Net.NetworkInformation.PingReply"/>.
            </summary>
            <param name="host">The target hostname.</param>
            <param name="pingReply">The ping reply.</param>
            <param name="unreachable">Optionally specifies that the host was unrechable.</param>
        </member>
        <member name="P:Neon.Net.ReachableHost.Host">
            <summary>
            The target host]name.
            </summary>
        </member>
        <member name="P:Neon.Net.ReachableHost.Address">
            <summary>
            The target IP address or <c>null</c> if the target is unreachable.
            </summary>
        </member>
        <member name="P:Neon.Net.ReachableHost.Time">
            <summary>
            The ping and answer round trip time.
            </summary>
        </member>
        <member name="P:Neon.Net.ReachableHost.Unreachable">
            <summary>
            Indicates that the host was unreachable but was returned anyway because
            <see cref="F:Neon.Net.ReachableHostMode.ReturnFirst"/> was specified.
            </summary>
        </member>
        <member name="T:Neon.Net.ReachableHostMode">
            <summary>
            Enumerates how <see cref="M:Neon.Net.NetHelper.GetReachableHost(System.Collections.Generic.IEnumerable{System.String},Neon.Net.ReachableHostMode)"/> should
            behave when no there are no healthy hosts.
            </summary>
        </member>
        <member name="F:Neon.Net.ReachableHostMode.Throw">
            <summary>
            Throw an exception when no hosts respond.
            </summary>
        </member>
        <member name="F:Neon.Net.ReachableHostMode.ReturnFirst">
            <summary>
            Return the first host when no hosts respond.
            </summary>
        </member>
        <member name="F:Neon.Net.ReachableHostMode.ReturnNull">
            <summary>
            Return <c>null</c> when no hosts respond.
            </summary>
        </member>
        <member name="T:Neon.Retry.ExponentialRetryPolicy">
            <summary>
            Implements an <see cref="T:Neon.Retry.IRetryPolicy"/> that retries an operation 
            first at an initial interval and then doubles the interval up to a limit
            for a specified maximum number of times.
            </summary>
            <remarks>
            <para>
            You can enable transient error logging by passing a non-empty <b>logCategory</b>
            name to the constructor.  This creates an embedded <see cref="T:Neon.Diagnostics.INeonLogger"/>
            using that name and any retried transient errors will then be logged as
            warnings including <b>[transient-retry]</b> in the message.
            </para>
            <note>
            Only the retried errors will be logged.  The final exception thrown after
            all retries fail will not be logged because it's assumed that these will
            be caught and handled upstack by application code.
            </note>
            <para>
            Choose a category name that can be used to easily identify the affected
            component.  For example, <b>couchbase:my-cluster</b> to identify a
            specific Couchbase cluster.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.#ctor(System.Func{System.Exception,System.Boolean},System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy with a specific transitent detection function.
            </summary>
            <param name="transientDetector">
            Optionally specifies the function that determines whether an exception is transient 
            (see <see cref="T:Neon.Retry.TransientDetector"/>).  You can pass <c>null</c>
            if all exceptions are to be considered to be transient.
            </param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="initialRetryInterval">Optionally specifies the initial retry interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="maxRetryInterval">Optionally specifies the maximum retry interval (defaults to essentially unlimited: 24 hours).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.#ctor(System.Type,System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a specific exception type as transient.
            </summary>
            <param name="exceptionType">The exception type to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="initialRetryInterval">Optionally specifies the initial retry interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="maxRetryInterval">Optionally specifies the maximum retry interval (defaults to essentially unlimited: 24 hours).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.#ctor(System.Type[],System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a multiple exception types as transient.
            </summary>
            <param name="exceptionTypes">The exception type to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="initialRetryInterval">Optionally specifies the initial retry interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="maxRetryInterval">Optionally specifies the maximum retry interval (defaults to essentially unlimited: 24 hours).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
        </member>
        <member name="P:Neon.Retry.ExponentialRetryPolicy.MaxAttempts">
            <summary>
            Returns the maximum number of times the action should be attempted.
            </summary>
        </member>
        <member name="P:Neon.Retry.ExponentialRetryPolicy.InitialRetryInterval">
            <summary>
            Returns the initial interval between action retry attempts.
            </summary>
        </member>
        <member name="P:Neon.Retry.ExponentialRetryPolicy.MaxRetryInterval">
            <summary>
            Returns the maximum intervaL between action retry attempts. 
            </summary>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.ExponentialRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Retry.IRetryPolicy">
            <summary>
            Describes the behavior of an operation retry policy.  These are used
            to retry operations that have failed due to transient errors.
            </summary>
        </member>
        <member name="P:Neon.Retry.IRetryPolicy.Timeout">
            <summary>
            Returns the optional policy timeout.  When present, this specifies the
            maximum time the policy will continue retrying the operation.
            </summary>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.Clone">
            <summary>
            Returns a copy of the retry policy.
            </summary>
            <returns>The policy copy.</returns>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Retries an action that returns no result when it throws exceptions due to 
            transient errors.  The classification of what is a transient error, the interval
            between the retries as well as the number of times the operation are retried are
            determined by the policy implementation.
            </summary>
            <param name="action">The action to be performed.</param>
        </member>
        <member name="M:Neon.Retry.IRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Retries an action that returns <typeparamref name="TResult"/> when it throws exceptions
            due to transient errors.  he classification of what is a transient error, the interval 
            between the retries as well as the number of times the operation are retried are 
            determined by the policy implementation. 
            </summary>
            <typeparam name="TResult">The action result type.</typeparam>
            <param name="action">The action to be performed.</param>
            <returns>The action result.</returns>
        </member>
        <member name="T:Neon.Retry.LinearRetryPolicy">
            <summary>
            Implements a simple <see cref="T:Neon.Retry.IRetryPolicy"/> that retries an operation 
            at a fixed interval for a specified maximum number of times.
            </summary>
            <remarks>
            <para>
            You can enable transient error logging by passing a non-empty <b>logCategory</b>
            name to the constructor.  This creates an embedded <see cref="T:Neon.Diagnostics.INeonLogger"/>
            using that name and any retried transient errors will then be logged as
            warnings including <b>[transient-retry]</b> in the message.
            </para>
            <note>
            Only the retried errors will be logged.  The final exception thrown after
            all retries fail will not be logged because it's assumed that these will
            be caught and handled upstack by application code.
            </note>
            <para>
            Choose a category name that can be used to easily identify the affected
            component.  For example, <b>couchbase:my-cluster</b> to identify a
            specific Couchbase cluster.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.#ctor(System.Func{System.Exception,System.Boolean},System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy with a specific transitent detection function.d
            </summary>
            <param name="transientDetector">
            Optionally specifies the function that determines whether an exception is transient 
            (see <see cref="T:Neon.Retry.TransientDetector"/>).  You can pass <c>null</c>
            if all exceptions are to be considered to be transient.
            </param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="retryInterval">Optionally specifies time interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.#ctor(System.Type,System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a specific exception type as transient.
            </summary>
            <param name="exceptionType">The exception type to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="retryInterval">Optionally specifies the time interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.#ctor(System.Type[],System.Int32,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Constructs the retry policy to handle a multiple exception types as transient.
            </summary>
            <param name="exceptionTypes">The exception type to be considered to be transient.</param>
            <param name="maxAttempts">Optionally specifies the maximum number of times an action should be retried (defaults to <b>5</b>).</param>
            <param name="retryInterval">Optionally specifies the time interval between retry attempts (defaults to <b>1 second</b>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation will be retried (defaults to unconstrained)</param>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
        </member>
        <member name="P:Neon.Retry.LinearRetryPolicy.MaxAttempts">
            <summary>
            Returns the maximum number of times the action should be attempted.
            </summary>
        </member>
        <member name="P:Neon.Retry.LinearRetryPolicy.RetryInterval">
            <summary>
            Returns the fixed interval between action retry attempts.
            </summary>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.LinearRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Retry.NoRetryPolicy">
            <summary>
            Implements an <see cref="T:Neon.Retry.IRetryPolicy"/> that does not attempt to retry operations.
            </summary>
        </member>
        <member name="P:Neon.Retry.NoRetryPolicy.Instance">
            <summary>
            Returns a global invariant instance.
            </summary>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Retry.NoRetryPolicy.Timeout">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.NoRetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Retry.RetryPolicy">
            <summary>
            Base class for used to help implement a <see cref="T:Neon.Retry.IRetryPolicy"/>.
            </summary>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.#ctor(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Constructor.
            </summary>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation should be retried (defaults to no limit).</param>
        </member>
        <member name="P:Neon.Retry.RetryPolicy.Timeout">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.InvokeAsync(System.Func{System.Threading.Tasks.Task})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.LogTransient(System.Exception)">
            <summary>
            Logs a transient exception that is going to be retried if logging
            is enabled.
            </summary>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Retry.RetryPolicy.AdjustDelay(System.TimeSpan)">
            <summary>
            Adjusts the delay <see cref="T:System.TimeSpan"/> passed to ensure such
            that delaying the next retry won't exceed the overall retry
            timeout (if specified).
            </summary>
            <param name="delay">The requested delay.</param>
            <returns>The adjusted delay.</returns>
            <remarks>
            <note>
            If the result is <see cref="F:System.TimeSpan.Zero"/> or negative, the
            calling retry policy should immediately stop retrying.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Retry.RetryPolicyBase">
            <summary>
            Base class for used to help implement a <see cref="T:Neon.Retry.IRetryPolicy"/>.
            </summary>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.#ctor(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Constructor.
            </summary>
            <param name="sourceModule">Optionally enables transient error logging by identifying the source module (defaults to <c>null</c>).</param>
            <param name="timeout">Optionally specifies the maximum time the operation should be retried (defaults to no limit).</param>
        </member>
        <member name="P:Neon.Retry.RetryPolicyBase.Timeout">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.InvokeAsync(System.Func{System.Threading.Tasks.Task})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.InvokeAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.LogTransient(System.Exception)">
            <summary>
            Logs a transient exception that is going to be retried if logging
            is enabled.
            </summary>
            <param name="e">The exception.</param>
        </member>
        <member name="M:Neon.Retry.RetryPolicyBase.AdjustDelay(System.TimeSpan)">
            <summary>
            Adjusts the delay <see cref="T:System.TimeSpan"/> passed to ensure such
            that delaying the next retry won't exceed the overall retry
            timeout (if specified).
            </summary>
            <param name="delay">The requested delay.</param>
            <returns>The adjusted delay.</returns>
            <remarks>
            <note>
            If the result is <see cref="F:System.TimeSpan.Zero"/> or negative, the
            calling retry policy should immediately stop retrying.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Retry.TransientDetector">
            <summary>
            Provides some common transient error detection functions for use by
            <see cref="T:Neon.Retry.IRetryPolicy"/> implementations.
            </summary>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Always(System.Exception)">
            <summary>
            Always determines that the exception is always transient.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c></returns>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Never(System.Exception)">
            <summary>
            Never determines that the exception is never transient.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Network(System.Exception)">
            <summary>
            Considers <see cref="T:System.Net.Sockets.SocketException"/> and <see cref="T:Neon.Retry.TransientException"/> as possible
            transient errors as well as these exceptions nested within an <see cref="T:System.AggregateException"/>.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c> if the exception is to be considered as transient.</returns>
            <remarks>
            <note>
            <see cref="T:Neon.Retry.TransientException"/> is always considered to be a transient exception.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Retry.TransientDetector.Http(System.Exception)">
            <summary>
            Considers <see cref="T:Neon.Net.HttpException"/>, <see cref="T:System.Net.Http.HttpRequestException"/>, and
            <see cref="T:Neon.Retry.TransientException"/> as possible transient errors as well as these 
            exceptions nested within an <see cref="T:System.AggregateException"/>.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c> if the exception is to be considered as transient.</returns>
            <remarks>
            <note>
            <see cref="T:Neon.Retry.TransientException"/> is always considered to be a transient exception.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Retry.TransientDetector.NetworkOrHttp(System.Exception)">
            <summary>
            Considers <see cref="T:System.Net.Sockets.SocketException"/>, <see cref="T:System.Net.Http.HttpRequestException"/>, and
            <see cref="T:Neon.Retry.TransientException"/> as possible transient errors as well as these 
            exceptions nested within an <see cref="T:System.AggregateException"/>.
            </summary>
            <param name="e">The potential transient exception.</param>
            <returns><c>true</c> if the exception is to be considered as transient.</returns>
            <remarks>
            <note>
            <see cref="T:Neon.Retry.TransientException"/> is always considered to be a transient exception.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Retry.TransientDetector.MatchException(System.Exception,System.Type)">
            <summary>
            Used internally to determine whether a thrown exception matches a specific exception type.
            </summary>
            <param name="e">The thrown exception or <c>null</c>.</param>
            <param name="exceptionType">The exception type to be matched.</param>
            <returns>
            <c>true</c> if <paramref name="e"/> is not <c>null</c> and
            it's type is <paramref name="exceptionType"/> or if <paramref name="e"/>
            is a <see cref="T:System.AggregateException"/> and one of the subexceptions
            is a <paramref name="exceptionType"/>.
            </returns>
        </member>
        <member name="T:Neon.Retry.TransientException">
            <summary>
            Used to indicate an explicit transient error.
            </summary>
        </member>
        <member name="M:Neon.Retry.TransientException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">Optional inner exception.</param>
        </member>
        <member name="T:Neon.Service.ServiceApiContact">
            <summary>
            Holds the contact information for a service API.  This maps closely
            to the <b>Microsoft.OpenApi.Models.OpenApiContact</b> class.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiContact.Name">
            <summary>
            The name of the contact person or organiztion.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiContact.Url">
            <summary>
            The URL pointing to the contact information.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiContact.Email">
            <summary>
            The email address of the contact person or organization formatted
            as a URL like: <b>mailto:joe@blow.com</b>
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceApiInfo">
            <summary>
            <para>
            Human readable metadata for a service API.  This maps pretty closely
            to the <c>Microsoft.OpenApi.Models.OpenApiInfo</c> class which is used
            to by Swagger when generating ASP.NET documentation.
            </para>
            <note>
            We're not referencing the <b>Microsoft.OpenApi</b> nuget package to
            avoid adding about 166KB to applications using the <b>Neon.Common</b>
            assembly.f
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Title">
            <summary>
            API documentation title.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Description">
            <summary>
            More detailed API description.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Version">
            <summary>
            API version.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.TermsOfService">
            <summary>
            References the API terms of service.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.Contact">
            <summary>
            API contact information.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiInfo.License">
            <summary>
            API licence information.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceApiLicense">
            <summary>
            Holds the license information for a service API.  This maps closely
            to the <b>Microsoft.OpenApi.Models.OpenApiLicense</b> class.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiLicense.Name">
            <summary>
            License name.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceApiLicense.Url">
            <summary>
            The URL pointing to the licence information.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceDescription">
            <summary>
            Describes a remote service.
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceDescription.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Name">
            <summary>
            The service name as deployed to Kubernetes.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Namespace">
            <summary>
            The Kubernetes namespace where the service is deployed.  This defaults to <b>"default"</b>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Domain">
            <summary>
            The cluster's configured domain (aka zone).  This defaults to <b>"cluster.local"</b>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Address">
            <summary>
            When set, this overrides <see cref="P:Neon.Service.ServiceDescription.Name"/>, <see cref="P:Neon.Service.ServiceDescription.Namespace"/>, and
            <see cref="P:Neon.Service.ServiceDescription.Domain"/> when generating the <see cref="P:Neon.Service.ServiceDescription.Hostname"/> result.
            This is typically set for public service endpoints for public deployments
            or when emulating a cluster on a local machine for testing purposes.  
            This defaults to <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Hostname">
            <summary>
            <para>
            Returns the hostname to be used to communcate with this service.  When deployed
            to a Kubernetes cluster, this will be formed from <see cref="P:Neon.Service.ServiceDescription.Name"/> and <see cref="P:Neon.Service.ServiceDescription.Namespace"/>,
            omitting the <see cref="P:Neon.Service.ServiceDescription.Domain"/>.  When testing and <see cref="P:Neon.Service.ServiceDescription.Address"/> is not <c>null</c>,
            then this will simply be the address converted to a string.
            </para>
            <note>
            Use <see cref="P:Neon.Service.ServiceDescription.FullHostname"/> if you need the fully qualified hostname that
            includes the cluster domain.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.FullHostname">
            <summary>
            <para>
            Returns the hostname to be used to communcate with this service.  When deployed
            to a Kubernetes cluster, this will be formed from <see cref="P:Neon.Service.ServiceDescription.Name"/> and <see cref="P:Neon.Service.ServiceDescription.Namespace"/>,
            including the <see cref="P:Neon.Service.ServiceDescription.Domain"/>.  When testing and <see cref="P:Neon.Service.ServiceDescription.Address"/> is not <c>null</c>,
            then this will simply be the address converted to a string.
            </para>
            <note>
            Use <see cref="P:Neon.Service.ServiceDescription.Hostname"/> if you need the fully qualified hostname that
            includes the cluster domain.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceDescription.Endpoints">
            <summary>
            The service's network endpoints.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceEndpoint">
            <summary>
            Describes a network endpoint for remote service.
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceEndpoint.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.ServiceDescription">
            <summary>
            <para>
            The parent <see cref="P:Neon.Service.ServiceEndpoint.ServiceDescription"/>.
            </para>
            <note>
            This must be initialized before attempting to reference the endpoint.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Name">
            <summary>
            The endpoint name.  This defaults to the empty string.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Protocol">
            <summary>
            Specifies the network protocol implemented by this endpoint.
            This defaults to <see cref="F:Neon.Service.ServiceEndpointProtocol.Http"/>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.PathPrefix">
            <summary>
            This specifies the path prefix to prepended to URIs accessing this service. 
            This defaults to an empty string.  This has meaning only for the HTTP and 
            HTTPS protocols.
            </summary>
            <remarks>
            <note>
            Any leading forward slash character will be stripped when setting this.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Port">
            <summary>
            <para>
            This specifies the network port to be used for URIs accessing this service.  This defaults to <b>-1</b>
            which indicates that HTTP and HTTPS based endpoints will be initialized to their default ports <b>80</b>
            and <b>443</b> so you don't need to specify and explicit ports for these.  You will need to set this to
            a valid port for TCP and UDP protocols.
            </para>
            <note>
            <b>CAUTION:</b> It's best not to rely on this value when setting up your service network endpoints and
            reference the port from <see cref="P:Neon.Service.ServiceEndpoint.Uri"/> instead because that will always be a valid TCP port number.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.ApiInfo">
            <summary>
            ASP.NET services, this can be set to the metadata used for Swagger documentation
            generation related purposes.  This defaults to <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.Uri">
            <summary>
            <para>
            Returns the URI for the endpoint.  For HTTP and HTTPS endpoints, this will
            include the service hostname returned by the parent <see cref="P:Neon.Service.ServiceEndpoint.ServiceDescription"/>,
            along with the port and path prefix.  For TCP and UDP protocols, this will
            use the <b>tcp://</b> or <b>udp://</b> scheme along with the hostname and
            just the port.  The path prefix is ignored for TCP and UDP.
            </para>
            <para>
            When <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is <b>-1</b> for HTTP or HTTPS endpoints, the URL returned 
            will use the default port for thbe protocol (80/443).  For TCP and UDP protocols,
            the port must be a valid (non-negative) network port.
            </para>
            <note>
            For production, this property returns the partially qualified hostname for
            the host, omitting the cluster domain (e.g. <b>cluster.local</b>).  Use 
            <see cref="P:Neon.Service.ServiceEndpoint.FullUri"/> if you need the fully qualified URI.
            </note>
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is not valid for the endpoint protocol.</exception>
        </member>
        <member name="P:Neon.Service.ServiceEndpoint.FullUri">
            <summary>
            <para>
            Returns the URI for the endpoint.  For HTTP and HTTPS endpoints, this will
            include the service hostname returned by the parent <see cref="P:Neon.Service.ServiceEndpoint.ServiceDescription"/>,
            along with the port and path prefix.  For TCP and UDP protocols, this will
            use the <b>tcp://</b> or <b>udp://</b> scheme along with the hostname and
            just the port.  The path prefix is ignored for TCP and UDP.
            </para>
            <para>
            When <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is zero for HTTP or HTTPS endpoints, the URL returned 
            will use the default port for thbe protocol (80/443).  For TCP and UDP protocols,
            the port must be a valid non-zero network port.
            </para>
            <note>
            For production, this property returns the partially qualified hostname for
            the host, including the cluster domain (e.g. <b>cluster.local</b>.  Use 
            <see cref="P:Neon.Service.ServiceEndpoint.Uri"/> if you need the relative qualified URI.
            </note>
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when <see cref="P:Neon.Service.ServiceEndpoint.Port"/> is not valid for the endpoint protocol.</exception>
        </member>
        <member name="T:Neon.Service.ServiceEndpointProtocol">
            <summary>
            Enumerats the network protocols that can be implemented by a <see cref="T:Neon.Service.ServiceEndpoint"/>.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Http">
            <summary>
            HTTP.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Https">
            <summary>
            HTTPS.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Tcp">
            <summary>
            TCP.
            </summary>
        </member>
        <member name="F:Neon.Service.ServiceEndpointProtocol.Udp">
            <summary>
            UDP.
            </summary>
        </member>
        <member name="T:Neon.Service.ServiceEndpoints">
            <summary>
            Holds the endpoint definitions for a service.
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceEndpoints.Add(Neon.Service.ServiceEndpoint)">
            <summary>
            Adds an endpoint.
            </summary>
            <param name="endpoint">The endpoint.</param>
        </member>
        <member name="P:Neon.Service.ServiceEndpoints.Default">
            <summary>
            Returns the default endpoint (the one with the empty name) if present.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the default endpoint doesn't exist.</exception>
        </member>
        <member name="T:Neon.Service.ServiceMap">
            <summary>
            Describes a collection of services deployed to Kubernetes or that run in
            a simulated unit test environment.  This is simply a dictionary mapping
            case sensitive service names to <see cref="T:Neon.Service.ServiceDescription"/>
            records for each service.
            </summary>
        </member>
        <member name="M:Neon.Service.ServiceMap.Add(Neon.Service.ServiceDescription)">
            <summary>
            Adds a service description to the map.
            </summary>
            <param name="description">The service descrioption.</param>
        </member>
        <member name="M:Neon.Service.ServiceMap.Add(System.String,Neon.Service.ServiceDescription)">
            <summary>
            Adds the named service description.
            </summary>
            <param name="name">The service name.</param>
            <param name="description">The service description.</param>
        </member>
        <member name="P:Neon.Service.ServiceMap.Item(System.String)">
            <summary>
            Indexer mapping service names to their <see cref="T:Neon.Service.ServiceDescription"/>.
            </summary>
            <param name="name">The service name.</param>
            <returns>The service description or <c>null</c> if the named service is not present.</returns>
        </member>
        <member name="M:Neon.Service.ServiceMap.GetServiceEndpoint(System.String,System.String)">
            <summary>
            Returns the named endpoint for the specified service.
            </summary>
            <param name="serviceName">The target service name.</param>
            <param name="endpointName">Optionally specifies the target endpoint name (defaults to <see cref="F:System.String.Empty"/>).</param>
            <returns>The requested service endpoint.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the requested service or endpoint does not exist.</exception>
        </member>
        <member name="M:Neon.Service.ServiceMap.GetServiceEndpointUri(System.String,System.String)">
            <summary>
            Returns the named endpoint <see cref="T:System.Uri"/> for the specified service.
            </summary>
            <param name="serviceName">The target service name.</param>
            <param name="endpointName">Optionally specifies the target endpoint name (defaults to <see cref="F:System.String.Empty"/>).</param>
            <returns>The requested service endpoint <see cref="T:System.Uri"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the requested service or endpoint does not exist.</exception>
        </member>
        <member name="T:Neon.Tasks.AsyncAutoResetEvent">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <see cref="T:System.Threading.AutoResetEvent"/>.
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="initialState">
            Pass <c>true</c> to set the initial event state to signaled, <c>false</c>
            for unsignaled.
            </param>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Set">
            <summary>
            Sets the state of the event to signalled allowing a single task that is currently
            waiting or the next task that waits on the event to proceed.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.Reset">
            <summary>
            Sets the state of the event to unsignalled, so that tasks will have to wait.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncAutoResetEvent.WaitAsync">
            <summary>
            Waits until the event is signalled.
            </summary>
        </member>
        <member name="T:Neon.Tasks.AsyncManualResetEvent">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <see cref="T:System.Threading.ManualResetEvent"/>.
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="initialState">
            Pass <c>true</c> to set the initial event state to signaled, <c>false</c>
            for unsignaled.
            </param>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting on this event.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Set">
            <summary>
            Sets the state of the event to signalled allowing one or more waiting tasks
            to proceed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the event has already been closed.</exception>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.Reset">
            <summary>
            Sets the state of the event to non-signalled, causing tasks to block.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncManualResetEvent.WaitAsync">
            <summary>
            Wait asynchronously for the event to be signalled.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the event has already been closed or is closed before it is signalled.</exception>
        </member>
        <member name="T:Neon.Tasks.AsyncMutex">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <see cref="T:System.Threading.Mutex"/>.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> This class does not allow a single task to acquire the lock more than once.  
            This differs from how the regular <see cref="T:System.Threading.Mutex"/> classes work which do allow a single 
            thread to acquire the mutex more than once.
            </para>
            <para>
            This means that you cannot expect to acquire a mutex in a task and then call into a
            method that will also attempt to acquire the same mutex.  Doing this will result in 
            a deadlock.
            </para>
            </note>
            <para>
            This class can be used to grant a task exclusive access to a resource.  This class is
            pretty easy to use.  Simply instantiate an instance and then call <see cref="M:Neon.Tasks.AsyncMutex.AcquireAsync"/>
            within a <c>using</c> statement:
            </para>
            <code language="cs">
            var mutex = new AsyncMutex();
            
            using (await mutex.Acquire())
            {
                // Protected code
            }
            </code>
            <note>
            Be very sure to include the <c>await</c> within the <c>using</c> statement to avoid
            hard to debug problems.  The <c>await</c> ensures that the <c>using</c> statement
            will dispose the acquired lock as opposed to the <see cref="T:System.Threading.Tasks.Task"/> that returns
            the lock.
            </note>
            <para>
            Applications that cannot use a <c>using</c> statement may release the lock explicitly
            by disposing the object returned by the lock method, like this:
            </para>
            <code language="cs">
            var mutex  = new AsyncMutex();
            var myLock = await mutex.AcquireAsync();
            
            // Protected code.
            
            myLock.Dispose();
            </code>
            <para>
            <see cref="T:Neon.Tasks.AsyncMutex"/>'s <see cref="M:Neon.Tasks.AsyncMutex.Dispose"/> method ensures that any tasks
            waiting for a lock will be unblocked with an <see cref="T:System.ObjectDisposedException"/>.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this mutex.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this mutex.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncMutex.AcquireAsync">
            <summary>
            Acquires exclusive access to the mutex.
            </summary>
            <returns>The <see cref="T:System.IDisposable"/> instance to be disposed to release the lock.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the lock is disposed before or after this method is called.</exception>
        </member>
        <member name="T:Neon.Tasks.AsyncPeriodicTask">
            <summary>
            Implements a common asynchronous coding pattern where an asynchronous
            operation is performed periodically and cancellation and exceptions
            are handled cleanly.
            </summary>
            <remarks>
            <para>
            This class provides a nice way to implement the very common server
            side pattern where we need to periodically perform some operation 
            until the operation signals that it's done or the task is canceled,
            while handling some of the messy exception handling details.
            </para>
            <para>
            You'll use the <see cref="M:Neon.Tasks.AsyncPeriodicTask.#ctor(System.TimeSpan,System.Func{System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Threading.Tasks.Task},System.Threading.CancellationTokenSource)"/>
            constructor to create a task, passing the task interval, asynchronous task handler and optional exception handler and cancellation token
            and then call <see cref="M:Neon.Tasks.AsyncPeriodicTask.Run"/> to execute the task.
            </para>
            <para>
            <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> will call the task handler, wait for the interval and then repeat.  The task handler
            return <c>false</c> to continue running or <c>true</c> to signal that <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> should stop.
            <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> also monitors the cancellation token passed and watches for <see cref="T:System.OperationCanceledException"/>
            thrown by the task handler to stop itself.
            </para>
            <para>
            The exception handler will be called for all exceptions thrown by the task handler except for <see cref="T:System.OperationCanceledException"/>
            exceptions as these signal that <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> should terminate.  Exception handlers return <c>false</c> to continue 
            running or <c>true</c> to signal that <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> should stop.
            stop.
            </para>
            <para>
            Finally, an optional handler can be specified that will be called just before the <see cref="T:Neon.Tasks.AsyncPeriodicTask"/> terminates.
            </para>
            <note>
            This class implements <see cref="T:System.IDisposable"/> and the task will be terminated
            when this is called.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.#ctor(System.TimeSpan,System.Func{System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}},System.Func{System.Threading.Tasks.Task},System.Threading.CancellationTokenSource)">
            <summary>
            Constructs a periodic task.
            </summary>
            <param name="interval">The interval between task executions.</param>
            <param name="onTaskAsync">Called periodically to implement the task.  The callback should return <c>true</c> if the task should terminate.</param>
            <param name="onExceptionAsync">Optional callback that handles exceptions thrown by the task.  The callback should return <c>true</c> if the task should terminate.</param>
            <param name="onTerminateAsync">Optional callback that will be called just before the task terminates.</param>
            <param name="cancellationTokenSource">Optionally specifies the <see cref="P:Neon.Tasks.AsyncPeriodicTask.CancellationTokenSource"/> that can be used to stop the task.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.Dispose">
            <summary>
            Stops the task if it's running.
            </summary>
        </member>
        <member name="P:Neon.Tasks.AsyncPeriodicTask.Interval">
            <summary>
            Returns the task interval.
            </summary>
        </member>
        <member name="P:Neon.Tasks.AsyncPeriodicTask.CancellationTokenSource">
            <summary>
            Returns the cancellation token.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.Run">
            <summary>
            Asynchronously executes the task until it exits or is canceled.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.OnTerminateAsync">
            <summary>
            Asynchronously invokes the termination handler (if present).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neon.Tasks.AsyncPeriodicTask.OnExceptionAsync(System.Exception)">
            <summary>
            Asynchronously executes the exception handler (if present).
            </summary>
            <param name="e">The exception.</param>
            <returns><c>true</c> if the handler indicates that the task should be terminated.</returns>
        </member>
        <member name="T:Neon.Tasks.AsyncReaderWriterLock">
            <summary>
            Implements an <c>async</c>/<c>await</c> friendly equivalent of <b>ReaderWriterLock</b>.
            </summary>
            <remarks>
            <para>
            This class can be used to grant a single writer task exclusive access to a resource
            or multiple reader tasks.  This class is pretty easy to use.  Simply instantiate
            an instance and then call <see cref="M:Neon.Tasks.AsyncReaderWriterLock.GetReadLockAsync"/> or <see cref="M:Neon.Tasks.AsyncReaderWriterLock.GetWriteLockAsync"/>
            within a <c>using</c> statement:
            </para>
            <code language="cs">
            var rwLock = new AsyncReaderWriterLock();
            
            using (await rwLock.GetReadLockAsync())
            {
                // Protected reading code
            }
            
            using (await rwLock.GetWriteLockAsync())
            {
                // Protected writing code
            }
            </code>
            <note>
            Be very sure to include the <c>await</c> within the <c>using</c> statement to avoid
            hard to debug problems.  The <c>await</c> ensures that the <c>using</c> statement
            will dispose the acquired lock as opposed to the <see cref="T:System.Threading.Tasks.Task"/> that returns
            the lock.
            </note>
            <para>
            Applications that cannot use a <c>using</c> statement may release the lock explicitly
            by disposing the object returned by the lock method, like this:
            </para>
            <code language="cs">
            var rwLock   = new AsyncReaderWriterLock();
            var readLock = await rwLock.GetReadLockAsync();
            
            // Protected reading code.
            
            readLock.Dispose();
            </code>
            <para>
            <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/>'s <see cref="M:Neon.Tasks.AsyncReaderWriterLock.Dispose"/> method ensures that any tasks
            waiting for a lock will be unblocked with an <see cref="T:System.ObjectDisposedException"/>.
            </para>
            <para>
            This class is implemented is fairly simple and always favors writers over readers.
            Also, all waiting readers will be released together.
            </para>
            <note>
            <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/> does not support any kind of reentrant <see cref="T:System.Threading.Tasks.Task"/>
            locking support.  Child tasks will be considered to be completely independent of the parent
            and <b>will not</b> inherit the parent's lock and a single task will not be able to acquire 
            the same lock multiple times.
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="T:Neon.Tasks.AsyncReaderWriterLock.Lock">
            <summary>
            The disposable lock returned by an <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/> granting read
            or write access to a resource.  Call <see cref="M:Neon.Tasks.AsyncReaderWriterLock.Lock.Dispose"/> to release the lock.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Lock.#ctor(Neon.Tasks.AsyncReaderWriterLock,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="parent">The parent lock.</param>
            <param name="isWriteLock"><c>true</c> if for a write lock.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Lock.Dispose">
            <summary>
            Releases the lock acquired from a <see cref="T:Neon.Tasks.AsyncReaderWriterLock"/>.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Close">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this lock.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Dispose">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <remarks>
            <note>
            This method will cause a <see cref="T:System.ObjectDisposedException"/> to be thrown on
            any task waiting to acquire this lock.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.GetReadLockAsync">
            <summary>
            Acquires a non-exclusive read lock.
            </summary>
            <returns>The <see cref="T:System.IDisposable"/> instance to be disposed to release the lock.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the lock is disposed before or after this method is called.</exception>
            <remarks>
            <note>
            This class allows multiple readers to hold the lock at any given time but requires
            that writers have exclusive access.  Writers are given priority over readers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.ReleaseReadLock">
            <summary>
            Called by a <see cref="T:Neon.Tasks.AsyncReaderWriterLock.Lock"/> to release a read lock.
            </summary>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.GetWriteLockAsync">
            <summary>
            Acquires an exclusive write lock.
            </summary>
            <returns>The <see cref="T:System.IDisposable"/> instance to be disposed to release the lock.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the lock is disposed before or after this method is called.</exception>
            <remarks>
            <note>
            This class allows multiple readers to hold the lock at any given time but requires
            that writers have exclusive access.  Writers are given priority over readers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Tasks.AsyncReaderWriterLock.ReleaseWriteLock">
            <summary>
            Called by a <see cref="T:Neon.Tasks.AsyncReaderWriterLock.Lock"/> to release a write lock.
            </summary>
        </member>
        <member name="T:Neon.Tasks.NonDisposableTask">
            <summary>
            Used to convert a <see cref="T:System.Threading.Tasks.Task"/> into an awaitable that that does not
            implement <see cref="T:System.IDisposable"/>.  This is useful for avoiding confusion
            and hard to debug problems when async methods return an <see cref="T:System.IDisposable"/>
            intended to be referenced in a <c>using</c> statement.  It is very easy to forget
            the <c>await</c> keyword in this situation and because <see cref="T:System.Threading.Tasks.Task"/>
            also implements <see cref="T:System.IDisposable"/>, there will be no compiler error
            or warning.  Wrapping the task with this structure addresses this.
            </summary>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Constructor.
            </summary>
            <param name="task">The task being wrapped.</param>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask.GetAwaiter">
            <summary>
            Returns the task's awaiter.
            </summary>
        </member>
        <member name="T:Neon.Tasks.NonDisposableTask`1">
            <summary>
            Used to convert a <see cref="T:System.Threading.Tasks.Task`1"/> into an awaitable that that does not
            implement <see cref="T:System.IDisposable"/>.  This is useful for avoiding confusion
            and hard to debug problems when async methods return an <see cref="T:System.IDisposable"/>
            intended to be referenced in a <c>using</c> statement.  It is very easy to forget
            the <c>await</c> keyword in this situation and because <see cref="T:System.Threading.Tasks.Task`1"/>
            also implements <see cref="T:System.IDisposable"/>, there will be no compiler error
            or warning.  Wrapping the task with this structure addresses this.
            </summary>
            <typeparam name="T">The task result type.</typeparam>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask`1.#ctor(System.Threading.Tasks.Task{`0})">
            <summary>
            Constructor.
            </summary>
            <param name="task">The task being wrapped.</param>
        </member>
        <member name="M:Neon.Tasks.NonDisposableTask`1.GetAwaiter">
            <summary>
            Returns the task's awaiter.
            </summary>
        </member>
        <member name="T:Neon.Time.GatedTimer">
            <summary>
            Implements a timer that allows only one thread at a time to process timer events.
            </summary>
            <remarks>
            <para>
            This is necessary to because the <see cref="T:System.Threading.Timer"/> class will continue firing
            thread handlers even if a long-running thread is still handling an earlier
            timer event.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.GatedTimer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan)">
            <summary>
            Initializes and starts the timer.
            </summary>
            <param name="callback">The callback to be called when the timer fires.</param>
            <param name="state">Application state.</param>
            <param name="period">Time to wait between firing events.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes and starts the timer.
            </summary>
            <param name="callback">The callback to be called when the timer fires.</param>
            <param name="state">Application state.</param>
            <param name="dueTime">Time to wait before firing the first event.</param>
            <param name="period">Time to wait between firing events.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Time.GatedTimer.Dispose">
            <summary>
            Releases all resources associated with the timer.
            </summary>
        </member>
        <member name="M:Neon.Time.GatedTimer.Dispose(System.Boolean)">
            <summary>
            Releases any important resources associated with the instance.
            </summary>
            <param name="disposing">Pass <c>true</c> if the instance is being disposed as opposed to being finalized.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.Change(System.TimeSpan,System.TimeSpan)">
            <summary>
            Modifies the timer.
            </summary>
            <param name="dueTime">Time to wait before firing the first event.</param>
            <param name="period">Time to wait between firing events.</param>
        </member>
        <member name="M:Neon.Time.GatedTimer.OnTimer(System.Object)">
            <summary>
            Handles the timer dispatch.
            </summary>
            <param name="state"></param>
        </member>
        <member name="T:Neon.Time.GoTimeSpan">
            <summary>
            Implements support for GO Language formatted durations.  This class is
            useful for integrating with GO applications.
            </summary>
            <remarks>
            <note>
            <para>
            <see cref="T:Neon.Time.GoTimeSpan"/> measures time down 1 nanosecond resolution whereas
            <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/>'s resolution is 100ns and both implementations use
            a signed 64-bit integer as the underlying representation.  This means that
            <see cref="T:Neon.Time.GoTimeSpan"/> can represent of maximum duration of about 290
            years (positive and negative) where <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/> can handle 
            about 29,000 years.
            </para>
            <para>
            This class will throw a <see cref="T:System.ArgumentOutOfRangeException"/> when converting
            a <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/> that is beyound the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.
            </para>
            </note>
            </remarks>
        </member>
        <member name="F:Neon.Time.GoTimeSpan.TicksPerMicrosecond">
            <summary>
            The number of nanosecond ticks per micrososecond.
            </summary>
        </member>
        <member name="F:Neon.Time.GoTimeSpan.TicksPerMillisecond">
            <summary>
            The number of nanosecond ticks per millisecond.
            </summary>
        </member>
        <member name="F:Neon.Time.GoTimeSpan.TicksPerSecond">
            <summary>
            The number of nanosecond ticks per second;
            </summary>
        </member>
        <member name="F:Neon.Time.GoTimeSpan.TicksPerMinute">
            <summary>
            The number of nanosecond ticks per minute.
            </summary>
        </member>
        <member name="F:Neon.Time.GoTimeSpan.TicksPerHour">
            <summary>
            The number of nanosecond ticks per minute.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Zero">
            <summary>
            Returns a zero <see cref="T:Neon.Time.GoTimeSpan"/> .
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.MinValue">
            <summary>
            Returns the minimum possible <see cref="T:Neon.Time.GoTimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.MaxValue">
            <summary>
            Returns the maximum possible <see cref="T:Neon.Time.GoTimeSpan"/>.
            </summary>
        </member>
        <member name="F:Neon.Time.GoTimeSpan.MinValueString">
            <summary>
            The minimum value serialized to a string (computed by hand to avoid 64-bit wrap around issues.
            </summary>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.op_Implicit(Neon.Time.GoTimeSpan)~System.TimeSpan">
            <summary>
            Implicitly converts a <see cref="T:Neon.Time.GoTimeSpan"/> into a <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/>.
            </summary>
            <param name="goTimeSpan">The input <see cref="T:Neon.Time.GoTimeSpan"/>.</param>
            <returns>The equivalent <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.op_Implicit(System.TimeSpan)~Neon.Time.GoTimeSpan">
            <summary>
            Implicitly converts a <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/> into a <see cref="T:Neon.Time.GoTimeSpan"/>.
            </summary>
            <param name="timespan">The input <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/>.</param>
            <returns>The equivalent <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.TryParse(System.String,Neon.Time.GoTimeSpan@)">
            <summary>
            Attempts to parse a GO formatted timespan.  
            </summary>
            <param name="input">The input string.</param>
            <param name="goTimeSpan">Returns as the parsed timespan on success.</param>
            <returns><c>true</c> on success.</returns>
            <remarks>
            <para>
            The input is a possibly signed sequence of decimal numbers, each with 
            optional fraction and a unit suffix, such as "300ms", "-1.5h" or 
            "2h45m". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". 
            </para>
            <note>
            GO timespans are limited to about 290 years (the maximum number of
            nanoseconds that can be represented in a signed 64-bit integer).
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.Parse(System.String)">
            <summary>
            Parses a <see cref="T:Neon.Time.GoTimeSpan"/> from a string.
            </summary>
            <param name="input">The input string.</param>
            <returns>The parsed <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
            <exception cref="T:System.FormatException">Thrown if the input is not valid.</exception>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.FromTimeSpan(System.TimeSpan)">
            <summary>
            Creates a <see cref="T:Neon.Time.GoTimeSpan"/> from a <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/>.
            </summary>
            <param name="timespan">The input time span.</param>
            <returns>The new <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.FromNanoseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoTimeSpan"/> from nanoseconds.
            </summary>
            <param name="nanoseconds">The duration in nanoseconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.FromMicroseconds(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoTimeSpan"/> from microseconds.
            </summary>
            <param name="milliseconds">The duration in microseconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.FromMilliseconds(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoTimeSpan"/> from milliseconds.
            </summary>
            <param name="milliseconds">The duration in milliseconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.FromSeconds(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoTimeSpan"/> from seconds.
            </summary>
            <param name="seconds">The duration in seconds.</param>
            <returns>The new <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.FromMinutes(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoTimeSpan"/> from minutes.
            </summary>
            <param name="minutes">The duration in minutes.</param>
            <returns>The new <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.FromHours(System.Double)">
            <summary>
            Returns a <see cref="T:Neon.Time.GoTimeSpan"/> from hours.
            </summary>
            <param name="hours">The duration in hours.</param>
            <returns>The new <see cref="T:Neon.Time.GoTimeSpan"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.ToTicks(System.Double)">
            <summary>
            Converts a <c>double</c> nanosecond count to a <c>long</c>, ensuring that the
            result can be represented as a <see cref="T:Neon.Time.GoTimeSpan"/>.
            </summary>
            <param name="nanoseconds">The input <c>douuble</c>.</param>
            <returns>The output <c>long</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.</exception>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.#ctor(System.Int64)">
            <summary>
            Constructs a <see cref="T:Neon.Time.GoTimeSpan"/> from nanoseconds.
            </summary>
            <param name="nanoseconds">The duration in nanoseconds.</param>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.#ctor(System.TimeSpan)">
            <summary>
            Constructs an instance from a <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/>.
            </summary>
            <param name="timespan">The time span.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input is outside the capability of a <see cref="T:Neon.Time.GoTimeSpan"/>.</exception>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Ticks">
            <summary>
            The duration expressed as nanosecond ticks.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.TotalNanoseconds">
            <summary>
            Returns the duration as nanoseconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.TotalMicroseconds">
            <summary>
            Returns the total number of microseconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.TotalMilliseconds">
            <summary>
            Returns the total number of milliseconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.TotalSeconds">
            <summary>
            Returns the total number of seconds.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.TotalMinutes">
            <summary>
            Returns the total number of minutes.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.TotalHours">
            <summary>
            Returns the total number of hours.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Nanoseconds">
            <summary>
            Returns the nanosecond component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Microseconds">
            <summary>
            Returns the microsecond component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Milliseconds">
            <summary>
            Returns the millisecond component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Seconds">
            <summary>
            Returns the second component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Minutes">
            <summary>
            Returns the minutes component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.Hours">
            <summary>
            Returns the hours component of the duration.
            </summary>
        </member>
        <member name="P:Neon.Time.GoTimeSpan.TimeSpan">
            <summary>
            Returns the equivalent <see cref="P:Neon.Time.GoTimeSpan.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:Neon.Time.GoTimeSpan.ToString">
            <summary>
            Renders the time span as a GO Duration compatible string.
            </summary>
            <returns>The GO duration.</returns>
        </member>
        <member name="T:Neon.Time.PolledTimer">
            <summary>
            Implements a timer suitable for use in scenarios that need to 
            poll periodically to see if an action needs to be performed.
            </summary>
            <remarks>
            <para>
            A common programming pattern is to have background threads check
            periodically for something to do; like resend a message, clean up
            idle connections, or signal a timeout.  The <see cref="T:Neon.Time.PolledTimer" />
            class provides an easy way to encapsulate the interval and next
            scheduled time at which these events should happen.
            </para>
            <para>
            Use <see cref="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan)" /> or <see cref="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan,System.Boolean)" />
            to create a timer, specifying the firing interval.  The second constructor
            also specifies the <i>autoReset</i> parameter which indicates that the
            timer should automatically reschedule itself after being fired.  Note that
            one of these constructors <b>must be used</b>.  <see cref="T:Neon.Time.PolledTimer" />
            structures created with the default constructor will thow a <see cref="T:System.InvalidOperationException" />
            when an attempt is made to use it.
            </para>
            <para>
            While being constructed, a polled timer calculates its next scheduled firing time (SYS).
            Note that this value generated by <see cref="T:Neon.Time.SysTime" /> not a normal system time.
            The scheduled firing time is available as the <see cref="P:Neon.Time.PolledTimer.FireTime" /> property.
            Ther current interval is available as the <see cref="P:Neon.Time.PolledTimer.Interval" /> property.
            </para>
            <para>
            Use <see cref="P:Neon.Time.PolledTimer.HasFired" /> to determine if the timer has been fired.  This
            will return <c>true</c> if this is the case.  If <i>autoReset=true</i> was 
            passed to the constructor, then <see cref="P:Neon.Time.PolledTimer.HasFired" /> will automatically 
            reset the timer by scheduling the next firing time.  If <i>autoReset=false</i>,
            then the timer will remain in the fired state until <see cref="M:Neon.Time.PolledTimer.Reset" /> is
            called.
            </para>
            <para>
            Asynchronous applications may find it more convienent to call <see cref="M:Neon.Time.PolledTimer.WaitAsync(System.TimeSpan)"/>
            to wait for the timer to fire.
            </para>
            <para>
            The <see cref="M:Neon.Time.PolledTimer.Reset" />, <see cref="M:Neon.Time.PolledTimer.ResetImmediate" />, and <see cref="M:Neon.Time.PolledTimer.ResetRandom" /> 
            methods are used recalcuclate the firing time.  The first variation schedules this time as
            the current time plus the timer interval.  The second variation schedules
            the timer for immediate firing (typically used right after the timer is
            constructed in situations where the application wishes the timer to fire
            right away the first time it is polled), and the third method resets the timer
            to fire at a random interval between zero and the timer's interval (useful when
            trying to avoid having multiple timers fire at the same time).
            </para>
            <para>
            The <see cref="M:Neon.Time.PolledTimer.Disable" /> method prevents the timer from firing until
            <see cref="M:Neon.Time.PolledTimer.Reset" /> is called or <see cref="P:Neon.Time.PolledTimer.Interval" /> is set.
            This is useful for preventing a timer from firing when an operation
            initiated from a previous firing is still executing (perhaps on another
            thread).
            </para>
            </remarks>
            <threadsafety instance="true" />
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor">
            <summary>
            The default constructor creates a timer that is initially disabled.
            </summary>
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor(System.Boolean)">
            <summary>
            The default constructor creates a timer that is initially disabled
            with optional auto reset capabilities. 
            </summary>
            <param name="autoReset">Indicates whether the timer should automatically reset itself after firing.</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan)">
            <summary>
            Constructs a timer, initializing it to fire at the specified interval.
            </summary>
            <param name="interval">The timer interval.</param>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.#ctor(System.TimeSpan,System.Boolean)">
            <summary>
            Constructs a timer with the option of auto resetting itself.
            </summary>
            <param name="interval">The timer interval.</param>
            <param name="autoReset">Pass <c>true</c> to create an auto reset timer.</param>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.Reset">
            <summary>
            Reschedules the timer to fire at the current time plus the timer interval.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetImmediate">
            <summary>
            Reschedules the timer to fire immediately.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetRandom">
            <summary>
            Reschedules the timer to fire at a random time between now and the timer interval.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetAddRandom(System.TimeSpan)">
            <summary>
            Reschedules the timer to fire at a random time between the current scheduled
            firing time and a random interval between <see cref="F:System.TimeSpan.Zero" /> and
            <paramref name="interval" />.
            </summary>
            <param name="interval">The interval to be randomized (can be positive or negative).</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.Reset(System.TimeSpan)">
            <summary>
            Assigns a new interval to the timer and reschedules the timer
            to fire at the current time plus the new interval.
            </summary>
            <param name="interval">The new timer interval.</param>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetTemporary(System.TimeSpan)">
            <summary>
            Reschedules the timer to fire at the current time plus the specified interval
            but <b>does not</b> change the underlying timer interval.  Subsequent timer
            resets will continue to use the original interval.
            </summary>
            <param name="interval">The timer wait interval.</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.ResetRandomTemporary(System.TimeSpan,System.TimeSpan)">
            <summary>
            Reschedules the timer to fire at the current time plus a randomly selected
            time between the two intervals passed.  This call <b>does not</b> change the 
            underlying timer interval.  Subsequent timer resets will continue to use the 
            original interval.
            </summary>
            <param name="minInterval">The minimum timer wait interval.</param>
            <param name="maxInterval">The maximum timer wait interval.</param>
        </member>
        <member name="M:Neon.Time.PolledTimer.FireNow">
            <summary>
            Sets the timer into the fired state.
            </summary>
        </member>
        <member name="M:Neon.Time.PolledTimer.Disable">
            <summary>
            Prevents the timer from firing until one of the <see cref="M:Neon.Time.PolledTimer.Reset" /> methods
            are called or <see cref="P:Neon.Time.PolledTimer.Interval" /> is assigned a new value.
            </summary>
        </member>
        <member name="P:Neon.Time.PolledTimer.HasFired">
            <summary>
            Determines whether the timer has fired.
            </summary>
            <returns><c>true</c> if the timer has fired.</returns>
            <remarks>
            For auto reset timers, this property will reschedule the next
            firing time if the timer has fired.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="M:Neon.Time.PolledTimer.WaitAsync(System.TimeSpan)">
            <summary>
            Waits aynchronously for the timer to fire.
            </summary>
            <param name="pollInterval">Optional timer polling interval (defaults to <b>15 seconds</b>).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="P:Neon.Time.PolledTimer.FireTime">
            <summary>
            Returns the scheduled firing time (SYS).
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
        </member>
        <member name="P:Neon.Time.PolledTimer.Interval">
            <summary>
            The current timer interval.
            </summary>
            <remarks>
            <note>Setting a new interval causes the timer fire time to be rescheduled.</note>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the timer was created using the default constructor.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the interval passed is not positive.</exception>
        </member>
        <member name="T:Neon.Time.RecurringTimer">
            <summary>
            Used to manage tasks that need to be performed on a periodic basis.
            </summary>
            <remarks>
            <para>
            This timer is designed to be polled periodically from an application's background
            thread by calling the <see cref="M:Neon.Time.RecurringTimer.HasFired" /> or <see cref="M:Neon.Time.RecurringTimer.HasFired(System.DateTime)" />
            methods.  These methods will return <c>true</c> if the action associated with the timer
            is to be performed.
            </para>
            <para>
            This class works by watching for the transition between a call to <see cref="M:Neon.Time.RecurringTimer.HasFired" />
            made at a time before the scheduled event and then a subsequent call made when the 
            current time is at or after the scheduled event time. <see cref="M:Neon.Time.RecurringTimer.HasFired" /> will
            return <c>true</c> on the subsequent call if the time is right.
            </para>
            <para>
            This behavior ensures that scheduled tasks will only be executed once for any recurring
            schedule, even if the application is restarted.
            </para>
            <para>
            The <see cref="M:Neon.Time.RecurringTimer.HasFired" /> method uses the current UTC time to perform the
            time comparison.  The <see cref="M:Neon.Time.RecurringTimer.HasFired(System.DateTime)" /> will use the time passed
            (which may be local time, etc.) to do this.
            </para>
            <note>
            <para>
            This timer auto resets after <see cref="M:Neon.Time.RecurringTimer.HasFired" /> returns <c>true</c>.  Note also
            that <see cref="M:Neon.Time.RecurringTimer.HasFired" /> must be called fairly frequently (on the order of a few minutes or less)
            to obtain reasonable accuracy.
            </para>
            <para>
            Asynchronous applications may find it more convienent to call <see cref="M:Neon.Time.RecurringTimer.WaitAsync(System.TimeSpan)"/>
            to wait for the timer to fire.
            </para>
            <para>
            The <see cref="M:Neon.Time.RecurringTimer.Reset"/> and <see cref="M:Neon.Time.RecurringTimer.Reset(System.DateTime)"/> methods may be used to explictly
            reset the timer to fire at the next scheduled time.  This may be useful for ensuring that
            short duration timers are properly reset after an operation that may take longer to
            complete than the timer interval.
            </para>
            </note>
            <para>
            Recurring timers are represented as strings with the format of the string
            depending on the type of timer.  The table below describes these formats:
            </para>
            <list type="table">
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Disabled" /></term>
                    <description>
                    <para>
                    Disabled timers never fire.  Simply place the word <b>Disabled</b> at the
                    beginning of the timer string.
                    </para>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Minute" /></term>
                    <description>
                    <para>
                    Minute timers fire at the top of every minute.  There is no offset.  Minute
                    timers are formatted as:
                    </para>
                    <example>
                    Minute
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.QuarterHour" /></term>
                    <description>
                    <para>
                    Quarter hour timers are fired four times an hour at the offset from the 15 minute time.  
                    Quarter hour timers formatted as:
                    </para>
                    <example>
                    QuarterHour
                    QuarterHour:MM
                    QuarterHour:MM:SS
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Hourly" /></term>
                    <description>
                    <para>
                    Hourly timers are fired once per hour at the offset from the top of the hour.  Hourly timers
                    are formatted as:
                    </para>
                    <example>
                    Hourly
                    Hourly:MM
                    Hourly:MM:SS
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Daily" /></term>
                    <description>
                    <para>
                    Daily timers are fired once per day at the specified time of day.  Daily timers
                    are formatted as:
                    </para>
                    <example>
                    Daily
                    Daily:HH:MM
                    Daily:HH:MM:SS
                    </example>
                    </description>
                </item>
                <item>
                    <term><see cref="F:Neon.Time.RecurringTimerType.Interval" /></term>
                    <description>
                    <para>
                    Interval timers are fired on a regular interval that is not not
                    tied to a specific period.  Interval timers are formatted as:
                    </para>
                    <example>
                    Interval:HH:MM:SS
                    </example>
                    </description>
                </item>
            </list>
            </remarks>
            <threadsafety instance="false" />
        </member>
        <member name="P:Neon.Time.RecurringTimer.Disabled">
            <summary>
            Returns a disabled timer.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.TryParse(System.String,Neon.Time.RecurringTimer@)">
            <summary>
            Attempts to parse <see cref="T:Neon.Time.RecurringTimer"/> from a string.
            </summary>
            <param name="input">The input string.</param>
            <param name="timer">Returns as the parsed timer.</param>
            <returns><c>true</c> if the timer was parsed successfully.</returns>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor">
            <summary>
            Default constructor that creates a <see cref="F:Neon.Time.RecurringTimerType.Disabled" /> timer.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor(System.String)">
            <summary>
            Constructs a timer by parsing a string value.
            </summary>
            <param name="value">The string representation.</param>
            <exception cref="T:System.ArgumentException">Thrown if the string passed is not valid.</exception>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor(Neon.Time.RecurringTimerType,System.TimeSpan)">
            <summary>
            Constructs a recurring timer of the specified type and time offset from
            the beginning of the implied period.
            </summary>
            <param name="type">Describes the timer type which implies the period.</param>
            <param name="timeOffset">The time offset from the beginning of the implied timer period.</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.#ctor(Neon.Time.TimeOfDay)">
            <summary>
            Constructs a recurring timer that will fire once a day at the specified time offset.
            </summary>
            <param name="timeOfDay">The time of day offset.</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.HasFired">
            <summary>
            Determines whether the timer has fired by comparing the current UTC time with
            the scheduled event time.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.HasFired(System.DateTime)">
            <summary>
            Determines if the timer has fired by comparing the current time passed with
            the next scheduled firing time.
            </summary>
            <param name="nowUtc">The current time (UTC).</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.WaitAsync(System.TimeSpan)">
            <summary>
            Waits aynchronously for the timer to fire.
            </summary>
            <param name="pollInterval">Optional timer polling interval (defaults to <b>15 seconds</b>).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Reset">
            <summary>
            Resets the timer to fire at the next scheduled interval after the current UTC time.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Reset(System.DateTime)">
            <summary>
            Resets the timer to fire at the next scheduled interval after the time passed.
            </summary>
            <param name="now">The current time.</param>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Start">
            <summary>
            Starts the timer by computing the next firing time after the current time (UTC).
            </summary>
            <remarks>
            <para>
            Applications may use this method to initalize the timer.  This is useful in situations where
            some time may pass between the time the timer was constructed and the first time
            <see cref="M:Neon.Time.RecurringTimer.HasFired" /> has been called.  In these situations, the timer will
            not fire for a scheduled event that occurs during this interval.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Start(System.DateTime)">
            <summary>
            Starts the timer by computing the next firing time after the time passed.
            </summary>
            <param name="nowUtc">The current time (UTC).</param>
            <remarks>
            <para>
            Applications may use this method to initalize the timer.  This is useful in situations where
            some time may pass between the time the timer was constructed and the first time
            <see cref="M:Neon.Time.RecurringTimer.HasFired" /> has been called.  In these situations, the timer will
            not fire for a scheduled event that occurs during this interval.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.RecurringTimer.Set(System.DateTime)">
            <summary>
            Sets the firing time for the timer.
            </summary>
            <param name="timeUtc">Optionally specifies the scheduled time (UTC) (defaults to now).</param>
            <remarks>
            This is useful in situations where it is necessary to special-case a
            specific firing time.
            </remarks>
        </member>
        <member name="P:Neon.Time.RecurringTimer.Type">
            <summary>
            Returns the timer type.
            </summary>
        </member>
        <member name="P:Neon.Time.RecurringTimer.TimeOffset">
            <summary>
            Returns the <see cref="T:System.TimeSpan" /> offet from the beginning of the 
            period when the timer is scheduled to fire.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.GetTimeOffsetString">
            <summary>
            Renders the local timeoffset into a nice string.
            </summary>
        </member>
        <member name="M:Neon.Time.RecurringTimer.ToString">
            <summary>
            Renders the timer into a string.
            </summary>
            <returns>The timer string.</returns>
        </member>
        <member name="M:Neon.Time.RecurringTimer.TryParse(System.String)">
            <summary>
            Attempts to parse the configuration value.
            </summary>
            <param name="input">The configuration value.</param>
            <returns><c>true</c> if the value could be parsed, <b></b> if the value is not valid for the type.</returns>
        </member>
        <member name="T:Neon.Time.RecurringTimerType">
            <summary>
            Enumerates the possible <see cref="T:Neon.Time.RecurringTimer" /> types.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Disabled">
            <summary>
            The timer never fires.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Minute">
            <summary>
            The timer will be fired once per minute. 
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.QuarterHour">
            <summary>
            The timer will be fired once every 15 minutes.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Hourly">
            <summary>
            The timer will be fired once per hour.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Daily">
            <summary>
            The timer will be fired once per day.
            </summary>
        </member>
        <member name="F:Neon.Time.RecurringTimerType.Interval">
            <summary>
            The timer is fired on a specified interval rather than a 
            specific period offset.  This is similar to how <see cref="T:Neon.Time.PolledTimer" />
            works.
            </summary>
        </member>
        <member name="T:Neon.Time.SysTime">
            <summary>
            A date/time implementation that is guaranteed to be monotonically increasing
            even as the underlying system time is updated manually or automatically to adjust
            for daylight savings time or clock skewing.
            </summary>
            <remarks>
            <para>
            Use of system time rather than real-time is useful in situations
            where events need to be timed in relative rather than absolute time.
            Using absolute time to measure intervals call can be problematic
            because system clock may be have to be periodically corrected to
            keep it in sync with a global time base.  These corrections will
            cause event timers to become inaccurate.
            </para>
            <para>
            The <see cref="P:Neon.Time.SysTime.Now" /> property returns the current system time and
            <see cref="P:Neon.Time.SysTime.Infinite" /> calculates and returns an essentially infinite
            timespan value that will be safe when added to the current system time.
            </para>
            <note>
            The <see cref="T:System.DateTime" /> instances returned by this class are useful
            only for measuring timespans.  The Day, Month, Year properties 
            will have no useful meaning.
            </note>
            <note>
            The class is implemented such that the first time
            returned by the <see cref="P:Neon.Time.SysTime.Now" /> property will be a time value that 
            is a minumim of one year after <see cref="F:System.DateTime.MinValue" />.  This is 
            useful in situations where programs want to schedule a periodic event 
            for immediate triggering when the application starts by setting the last trigger
            time to <see cref="F:System.DateTime.MinValue" />.
            </note>
            <para>
            The <see cref="T:Neon.Time.SysTime" /> class is also capable of maintaining rough
            synchronization with an external time source.  To use this feature,
            you'll periodically get the time from the external source and assign
            it to the static <see cref="P:Neon.Time.SysTime.ExternalNow" /> property then you can
            use the <see cref="P:Neon.Time.SysTime.ExternalNow" /> property to get and estimate of the
            current external time.
            </para>
            <para>
            The local side clock will likely drift over time, resulting in a skew
            between the time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> and the actual
            time at the external source.  This skew can be limited by getting the
            external time and assigning it to <see cref="P:Neon.Time.SysTime.ExternalNow" /> more
            frequently.
            </para>
            <note>
            The time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> is not guaranteed to be
            monotimically increasing since reported times may jump around as the
            bias between the local and external clocks are adjusted.
            </note>
            <para><b><u>Implementation Note</u></b></para>
            <para>
            This class is currently implemented using the Windows <b>GetTickCount()</b> API.
            This function returns the number of milliseconds since the operating system
            was booted with a resolution equal to the process/threading timeslice (typically
            10-15 milliseconds).  The actual resolution for the current machine can be
            obtained from <see cref="P:Neon.Time.SysTime.Resolution" />.
            </para>
            <para>
            The <see cref="P:System.Environment.TickCount"/> counter is an unsigned 32-bit value and will wrap-around
            every 49.7 days.  The <see cref="T:Neon.Time.SysTime" /> class handles this by using a <see cref="T:Neon.Time.GatedTimer" />
            to wake up every five minutes to check for and handle this wrap-around.
            </para>
            <para>
            As noted above, the time value returned by <see cref="P:Neon.Time.SysTime.Now" /> has no relation
            to the actual calendar date.  The first date returned after booting the computer
            will be approximately 1/1/0002 00:00:00, one year <i>greater</i> the minimum <see cref="T:System.DateTime" />
            value.  <see cref="P:Neon.Time.SysTime.Infinite" /> returns a calculated value that when added to <see cref="P:Neon.Time.SysTime.Now" />
            will result in a date one year less then the maximum <see cref="T:System.DateTime" /> value.
            </para>
            <para>
            These one year offsets were choosen so that applications can perform reasonable
            offset calculations (e.g. within background tasks) without fear of wrap-around.
            Since <see cref="T:System.DateTime" /> and <see cref="T:System.TimeSpan" /> span up to 10,000
            years, this means that <see cref="T:Neon.Time.SysTime" /> calculations will remain valid
            for up to 9,998 years after the computer has been started, which should be
            good enough for most applications.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Time.SysTime.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Time.SysTime.Reset">
            <summary>
            Used by Unit tests to reset the timer class to its initial value.
            </summary>
        </member>
        <member name="M:Neon.Time.SysTime.OnTimer(System.Object)">
            <summary>
            This will be called on 5 minute intervals to ensure that we catch
            tickcount rollovers and increment the msi field appropriately.
            </summary>
            <param name="state">Not used.</param>
        </member>
        <member name="M:Neon.Time.SysTime.GetTime">
            <summary>
            Returns the current time relative to time the system started.
            </summary>
        </member>
        <member name="P:Neon.Time.SysTime.Now">
            <summary>
            Returns the current time relative to time the system started.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if there's a problem with the system timer.</exception>
        </member>
        <member name="P:Neon.Time.SysTime.Resolution">
            <summary>
            Returns the resolution of the underlying system timer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if there's a problem with the system timer.</exception>
        </member>
        <member name="P:Neon.Time.SysTime.Infinite">
            <summary>
            Returns what is essentially an infinite timespan.
            </summary>
            <remarks>
            <para>
            The value returned will calculated such that when added to the
            current <see cref="T:Neon.Time.SysTime" />.<see cref="P:Neon.Time.SysTime.Now" /> value that the
            result will be <see cref="F:System.DateTime.MaxValue" /> minus one year.
            </para>
            <para>
            This is useful for situations where you need specify an infinite
            timeout but you want to avoid wrap-around when adding this to
            the current <see cref="T:Neon.Time.SysTime" />.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if there's a problem with the system timer.</exception>
        </member>
        <member name="P:Neon.Time.SysTime.ExternalNow">
            <summary>
            Tracks an external time source.
            </summary>
            <remarks>
            <para>
            The <see cref="T:Neon.Time.SysTime" /> class is also capable of maintaining rough
            synchronization with an external time source.  To use this feature,
            you'll periodically get the time from the external source and assign
            it to the static <see cref="P:Neon.Time.SysTime.ExternalNow" /> property then you can
            use the <see cref="P:Neon.Time.SysTime.ExternalNow" /> property to get and estimate of the
            current external time.
            </para>
            <para>
            The local side clock will likely drift over time, resulting in a skew
            between the time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> and the actual
            time at the external source.  This skew can be limited by getting the
            external time and assigning it to <see cref="P:Neon.Time.SysTime.ExternalNow" /> more
            frequently.
            </para>
            <note>
            The time returned by <see cref="P:Neon.Time.SysTime.ExternalNow" /> is not guaranteed to be
            monotimically increasing since reported times may jump around as the
            bias between the local and external clocks are adjusted.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Time.TimeOfDay">
            <summary>
            Represents the time offset since the beginning of the day.
            </summary>
            <threadsafety instance="true" />
        </member>
        <member name="M:Neon.Time.TimeOfDay.TryParse(System.String,Neon.Time.TimeOfDay@)">
            <summary>
            Attempts to parse a string of the form HH:MM or HH:MM:SS into a
            time of day offset.
            </summary>
            <param name="value">The string to be parsed.</param>
            <param name="timeOfDay">Returns as the parsed time of day on success.</param>
            <returns><c>true</c> if the string was parsed successfully, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.DateTime)">
            <summary>
            Constructs a time of day offset by stripping the date portion
            from the parameter passed.
            </summary>
            <param name="date">The source date time.</param>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a time of day offset from hours and minutes.
            </summary>
            <param name="hours">The hours.</param>
            <param name="minutes">The minutes.</param>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a time of day offset from hours, minutes, and seconds.
            </summary>
            <param name="hours">The hours.</param>
            <param name="minutes">The minutes.</param>
            <param name="seconds">The seconds.</param>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.String)">
            <summary>
            Constructs a time of day offset by parsing a string of the form HH:MM or HH:MM:SS.
            </summary>
            <param name="value">The input string.</param>
            <exception cref="T:System.ArgumentException">Thrown if the string passed does not represent a valid time of day offset.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.#ctor(System.TimeSpan)">
            <summary>
            Constructs a time of day offset from a <see cref="P:Neon.Time.TimeOfDay.TimeSpan" />.
            </summary>
            <param name="offset">The time offset from the beginning of the day.</param>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="M:Neon.Time.TimeOfDay.Validate">
            <summary>
            Checks to make sure that the specified offset is valid.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if the specified offset is negative or &gt;= 24 hours.</exception>
        </member>
        <member name="P:Neon.Time.TimeOfDay.Hour">
            <summary>
            Returns the hours part of the time offset.
            </summary>
        </member>
        <member name="P:Neon.Time.TimeOfDay.Minute">
            <summary>
            Returns the minutes part of the time offset.
            </summary>
        </member>
        <member name="P:Neon.Time.TimeOfDay.Second">
            <summary>
            Returns the seconds part of the time offset.
            </summary>
        </member>
        <member name="P:Neon.Time.TimeOfDay.TimeSpan">
            <summary>
            Returns the offset as a <see cref="P:Neon.Time.TimeOfDay.TimeSpan" />.
            </summary>
        </member>
        <member name="M:Neon.Time.TimeOfDay.ToString">
            <summary>
            Renders the time of day value as a string formatted as HH:MM:SS.
            </summary>
            <returns>The formatted string.</returns>
        </member>
        <member name="T:Neon.Windows.PowerShell">
            <summary>
            <para>
            Internal proxy for executing PowerShell commands on Windows machines.
            </para>
            <note>
            This class requires elevated administrative rights.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Windows.PowerShell.PwshPath">
            <summary>
            Optional path to the Powershell Core <b>pwsh</b> executable.  The <b>PATH</b>
            environment variable will be searched by default.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.GetPwshPath">
            <summary>
            Returns the path to the Powershell Core <b>pwsh</b> executable.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.#ctor(System.Action{System.String},System.Action{System.String})">
            <summary>
            Default constructor to be used to execute local PowerShell commands.
            </summary>
            <param name="outputAction">Optionally specifies an action to receive logged output.</param>
            <param name="errorAction">Optionally specifies an action to receive logged error output.</param>
            <exception cref="T:System.NotSupportedException">Thrown if we're not running on Windows.</exception>
            <remarks>
            You can pass callbacks to the <paramref name="outputAction"/> and/or <paramref name="errorAction"/>
            parameters to be receive logged output and errors.  Note that <paramref name="outputAction"/> will receive
            both STDERR and STDOUT text if <paramref name="errorAction"/> isn't specified.
            </remarks>
        </member>
        <member name="M:Neon.Windows.PowerShell.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.Dispose">
            <summary>
            Releases all resources associated with the instance.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShell.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Windows.PowerShell.ExpandEnvironmentVars(System.String)">
            <summary>
            Expands any environment variables of the form <b>${NAME}</b> in the input
            string and returns the expanded result.
            </summary>
            <param name="input">The input string.</param>
            <returns>The expanded output string.</returns>
        </member>
        <member name="M:Neon.Windows.PowerShell.Execute(System.String,System.Boolean)">
            <summary>
            Executes a PowerShell command that returns a simple string result.
            </summary>
            <param name="command">The command string.</param>
            <param name="noEnvironmentVars">
            Optionally disables that environment variable subsitution (defaults to <c>false</c>).
            </param>
            <returns>The command response.</returns>
            <exception cref="T:Neon.Windows.PowerShellException">Thrown if the command failed.</exception>
        </member>
        <member name="M:Neon.Windows.PowerShell.ExecuteJson(System.String,System.Boolean)">
            <summary>
            Executes a PowerShell command that returns result JSON, subsituting any
            environment variable references of the form <b>${NAME}</b> and returning a list 
            of <c>dynamic</c> objects parsed from the table with the object property
            names set to the table column names and the values parsed as strings.
            </summary>
            <param name="command">The command string.</param>
            <param name="noEnvironmentVars">
            Optionally disables that environment variable subsitution (defaults to <c>false</c>).
            </param>
            <returns>The list of <c>dynamic</c> objects parsed from the command response.</returns>
            <exception cref="T:Neon.Windows.PowerShellException">Thrown if the command failed.</exception>
        </member>
        <member name="T:Neon.Windows.PowerShellException">
            <summary>
            Thrown by <see cref="T:Neon.Windows.PowerShell"/> when an error is detected.
            </summary>
        </member>
        <member name="M:Neon.Windows.PowerShellException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The exception message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="T:Neon.Windows.Win32">
            <summary>
            Low-level Windows system calls.
            </summary>
        </member>
        <member name="M:Neon.Windows.Win32.GetPhysicallyInstalledSystemMemory(System.Int64@)">
            <summary>
            Returns the total installed physical RAM as kilobytes.
            </summary>
            <param name="TotalMemoryInKilobytes">Returns as the physical RAM as KiB.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="M:Neon.Windows.Win32.EncryptFile(System.String)">
            <summary>
            Has Windows encrypt a file or folder at rest.
            </summary>
            <param name="path">The file or folder path.</param>
            <returns><c>true</c> on success.</returns>
        </member>
        <member name="T:Newtonsoft.Json.Linq.JsonExtensions">
            <summary>
            Newtonsoft JSON Linq extensions.
            </summary>
        </member>
        <member name="M:Newtonsoft.Json.Linq.JsonExtensions.TryGetValue``1(Newtonsoft.Json.Linq.JObject,System.String,``0@)">
            <summary>
            Attempts to return the value of a specified <see cref="T:Newtonsoft.Json.Linq.JObject"/> property
            converted to a specific type.
            </summary>
            <typeparam name="T">The desired type.</typeparam>
            <param name="jObject">The <see cref="T:Newtonsoft.Json.Linq.JObject"/> instance.</param>
            <param name="propertyName">The property name.</param>
            <param name="value">Returns as the property value if present.</param>
            <returns><c>true</c> if the property was present and returned.</returns>
        </member>
        <member name="T:System.Diagnostics.Contracts.Covenant">
            <summary>
            A simple, lightweight, and partial implementation of the Microsoft Dev Labs <c>Contract</c> class.
            </summary>
            <remarks>
            <para>
            This class is intended to be a drop-in replacement for code contract assertions by simply
            searching and replacing <b>"Contract."</b> with "<see cref="T:System.Diagnostics.Contracts.Covenant"/>." in all source code.
            In my experience, code contracts slow down build times too much and often obsfucate 
            <c>async</c> methods such that they cannot be debugged effectively using the debugger.
            Code Contracts are also somewhat of a pain to configure as project propoerties.
            </para>
            <para>
            This class includes the <see cref="M:System.Diagnostics.Contracts.Covenant.Requires(System.Boolean,System.String)"/>, <see cref="M:System.Diagnostics.Contracts.Covenant.Requires``1(System.Boolean,System.String)"/>
            and <see cref="M:System.Diagnostics.Contracts.Covenant.Assert(System.Boolean,System.String)"/> methods that can be used to capture validation
            requirements in code, but these methods don't currently generate any code. 
            </para>
            </remarks>
        </member>
        <member name="M:System.Diagnostics.Contracts.Covenant.Requires(System.Boolean,System.String)">
            <summary>
            Verifies a method pre-condition.
            </summary>
            <param name="condition">The condition to be tested.</param>
            <param name="message">An optional message to be included in the exception thrown.</param>
            <exception cref="T:Neon.Diagnostics.AssertException">Thrown if <paramref name="condition"/> is <c>false</c>.</exception>
        </member>
        <member name="M:System.Diagnostics.Contracts.Covenant.Requires``1(System.Boolean,System.String)">
            <summary>
            Verifies a method pre-condition throwing a custom exception.
            </summary>
            <typeparam name="TException">The exception to be thrown if the condition is <c>false</c>.</typeparam>
            <param name="condition">The condition to be tested.</param>
            <param name="message">An optional message to be included in the exception thrown.</param>
        </member>
        <member name="M:System.Diagnostics.Contracts.Covenant.Assert(System.Boolean,System.String)">
            <summary>
            Asserts that a condition is <c>true</c>.
            </summary>
            <param name="condition">The condition to be tested.</param>
            <param name="message">An optional message to be included in the exception thrown.</param>
            <exception cref="T:Neon.Diagnostics.AssertException">Thrown if <paramref name="condition"/> is <c>false</c>.</exception>
        </member>
        <member name="T:System.IO.IOExtensions">
            <summary>
            Implements I/O related class extensions.
            </summary>
        </member>
        <member name="M:System.IO.IOExtensions.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Writes a byte array to a stream.
            </summary>
            <param name="stream">The stream.</param>
            <param name="bytes">The byte array.</param>
        </member>
        <member name="M:System.IO.IOExtensions.WriteAsync(System.IO.Stream,System.Byte[])">
            <summary>
            Asynchronously writes a byte array to a stream.
            </summary>
            <param name="stream">The stream.</param>
            <param name="bytes">The byte array.</param>
        </member>
        <member name="M:System.IO.IOExtensions.ReadBytes(System.IO.Stream,System.Int32)">
            <summary>
            Reads the byte array from the current position, advancing
            the position past the value read.
            </summary>
            <param name="stream">The stream.</param>
            <param name="cb">The number of bytes to read.</param>
            <returns>
            The byte array.  Note that the array returned may have a length
            less than the size requested if the end of the file has been
            reached.
            </returns>
        </member>
        <member name="M:System.IO.IOExtensions.ReadToEnd(System.IO.Stream)">
            <summary>
            Reads all bytes from the current position to the end of the stream.
            </summary>
            <returns>The byte array.</returns>
        </member>
        <member name="M:System.IO.IOExtensions.ReadToEndAsync(System.IO.Stream)">
            <summary>
            Asynchronously reads all bytes from the current position to the end of the stream.
            </summary>
            <returns>The byte array.</returns>
        </member>
        <member name="M:System.IO.IOExtensions.DeflateTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses deflate to compress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:System.IO.IOExtensions.InflateTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses deflate to decompress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:System.IO.IOExtensions.GzipTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses GZIP to compress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:System.IO.IOExtensions.GunzipTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Uses GZIP to decompress a source to a target stream.
            </summary>
            <param name="source">The source stream.</param>
            <param name="target">The target stream.</param>
        </member>
        <member name="M:System.IO.IOExtensions.Lines(System.IO.TextReader,System.Boolean)">
            <summary>
            Returns an enumerator that returns the lines of text from a <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="reader">The reader.</param>
            <param name="ignoreBlank">Optionally skip empty lines or lines with oly whitespace.</param>
            <returns>The <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="T:System.Net.Http.HttpClientExtensions">
            <summary>
            <see cref="T:System.Net.Http.HttpClient"/> extension methods, mostly related to supporting <see cref="T:Neon.Diagnostics.LogActivity"/> 
            related headers.
            </summary>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET request to the specified string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET request to a specified <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetByteArrayAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET to a specified string URI and returns the response body as a byte array.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response byte array.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetByteArrayAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET to a specified <see cref="T:System.Uri"/> and returns the response body as a byte array.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response byte array.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetStreamAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET to a specified string URI and returns the response body as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response stream.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetStreamAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET to a specified <see cref="T:System.Uri"/> and returns the response body as a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response stream.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetStringAsync(System.Net.Http.HttpClient,System.String,Neon.Collections.ArgDictionary,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET request to a string URI and returns the response as a string.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.GetStringAsync(System.Net.Http.HttpClient,System.Uri,Neon.Collections.ArgDictionary,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a GET request to a <see cref="T:System.Uri"/> and returns the response as a string.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="headers">Optional request headers.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.PostAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a POST request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.PostAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a POST request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.PutAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a PUT request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.PutAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a PUT request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.DeleteAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a DELETE request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.DeleteAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a DELETE request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.PatchAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a PATCH request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.PatchAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a PATCH request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.OptionsAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a OPTIONS request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.OptionsAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a OPTIONS request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.HeadAsync(System.Net.Http.HttpClient,System.String,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a HEAD request to a string URI.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.HeadAsync(System.Net.Http.HttpClient,System.Uri,System.Net.Http.HttpContent,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends a HEAD request to a <see cref="T:System.Uri"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="requestUri">The request URI.</param>
            <param name="content">The content to be sent to the server.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
        </member>
        <member name="M:System.Net.Http.HttpClientExtensions.SendAsync(System.Net.Http.HttpClient,System.Net.Http.HttpRequestMessage,Neon.Collections.ArgDictionary,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken,Neon.Diagnostics.LogActivity)">
            <summary>
            Sends an <see cref="T:System.Net.Http.HttpRequestMessage"/>.
            </summary>
            <param name="client">The client.</param>
            <param name="request">The request.</param>
            <param name="headers">Optional request headers.</param>
            <param name="completionOption">
            Optionally specifies when the operation should complete (as soon as a response is available or after
            reading the whole response content).
            </param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="activity">Optional <see cref="T:Neon.Diagnostics.LogActivity"/> whose ID is to be included in the request.</param>
            <returns>The response.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when a required argument is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when the request has already been sent by the <see cref="T:System.Net.Http.HttpClient"/> class.</exception>
        </member>
        <member name="T:System.AppDomainExtensions">
            <summary>
            Implements <see cref="T:System.AppDomain"/> extension methods.
            </summary>
        </member>
        <member name="M:System.AppDomainExtensions.GetUserAssemblies(System.AppDomain)">
            <summary>
            Enumerates all non <b>System</b> and <b>Microsoft</b> assemblies currently
            loaded in the <see cref="T:System.AppDomain"/>.  This can be used as a performance
            optimization when you only need to scan user assemblies.
            </summary>
            <param name="appDomain"></param>
            <returns>The enumerated assemblies.</returns>
            <remarks>
            We also use this to work around this Visual Studio bug: 
            <a href="https://github.com/nforgeio/neonKUBE/issues/531"/>
            </remarks>
        </member>
        <member name="T:System.EnumExtensions">
            <summary>
            <see cref="T:System.Enum"/> extensions.
            </summary>
        </member>
        <member name="M:System.EnumExtensions.ToMemberString(System.Enum)">
            <summary>
            Converts an enumeration value into a string, using the <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            value if one was specified for the value in the enumeration type definition otherwise
            the default enumeration value name will be returned.
            </summary>
            <param name="value">The enumeration value to be converted.</param>
            <returns>The member or default string value.</returns>
            <remarks>
            This is useful because <see cref="M:System.Enum.ToString"/> ignores any <see cref="T:System.Runtime.Serialization.EnumMemberAttribute"/>
            attributes.
            </remarks>
        </member>
        <member name="T:System.ExceptionExtensions">
            <summary>
            <see cref="T:System.Exception"/> extensions.
            </summary>
        </member>
        <member name="M:System.ExceptionExtensions.Contains``1(System.Exception)">
            <summary>
            Determines whether the exception has a specified type or was triggered by
            an underlying exception of a specified type.  This is useful for checking whether
            an exception has a specific inner exception or whether an <see cref="T:System.AggregateException"/>
            was triggered with a specific exception type.
            </summary>
            <typeparam name="T">The target exception type.</typeparam>
            <param name="e">The exception being tested.</param>
            <returns><c>true</c> if the exception was triggered by an exception of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:System.ExceptionExtensions.Find``1(System.Exception)">
            <summary>
            Searches an exception for an underlying exception of a specific type specified as a generic
            type parameter.   This is useful for  checking whether an exception has a specific inner 
            exception or whether an <see cref="T:System.AggregateException"/> was triggered with a specific 
            exception type.
            </summary>
            <typeparam name="T">The target exception type.</typeparam>
            <param name="e">The exception being tested.</param>
            <returns>The underlying exception or <c>null</c>.</returns>
        </member>
        <member name="M:System.ExceptionExtensions.Find(System.Exception,System.Type)">
            <summary>
            Searches an exception for an underlying exception of a specific type.  This is useful for 
            checking whether an exception has a specific inner exception or whether an <see cref="T:System.AggregateException"/>
            was triggered with a specific exception type.
            </summary>
            <param name="e">The exception being tested.</param>
            <param name="exceptionType">The target exception type.</param>
            <returns>The underlying exception or <c>null</c>.</returns>
        </member>
        <member name="T:System.Collections.Generic.IEnumerableExtensions">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> extension methods.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.SelectRandom``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Selects one or more randomly selected items from an enumeration.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="items">The source items.</param>
            <param name="count">The number of values to be returned (defaults to <b>1</b>.</param>
            <returns>The randomly selected items as an enumeration.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if <paramref name="count"/> is not positive or if <paramref name="items"/> does
            not have at least <paramref name="count"/> items.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.IEnumerableExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether an <see cref="T:System.Collections.IEnumerable"/> is empty.
            </summary>
            <typeparam name="T">The enumeration value type.</typeparam>
            <param name="items">The items to be tested.</param>
            <param name="predicate">Optional item selector.</param>
            <returns><c>true</c> if <paramref name="items"/> is empty.</returns>
        </member>
        <member name="T:System.RandomExtensions">
            <summary>
            <see cref="T:System.Random"/> class extension methods.
            </summary>
        </member>
        <member name="M:System.RandomExtensions.NextIndex(System.Random,System.Int32)">
            <summary>
            Returns a random index into a sequence whose length is specified.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance.</param>
            <param name="length">The sequence length.</param>
            <returns>The random index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if length is &lt;= 0.</exception>
        </member>
        <member name="M:System.RandomExtensions.RandomTimespan(System.Random,System.TimeSpan)">
            <summary>
            Returns a random <see cref="T:System.TimeSpan"/> between zero and a specified maximum.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance.</param>
            <param name="maxInterval">The maximum interval.</param>
            <returns>The random timespan.</returns>
            <remarks>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </remarks>
        </member>
        <member name="M:System.RandomExtensions.RandomTimespan(System.Random,System.TimeSpan,System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> between the specified base interval
            plus a random period of the specified fraction of the value.
            </summary>
            <param name="random">The <see cref="T:System.Random"/> instance.</param>
            <param name="baseInterval">The base interval.</param>
            <param name="fraction">The fractional multiplier for the random component.</param>
            <returns>The random timespan.</returns>
            <remarks>
            <para>
            The value returned is at least as large as <paramref name="baseInterval" /> with an
            added random fractional interval if <paramref name="fraction" /> is positive or the value
            returned may be less than <paramref name="baseInterval" /> for a negative <paramref name="fraction" />.  
            This is computed via:
            </para>
            <code language="cs">
            baseInterval + RandTimespan(TimeSpan.FromSeconds(baseInterval.TotalSeconds * fraction));
            </code>
            <para>
            This method is useful for situations where its desirable to have some variation
            in a delay before performing an activity like retrying an operation or performing
            a background task.
            </para>
            </remarks>
        </member>
        <member name="T:System.Text.StringBuilderExtensions">
            <summary>
            System class extensions.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.AppendLineLinux(System.Text.StringBuilder,System.String)">
            <summary>
            Appends a line of text using a Linux-style (LF) line ending.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="line">The line.</param>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.AppendWithSeparator(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Appends non-<c>null</c> and non-empty text, separating it from any existing text with a string.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="text">The text to be appended.</param>
            <param name="separator">The separator string, this defaults to a single space.</param>
            <remarks>
            <note>
            The separator string will not be appended if <paramref name="text"/> is <c>null</c>
            or empty.
            </note>
            </remarks>
        </member>
        <member name="T:System.StringExtensions">
            <summary>
            String extension methods.
            </summary>
        </member>
        <member name="M:System.StringExtensions.ToLines(System.String)">
            <summary>
            Splits the string into lines of text.
            </summary>
            <param name="value">The string value.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the extracted lines.  Note
            that an empty string will return a single empty line and a <c>null</c>
            string will return no lines.
            </returns>
        </member>
        <member name="T:System.TimeSpanExtensions">
            <summary>
            <see cref="T:System.TimeSpan"/> extensions.
            </summary>
        </member>
        <member name="M:System.TimeSpanExtensions.AdjustToFitDateRange(System.TimeSpan,System.DateTime)">
            <summary>
            Adjusts a <see cref="T:System.TimeSpan"/> such that when it is added to a 
            <see cref="T:System.DateTime"/> the resulting date is within the valid
            possible date range of <see cref="F:System.DateTime.MinValue"/>...<see cref="F:System.DateTime.MaxValue"/>.
            This is useful for timeout related calculations.
            </summary>
            <param name="timespan">The <see cref="T:System.TimeSpan"/>.</param>
            <param name="dateTime">The <see cref="T:System.DateTime"/>.</param>
            <returns>The adjusted <see cref="T:System.TimeSpan"/>.</returns>
        </member>
        <member name="T:System.TypeExtensions">
            <summary>
            Type extension methods.
            </summary>
        </member>
        <member name="M:System.TypeExtensions.Implements``1(System.Type)">
            <summary>
            Determines whether a <see cref="T:System.Type"/> implements a specific interface.
            </summary>
            <typeparam name="TInterface">The required interface type.</typeparam>
            <param name="type">The type beinbg tested.</param>
            <returns><c>true</c> if <paramref name="type"/> implements <paramref name="type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="type"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <typeparamref name="TInterface"/> is not an <c>interface</c>.</exception>
        </member>
        <member name="T:System.WeakEventController">
            <summary>
            Implements a weak event listener that allows the owner to be garbage
            collected if it is the only remaining link is an event handler.
            </summary>
            <remarks>
            <para>
            This class is intended to be a drop-in replacement for the <b>WeakEventManager</b> 
            class that is available in .NET 4.5 but is not currently present in the Xamarin
            Mono class libraries.  Use the <see cref="M:System.WeakEventController.AddHandler``2(``0,System.String,System.EventHandler{``1})"/>
            and <see cref="M:System.WeakEventController.RemoveHandler``2(``0,System.String,System.EventHandler{``1})"/>
            to add or remove event handlers.
            </para>
            <note>
            <b>Important:</b> Take care to remove any handlers when an event listener instance is disposed 
            and/or finalized.  Neglecting to do this will orhpan the objects <see cref="T:System.WeakEventController"/>
            uses to track the handler references.
            </note>
            <para>
            This code was adapted from a Code Project article by <b>Samuel Cragg</b> called 
            <a href="www.codeproject.com/Articles/786606/WeakEventManager-for-WinRT">WeakEventManager for WinRT</a>.
            The code is licensed under the <a href="http://www.codeproject.com/info/cpol10.aspx">The Code Project Open License (CPOL)</a>.
            </para>
            <para>
            I enhanced the code by making it threadsafe.
            </para>
            </remarks>
        </member>
        <member name="F:System.WeakEventController.registeredEventBuckets">
            <summary>
            We're going to assign events to buckets using the hash of their property
            values.  Each bucket will hold a list of the weak events that were dropped
            in the bucket.  This should improve scalability when there are a lot
            of events.
            </summary>
        </member>
        <member name="M:System.WeakEventController.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:System.WeakEventController.HashToBucket(System.Object,System.String,System.Object)">
            <summary>
            Hashes the event properties to an event bucket index.
            </summary>
            <param name="source">The source object or <c>null</c>.</param>
            <param name="eventName">The event name.</param>
            <param name="handler">The event handler.</param>
            <returns>The event bucket index.</returns>
        </member>
        <member name="M:System.WeakEventController.AddHandler``2(``0,System.String,System.EventHandler{``1})">
            <summary>
            Adds the specified event handler to the specified event.
            </summary>
            <typeparam name="TEventSource">The type that raises the event.</typeparam>
            <typeparam name="TEventArgs">The type that holds the event data.</typeparam>
            <param name="source">
            The source object that raises the specified event or <c>null</c>.
            </param>
            <param name="eventName">The name of the event to subscribe to.</param>
            <param name="handler">The delegate that handles the event.</param>
        </member>
        <member name="M:System.WeakEventController.RemoveHandler``2(``0,System.String,System.EventHandler{``1})">
            <summary>
            Removes the specified event handler from the specified event.
            </summary>
            <typeparam name="TEventSource">The type that raises the event.</typeparam>
            <typeparam name="TEventArgs">The type that holds the event data.</typeparam>
            <param name="source">
            The source object that raises the specified event, or null if it's
            a static event.
            </param>
            <param name="eventName">
            The name of the event to remove the handler from.
            </param>
            <param name="handler">The delegate to remove.</param>
        </member>
        <member name="T:YamlDotNet.RepresentationModel.YamlDotNetExtensions">
            <summary>
            YamlDotNet related class extensions.
            </summary>
        </member>
        <member name="M:YamlDotNet.RepresentationModel.YamlDotNetExtensions.Load(YamlDotNet.RepresentationModel.YamlStream,System.String)">
            <summary>
            Initializes a <see cref="T:YamlDotNet.RepresentationModel.YamlStream"/> with text.
            </summary>
            <param name="stream">The YAML stream.</param>
            <param name="text">The text to be loaded.</param>
        </member>
    </members>
</doc>
