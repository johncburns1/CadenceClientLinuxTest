<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neon.Xunit</name>
    </assembly>
    <members>
        <member name="T:Neon.Xunit.AnsiblePlayer">
            <summary>
            Used for running Ansible playbooks within unit tests.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.PlayInFolder(System.String,System.String,System.String[])">
            <summary>
            <para>
            Plays a playbook within a specific working directory using <b>neon ansible play -- [args] playbook</b>.
            </para>
            <note>
            This method will have Ansible gather facts by default which can be quite slow.
            Consider using <see cref="M:Neon.Xunit.AnsiblePlayer.PlayInFolderNoGather(System.String,System.String,System.String[])"/> instead
            for unit tests that don't required the facts.
            </note>
            </summary>
            <param name="workDir">The playbook working directory (or <c>null</c> to use a temporary folder).</param>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.Play(System.String,System.String[])">
            <summary>
            <para>
            Plays a playbook within a temporary directory using <b>neon ansible play -- [args] playbook</b>.
            </para>
            <note>
            This method will have Ansible gather facts by default which can be quite slow.
            Consider using <see cref="M:Neon.Xunit.AnsiblePlayer.PlayNoGather(System.String,System.String[])"/> instead
            for unit tests that don't required the facts.
            </note>
            </summary>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.PlayInFolderNoGather(System.String,System.String,System.String[])">
            <summary>
            Plays a playbook without gathering facts by default within a specific working directory using 
            <b>neon ansible play -- [args] playbook</b>.
            </summary>
            <param name="workDir">The playbook working directory (or <c>null</c> to use a temporary folder).</param>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            <para>
            This method will add <b>gather_facts: no</b> to the playbook when
            this argument isn't already present.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.PlayNoGather(System.String,System.String[])">
            <summary>
            Plays a playbook without gathering facts by default within a temporary directory using 
            <b>neon ansible play -- [args] playbook</b>.
            </summary>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            <para>
            This method will add <b>gather_facts: no</b> to the playbook when
            this argument isnt already present.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.AnsiblePlayResults">
            <summary>
            Holds the results from an <see cref="T:Neon.Xunit.AnsiblePlayer"/> play operation.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayResults.#ctor(Neon.Common.ExecuteResponse)">
            <summary>
            Constructs an instance from the execution results of an
            <see cref="T:Neon.Xunit.AnsiblePlayer"/> play operation.
            </summary>
            <param name="rawResults">The execution results.</param>
        </member>
        <member name="P:Neon.Xunit.AnsiblePlayResults.RawResults">
            <summary>
            Returns the raw execution results.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsiblePlayResults.TaskResults">
            <summary>
            Returns the list of <see cref="T:Neon.Xunit.AnsibleTaskResult"/> instance in the order
            of execution.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayResults.GetTaskResult(System.String)">
            <summary>
            Returns the first <see cref="T:Neon.Xunit.AnsibleTaskResult"/> for a named task.
            </summary>
            <param name="taskName">The task name.</param>
            <returns>The <see cref="T:Neon.Xunit.AnsibleTaskResult"/> or <c>null</c> if the named task was not found.</returns>
            <remarks>
            <note>
            Ansible does not enforce task name uniqueness, so it's possible
            to have more than one task sharing the same name.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.AnsibleTaskResult">
            <summary>
            Holds the results for a specific task executed in an Ansible playbook.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsibleTaskResult.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="rawTaskResults">The raw Ansible task results.</param>
            <remarks>
            <para>
            We're expecting <paramref name="rawTaskResults"/> to include the lines
            starting with:
            </para>
            <code>
            TASK [name] ******
            </code>
            <para>
            and then continuing up to the next task start line or the play recap line:
            </para>
            <code>
            PLAY RECAP ******
            </code>
            </remarks>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.RawResults">
            <summary>
            Returns the raw task results.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.HasStatus">
            <summary>
            Returns <c>true</c> for tasks that returned JSON status.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.TaskName">
            <summary>
            Returns the task name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.Success">
            <summary>
            Returns <c>true</c> if the task succeeded.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.Changed">
            <summary>
            Returns <c>true</c> if the task made any changes.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.OutputText">
            <summary>
            Returns the standard output text from the task.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.ErrorText">
            <summary>
            Returns the standard error text from the task.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.Message">
            <summary>
            Returns the error message (if any).
            </summary>
        </member>
        <member name="T:Neon.Xunit.CollectionComparer`1">
            <summary>
            Compares two collections for strict equality by ensuring they
            have the same items in the same order.
            </summary>
            <typeparam name="T">The collection item type.</typeparam>
        </member>
        <member name="M:Neon.Xunit.CollectionComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns true if two collections are identical.
            </summary>
            <param name="collection1">Collection #1.</param>
            <param name="collection2">Collection #2</param>
            <returns><c>true</c> if the collections are identical.</returns>
        </member>
        <member name="M:Neon.Xunit.CollectionComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Not implemented.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Neon.Xunit.AspNetFixture">
            <summary>
            Fixture for testing ASP.NET Core based websites and services.
            </summary>
        </member>
        <member name="T:Neon.Xunit.AspNetFixture.LoggingProvider">
            <summary>
            Handles site logging if enabled below.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.JsonClient">
            <summary>
            Returns a <see cref="P:Neon.Xunit.AspNetFixture.JsonClient"/> suitable for querying the service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.HttpClient">
            <summary>
            Returns an <see cref="P:Neon.Xunit.AspNetFixture.HttpClient"/> suitable for querying the service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.BaseAddress">
            <summary>
            Returns the base URI for the running service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.WebHost">
            <summary>
            Returns the service's <see cref="T:Microsoft.AspNetCore.Hosting.IWebHost"/>.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Start``1(System.Action{Microsoft.AspNetCore.Hosting.IWebHostBuilder},System.Int32,Neon.Xunit.TestOutputWriter,Neon.Diagnostics.LogLevel)">
             <summary>
             <para>
             Starts the ASP.NET service using the default controller factory.
             </para>
             <note>
             You'll need to call <see cref="M:Neon.Xunit.AspNetFixture.StartAsComposed``1(System.Action{Microsoft.AspNetCore.Hosting.IWebHostBuilder},System.Int32,Neon.Xunit.TestOutputWriter,Neon.Diagnostics.LogLevel)"/>
             instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
             </note>
             </summary>
             <typeparam name="TStartup">The startup class for the service.</typeparam>
             <param name="hostConfigurator">Optional action providing for customization of the hosting environment.</param>
             <param name="port">The port where the server will listen or zero to allow the operating system to select a free port.</param>
             <param name="logWriter">Optionally specifies a test output writer.</param>
             <param name="logLevel">Optionally specifies the log level.  This defaults to <see cref="F:Neon.Diagnostics.LogLevel.None"/>.</param>
             <remarks>
             <para>
             You can capture ASP.NET and service logs into your unit test logs by passing <paramref name="logWriter"/> as 
             non-null and <paramref name="logLevel"/> as something other than <see cref="F:Neon.Diagnostics.LogLevel.None"/>.  You'll need
             to obtain a <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> instance from Xunit via dependency injection by adding a parameter
             to your test constructor and then creating a <see cref="T:Neon.Xunit.TestOutputWriter"/> from it, like:
             </para>
             <code language="c#">
             public class MyTest : IClassFixture&lt;AspNetFixture&gt;
             {
                 private AspNetFixture               fixture;
                 private TestAspNetFixtureClient     client;
                 private TestOutputWriter            testWriter;
            
                 public Test_EndToEnd(AspNetFixture fixture, ITestOutputHelper outputHelper)
                 {
                     this.fixture    = fixture;
                     this.testWriter = new TestOutputWriter(outputHelper);
            
                     fixture.Start&lt;Startup&gt;(logWriter: testWriter, logLevel: Neon.Diagnostics.LogLevel.Debug);
            
                     client = new TestAspNetFixtureClient()
                     {
                         BaseAddress = fixture.BaseAddress
                     };
                  }
             }
             </code>
             </remarks>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.StartAsComposed``1(System.Action{Microsoft.AspNetCore.Hosting.IWebHostBuilder},System.Int32,Neon.Xunit.TestOutputWriter,Neon.Diagnostics.LogLevel)">
             <summary>
             Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
             </summary>
             <typeparam name="TStartup">The startup class for the service.</typeparam>
             <param name="hostConfigurator">Optional action providing for customization of the hosting environment.</param>
             <param name="port">The port where the server will listen or zero to allow the operating system to select a free port.</param>
             <param name="logWriter">Optionally specifies a test output writer.</param>
             <param name="logLevel">Optionally specifies the log level.  This defaults to <see cref="F:Neon.Diagnostics.LogLevel.None"/>.</param>
             <remarks>
             <para>
             You can capture ASP.NET and service logs into your unit test logs by passing <paramref name="logWriter"/> as 
             non-null and <paramref name="logLevel"/> as something other than <see cref="F:Neon.Diagnostics.LogLevel.None"/>.  You'll need
             to obtain a <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> instance from Xunit via dependency injection by adding a parameter
             to your test constructor and then creating a <see cref="T:Neon.Xunit.TestOutputWriter"/> from it, like:
             </para>
             <code language="c#">
             public class MyTest : IClassFixture&lt;AspNetFixture&gt;
             {
                 private AspNetFixture               fixture;
                 private TestAspNetFixtureClient     client;
                 private TestOutputWriter            testWriter;
            
                 public Test_EndToEnd(AspNetFixture fixture, ITestOutputHelper outputHelper)
                 {
                     this.fixture    = fixture;
                     this.testWriter = new TestOutputWriter(outputHelper);
            
                     fixture.Start&lt;Startup&gt;(logWriter: testWriter, logLevel: Neon.Diagnostics.LogLevel.Debug);
            
                     client = new TestAspNetFixtureClient()
                     {
                         BaseAddress = fixture.BaseAddress
                     };
                  }
             }
             </code>
             </remarks>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.StartServer``1(System.Int32)">
            <summary>
            Starts the service using the default controller factory.
            </summary>
            <param name="port">The port where the server will listen.</param>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Restart``1">
            <summary>
            Restarts the web service.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Xunit.ComposedFixture">
            <summary>
            Implements an <see cref="T:Neon.Xunit.ITestFixture"/> that is composed of other test
            fixtures.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Couchbase Docker container, modifying the local DNS <b>hosts</b>
            file or managing a Docker Swarm or cluster.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file with:
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            </para>
            </note>
            <para>
            Derived test fixtures that modify global machine or other environmental state
            must implement a <c>public static void EnsureReset()</c> method resets the state
            to a reasonable default.  These will be reflected and called when the first
            <see cref="T:Neon.Xunit.TestFixture"/> is created by the test runner for every test class.
            </para>
            </remarks>
            <threadsafety instance="false"/>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.AddFixture``1(System.String,``0,System.Action{``0})">
            <summary>
            Adds a named <see cref="T:Neon.Xunit.ITestFixture"/>.
            </summary>
            <param name="name">The fixture name (case insenstitive).</param>
            <param name="subFixture">The subfixture instance.</param>
            <param name="action">The optional <see cref="T:System.Action"/> to be called when the fixture is initialized.</param>
            <remarks>
            <note>
            This method doesn't work for <see cref="T:Neon.Xunit.KubeServiceFixture`1"/> based fixtures.  Use
            <see cref="M:Neon.Xunit.ComposedFixture.AddServiceFixture``1(System.String,Neon.Xunit.KubeServiceFixture{``0},System.Func{``0})"/> instead.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.AddServiceFixture``1(System.String,Neon.Xunit.KubeServiceFixture{``0},System.Func{``0})">
            <summary>
            Adds a named <see cref="T:Neon.Xunit.KubeServiceFixture`1"/> fixture.
            </summary>
            <typeparam name="TService">The service type (derived from <see cref="T:Neon.Kube.Service.KubeService"/>.</typeparam>
            <param name="name">The fixture name (case insenstitive).</param>
            <param name="subFixture">The subfixture being added.</param>
            <param name="serviceCreator">Callback that creates and returns the new service instance.</param>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Start(System.Action)">
            <summary>
            Starts the fixture if it hasn't already been started including invoking the optional
            <see cref="T:System.Action"/> when the first time <see cref="M:Neon.Xunit.ComposedFixture.Start(System.Action)"/> is called for
            a fixture instance.
            </summary>
            <param name="action">
            <para>
            The optional custom start action.
            </para>
            <note>
            This is generally intended for use when developing custom test fixtures.
            </note>
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this is called from within the <see cref="T:System.Action"/>.</exception>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Children">
            <summary>
            Returns the subfixtures.
            </summary>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Item(System.String)">
            <summary>
            Returns the named test fixture.
            </summary>
            <param name="name">The fixture name (case insensitive).</param>
            <returns>The test fixture.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the named fixture does not exist.</exception>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Item(System.Int32)">
            <summary>
            Returns the fixture at the specified index (based on the order
            the fixture was added.
            </summary>
            <param name="index"></param>
            <returns>The test fixture.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="index"/> is outside the range of valid indexes.</exception>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Count">
            <summary>
            Returns the number of fixtures in the set.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Dispose(System.Boolean)">
            <summary>
            Disposes all fixtures in the set.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.GetEnumerator">
            <summary>
            Enumerates the named test fixtures in the set.
            </summary>
            <returns>The fixtures as <c>KeyValuePair&lt;string, ITestFixture&gt;</c> instances.</returns>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates the named test fixtures in the set.
            </summary>
            <returns>The fixtures as <c>KeyValuePair&lt;string, ITestFixture&gt;</c> instances.</returns>
        </member>
        <member name="T:Neon.Xunit.ContainerFixture">
            <summary>
            Used to run a Docker container on the current machine as a test 
            fixture while tests are being performed and then deletes the
            container when the fixture is disposed.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Couchbase Docker container, modifying the local DNS <b>hosts</b>
            file or managing a Docker Swarm or cluster.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerFixture.ContainerName">
            <summary>
            Returns the running container's name <c>null</c> if the container
            has not been started.
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerFixture.ContainerId">
            <summary>
            Returns the running container's short ID or <c>null</c> if the container
            has not been started.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Start(System.String,System.String,System.String[],System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
            <para>
            Starts the container.
            </para>
            <note>
            You'll need to call <see cref="M:Neon.Xunit.ContainerFixture.StartAsComposed(System.String,System.String,System.String[],System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)"/>
            instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            </summary>
            <param name="name">Specifies the container name.</param>
            <param name="image">Specifies the container Docker image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker run ...</b> command.</param>
            <param name="containerArgs">Optional arguments to be passed to the container.</param>
            <param name="env">Optional environment variables to be passed to the Couchbase container, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <param name="noRemove">Optionally indicates that the <b>--rm</b> option should not be included when creating the container.</param>
            <param name="keepOpen">
            Optionally indicates that the container should continue to run after the fixture is disposed.  
            This implies <see cref="F:Neon.Xunit.ContainerFixture.noRemove"/><c>=true</c> and defaults to <c>true</c>.
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is not called from  within the <see cref="T:System.Action"/> method 
            passed <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            </exception>
            <remarks>
            <note>
            You must specify a valid container <paramref name="name"/>so that the fixure
            can remove any existing container with the same name before starting the new container.
            This is very useful during test debugging when the test might be interrupted during 
            debugging before ensuring that the container is stopped.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.StartAsComposed(System.String,System.String,System.String[],System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="name">Specifies the container name.</param>
            <param name="image">Specifies the container Docker image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker run ...</b> command.</param>
            <param name="containerArgs">Optional arguments to be passed to the container.</param>
            <param name="env">Optional environment variables to be passed to the Couchbase container, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <param name="noRemove">Optionally indicates that the <b>--rm</b> option should not be included when creating the container.</param>
            <param name="keepOpen">
            Optionally indicates that the container should continue to run after the fixture is disposed.  
            This implies <see cref="F:Neon.Xunit.ContainerFixture.noRemove"/><c>=true</c> and defaults to <c>true</c>.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is not called from  within the <see cref="T:System.Action"/> method 
            passed <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            </exception>
            <remarks>
            <note>
            You must specify a valid container <paramref name="name"/>so that the fixure
            can remove any existing container with the same name before starting the new container.
            This is very useful during test debugging when the test might be interrupted during 
            debugging before ensuring that the container is stopped.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.StartContainer">
            <summary>
            Starts the container using the instance fields.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Restart">
            <summary>
            Restarts the container.  This is a handy way to deploy a fresh container with the
            same properties while running unit tests.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture">
            <summary>
            An Xunit test fixture used to manage a local Docker daemon within unit tests.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Couchbase Docker container, modifying the local DNS <b>hosts</b>
            file or managing a Docker Swarm or cluster.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            </note>
            <para>
            This fixture resets the state of the local Docker daemon before and after
            the test runner executes the tests in a test class by removing all containers
            and services as well as swarm items such as secrets, configs and networks.
            </para>
            <note>
            This fixture works only for local Docker instances that <b>ARE NOT</b>
            members of a multi-node cluster as a safety measure to help avoid the
            possiblity of accidentially wiping out a production cluster.
            </note>
            <note>
            The fixture <see cref="M:Neon.Xunit.DockerFixture.Reset"/> method does not purge images from the target
            test node for performance reasons.  This can be a problem if you're testing
            container and you need to ensure that the latest image is downloaded from
            the registry first.  You can call <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/> to accomplish
            this or <see cref="M:Neon.Xunit.DockerFixture.PullImage(System.String)"/> to pull a specific image from the registry.
            </note>
            <para>
            This fixture is pretty easy to use.  Simply have your test class inherit
            from <see cref="T:Xunit.IClassFixture`1"/> and add a public constructor
            that accepts a <see cref="T:Neon.Xunit.DockerFixture"/> as the only argument.  Then
            you can call it's <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/> method
            within the constructor and optionally have your custom <see cref="T:System.Action"/>
            use the fixture to initialize swarm services, networks, secrets, etc.
            </para>
            <para>
            This fixture provides several methods for managing the cluster state.
            These may be called within the test class constructor's action method,
            within the test constructor but outside of tha action, or within
            the test methods:
            </para>
            <list type="table">
            <item>
                <term><b>Local Machine DNS</b></term>
                <description>
                <see cref="P:Neon.Xunit.DockerFixture.LocalMachineHosts"/>
                </description>
            </item>
            <item>
                <term><b>Docker</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.DockerExecute(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.DockerExecute(System.Object[])"/>
                </description>
            </item>
            <item>
                <term><b>Configs</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearConfigs(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.Byte[],System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.String,System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListConfigs(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveConfig(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Containers</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearContainers(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListContainers(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveContainer(System.String)"/>
                <see cref="M:Neon.Xunit.DockerFixture.RunContainer(System.String,System.String,System.String[],System.String[],System.String[])"/><br/>
                </description>
            </item>
            <item>
                <term><b>Images</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.PullImage(System.String)"/><br/>
                </description>
            </item>
            <item>
                <term><b>Networks</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearNetworks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateNetwork(System.String,System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListNetworks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveNetwork(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Secrets</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearSecrets(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.Byte[],System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.String,System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListSecrets(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveSecret(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Services</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearServices(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateService(System.String,System.String,System.String[],System.String[],System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListServices(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.InspectService(System.String,System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveService(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RestartService(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RollbackService(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.UpdateService(System.String,System.String[])"/>
                </description>
            </item>
            <item>
                <term><b>Stacks</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearStacks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.DeployStack(System.String,System.String,System.String[],System.TimeSpan,System.TimeSpan)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListStacks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveStack(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Volumes</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearVolumes(System.Boolean)"/>
                </description>
            </item>
            </list>
            <note>
            <see cref="T:Neon.Xunit.DockerFixture"/> derives from <see cref="T:Neon.Xunit.ComposedFixture"/> so you can
            use <see cref="M:Neon.Xunit.ComposedFixture.AddFixture``1(System.String,``0,System.Action{``0})"/>
            to add additional fixtures within your custom initialization action for advanced scenarios.
            </note>
            <para>
            There are two basic patterns for using this fixture.
            </para>
            <list type="table">
            <item>
                <term><b>initialize once</b></term>
                <description>
                <para>
                The basic idea here is to have your test class initialize the swarm
                once within the test class constructor inside of the initialize action
                with common state and services that all of the tests can access.
                </para>
                <para>
                This will be quite a bit faster than reconfiguring the swarm at the
                beginning of every test and can work well for many situations but it
                assumes that your test methods guarantee that running any test in 
                any order will not impact the results of subsequent tests.  A good 
                example of this is a series of read-only tests against a service
                or database.
                </para>
                </description>
            </item>
            <item>
                <term><b>initialize every test</b></term>
                <description>
                For common scenarios where the swarm must be reset before every test,
                you can call <see cref="M:Neon.Xunit.DockerFixture.Reset"/> within the test class constructor
                (but outside of the custom initialization <see cref="T:System.Action"/> to
                reset the swarm state before the next test method is invoked.
                </description>
            </item>
            </list>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.SecretInfo">
            <summary>
            Holds information about a Docker secret.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.SecretInfo.ID">
            <summary>
            Returns the secret ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.SecretInfo.Name">
            <summary>
            Returns the secret name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.NetworkInfo">
            <summary>
            Holds information about a Docker network.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.NetworkInfo.ID">
            <summary>
            Returns the network ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.NetworkInfo.Name">
            <summary>
            Returns the network name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.ConfigInfo">
            <summary>
            Holds information about a Docker config.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ConfigInfo.ID">
            <summary>
            Returns the config ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ConfigInfo.Name">
            <summary>
            Returns the config name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.ServiceInfo">
            <summary>
            Holds information about a Docker service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.ID">
            <summary>
            Returns the service ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.Name">
            <summary>
            Returns the service name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.ReplicasDesired">
            <summary>
            Returns the number of replicas desired.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.ReplicasDeployed">
            <summary>
            Returns the number of replicas actually deployed.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.StackInfo">
            <summary>
            Holds information about a Docker stack.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackInfo.Name">
            <summary>
            Returns the stack name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackInfo.ServiceCount">
            <summary>
            Returns the number of services deployed by the stack.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.ContainerInfo">
            <summary>
            Holds information about a Docker container.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ContainerInfo.ID">
            <summary>
            Returns the container ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ContainerInfo.Name">
            <summary>
            Returns the container name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.StackService">
            <summary>
            Describes a Docker stack service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackService.Name">
            <summary>
            The service name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackService.Replicas">
            <summary>
            The number of service replicas.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.StackDefinition">
            <summary>
            Parses useful information from a Docker YAML compose file.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.StackDefinition.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The stack name.</param>
            <param name="composeYaml">The stack compose YAML definition.</param>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackDefinition.Name">
            <summary>
            Returns the stack name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackDefinition.Services">
            <summary>
            Returns information about the stack's services.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.StackDefinition.GetServiceName(Neon.Xunit.DockerFixture.StackService)">
            <summary>
            Returns the service name Docker will assign to a stack service.
            </summary>
            <param name="service"></param>
            <returns>The service name.</returns>
        </member>
        <member name="F:Neon.Xunit.DockerFixture.RefCount">
            <summary>
            Used to track how many fixture instances for the current test run
            remain so we can determine when reset the Docker Swarm.
            </summary>
        </member>
        <member name="F:Neon.Xunit.DockerFixture.DockerNetworks">
            <summary>
            Identifies the built-in Docker networks.  These networks will not
            be returned by <see cref="M:Neon.Xunit.DockerFixture.ListNetworks(System.Boolean)"/> and cannot be deleted.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.EnsureReset">
            <summary>
            Called by <see cref="T:Neon.Xunit.TestFixture"/> to ensure that Docker is
            reset after an interrupted test run.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.#ctor(Neon.Common.Stub.Value)">
            <summary>
            Special private constructor that doesn't do reference counting
            or automatically reset the fixture state.
            </summary>
            <param name="param">Not used.</param>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.#ctor(System.Boolean)">
            <summary>
            Used for derived classes that need to disable the <see cref="M:Neon.Xunit.DockerFixture.Reset"/>
            call on construction
            </summary>
            <param name="reset">Optionally calls <see cref="M:Neon.Xunit.DockerFixture.Reset"/> when the reference count is zero.</param>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.LocalMachineHosts">
            <summary>
            Returns an integrated <see cref="T:Neon.Xunit.HostsFixture"/> that can be used to manage
            DNS entries in the local machine's DNS <b>hosts</b> file.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ClearDelay">
            <summary>
            Some Docker clear operations appear to take a few moments to complete.
            This delay will be added afterwards in an attempt to address this.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.DockerExecute(System.Object[])">
            <summary>
            Executes an arbitrary <b>docker</b> CLI command passing unformatted
            arguments and returns the results.
            </summary>
            <param name="args">The <b>docker</b> command arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/>.</returns>
            <remarks>
            <para>
            This method formats any arguments passed so they will be suitable 
            for passing on the command line by quoting and escaping them
            as necessary.
            </para>
            <note>
            This method is defined as <c>virtual</c> so that derived classes
            can modify how Docker is called.  For example, the <c>HiveFixture</c>
            class implemented in another assembly will override this to run
            the <b>docker</b> within a cluster using <b>neon-cli</b>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.DockerExecute(System.String)">
            <summary>
            Executes an arbitrary <b>docker</b> CLI command passing a pre-formatted
            argument string and returns the results.
            </summary>
            <param name="argString">The <b>docker</b> command arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/>.</returns>
            <remarks>
            <para>
            This method assumes that the single string argument passed is already
            formatted as required to pass on the command line.
            </para>
            <note>
            This method is defined as <c>virtual</c> so that derived classes
            can modify how Docker is called.  For example, the <c>HiveFixture</c>
            class implemented in another assembly will override this to run
            the <b>docker</b> within a cluster using <b>neon-cli</b>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.Reset">
            <summary>
            Resets the local Docker daemon by clearing all swarm services and state
            as well as removing all containers.
            </summary>
            <remarks>
            <note>
            This method does not reset the Docker images on the test node for
            performance reasons.  You can call <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/> from
            your tests if required.
            </note>
            <note>
            As a safety measure, this method ensures that the local Docker instance
            <b>IS NOT</b> a member of a multi-node swarm to avoid wiping out production
            clusters by accident.
            </note>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the local Docker instance is a member of a multi-node swarm.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearImages">
            <summary>
            Removes all unreferenced images from the target test node.  <see cref="M:Neon.Xunit.DockerFixture.Reset"/>
            does not do this for performance reasonse but tests may use this method
            if necessary.
            </summary>
            <remarks>
            <note>
            <para>
            Using this may result in very slow test performance, especially since
            it will purge a local copy of <b>neon-cli</b> if present.  This means
            this and any other test images (like Couchbase) will need to be
            downloaded again after every reset.
            </para>
            <para>
            We highly recommend that you use <see cref="M:Neon.Xunit.DockerFixture.PullImage(System.String)"/> to
            ensure that the desired images are up-to-date rather than using
            <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/>.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.PullImage(System.String)">
            <summary>
            Pulls a specific image to the target test node.
            </summary>
            <param name="image">The image name.</param>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateService(System.String,System.String,System.String[],System.String[],System.String[])">
            <summary>
            Creates a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <param name="image">Specifies the service image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker service create ...</b> command.</param>
            <param name="serviceArgs">Optional arguments to be passed to the service.</param>
            <param name="env">Optional environment variables to be passed to the service, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListServices(System.Boolean)">
            <summary>
            Returns information about the current swarm services.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster services whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.ServiceInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.InspectService(System.String,System.Boolean)">
            <summary>
            Inspects a service, returning details about its current state.
            </summary>
            <param name="name">The service name.</param>
            <param name="strict">Optionally specify strict JSON parsing.</param>
            <returns>The <see cref="T:Neon.Docker.ServiceDetails"/>.</returns>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveService(System.String)">
            <summary>
            Removes a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RestartService(System.String)">
            <summary>
            Restarts a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RollbackService(System.String)">
            <summary>
            Rolls back a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.UpdateService(System.String,System.String[])">
            <summary>
            Updates a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <param name="dockerArgs">Arguments to be passed to the <b>docker service update ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearServices(System.Boolean)">
            <summary>
            Removes all deployed services.
            </summary>
            <param name="removeSystem">Optionally remove core cluster services as well.</param>
            <remarks>
            By default, this method will not remove core cluster services
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RunContainer(System.String,System.String,System.String[],System.String[],System.String[])">
            <summary>
            Creates a Docker container.
            </summary>
            <param name="name">The container name.</param>
            <param name="image">Specifies the container image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker service create ...</b> command.</param>
            <param name="containerArgs">Optional arguments to be passed to the service.</param>
            <param name="env">Optional environment variables to be passed to the container, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListContainers(System.Boolean)">
            <summary>
            Returns information about the current Docker containers.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster containers whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.ContainerInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveContainer(System.String)">
            <summary>
            Removes a Docker container.
            </summary>
            <param name="name">The container name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearContainers(System.Boolean)">
            <summary>
            Removes all running containers.
            </summary>
            <param name="removeSystem">Optionally remove core cluster containers as well.</param>
            <remarks>
            By default, this method will not remove core cluster containers
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.DeployStack(System.String,System.String,System.String[],System.TimeSpan,System.TimeSpan)">
            <summary>
            Deploys a Docker stack.
            </summary>
            <param name="name">The stack name.</param>
            <param name="composeYaml">The compose-file YAML text.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker secret create ...</b> command.</param>
            <param name="timeout">Optionally specifies the maximum time to wait for service tasks to start (defaults to <b>5 minutes</b>).</param>
            <param name="convergeTime">
            Optionally specifies the time to wait after the service tasks 
            have been started for the tasks to initialize.  This defaults 
            to <b>5 seconds</b> which is the same time that Docker waits
            for Swarm services to converge.
            </param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <exception cref="T:System.TimeoutException">Thrown if the stack tasks were not deployed after waiting <paramref name="timeout"/>.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListStacks(System.Boolean)">
            <summary>
            Returns information about the current swarm stacks.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster stacks whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.StackInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveStack(System.String)">
            <summary>
            Removes a Docker stack.
            </summary>
            <param name="name">The stack name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearStacks(System.Boolean)">
            <summary>
            Removes all deployed stacks.
            </summary>
            <param name="removeSystem">Optionally remove core cluster stacks as well.</param>
            <remarks>
            By default, this method will not remove core cluster stacks
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.String,System.String[])">
            <summary>
            Creates a Docker secret from text.
            </summary>
            <param name="name">The secret name.</param>
            <param name="secretText">The secret text.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker secret create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.Byte[],System.String[])">
            <summary>
            Creates a Docker secret from bytes.
            </summary>
            <param name="name">The secret name.</param>
            <param name="secretBytes">The secret bytes.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker secret create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListSecrets(System.Boolean)">
            <summary>
            Returns information about the current swarm secrets.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster secrets whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.SecretInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveSecret(System.String)">
            <summary>
            Removes a Docker secret.
            </summary>
            <param name="name">The secret name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearSecrets(System.Boolean)">
            <summary>
            Removes all swarm secrets.
            </summary>
            <param name="removeSystem">Optionally remove core cluster secrets as well.</param>
            <remarks>
            By default, this method will not remove cluster cluster secrets
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.String,System.String[])">
            <summary>
            Creates a Docker config from text.
            </summary>
            <param name="name">The secret name.</param>
            <param name="configText">The secret text.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker config create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.Byte[],System.String[])">
            <summary>
            Creates a Docker config from bytes.
            </summary>
            <param name="name">The secret name.</param>
            <param name="configBytes">The secret bytes.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker config create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListConfigs(System.Boolean)">
            <summary>
            Returns information about the current swarm configs.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster configs whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.ConfigInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveConfig(System.String)">
            <summary>
            Removes a Docker config.
            </summary>
            <param name="name">The config name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearConfigs(System.Boolean)">
            <summary>
            Removes all swarm configs.
            </summary>
            <param name="removeSystem">Optionally remove core cluster configs as well.</param>
            <remarks>
            By default, this method will not remove core cluster configs
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateNetwork(System.String,System.String[])">
            <summary>
            Creates a Docker network.
            </summary>
            <param name="name">The network name.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker network create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListNetworks(System.Boolean)">
            <summary>
            Returns information about the current swarm networks.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster networks whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.NetworkInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <remarks>
            <note>
            This method <b>DOES NOT</b> include built-in Docker networks such as
            <b>bridge</b>, <b>docker_gwbridge</b>, <b>host</b>, <b>ingress</b>,
            or <b>none</b> in the listed networks.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveNetwork(System.String)">
            <summary>
            Removes a Docker network.
            </summary>
            <param name="name">The network name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown for built-in Docker networks.</exception>
            <remarks>
            <note>
            This method <b>DOES NOT</b> allow the removal of built-in Docker networks 
            such as <b>bridge</b>, <b>docker_gwbridge</b>, <b>host</b>, <b>ingress</b>,
            or <b>none</b> in the listed networks.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearNetworks(System.Boolean)">
            <summary>
            Removes all swarm networks.
            </summary>
            <param name="removeSystem">Optionally remove core cluster networks as well.</param>
            <remarks>
            By default, this method will not remove core cluster networks
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearVolumes(System.Boolean)">
            <summary>
            Removes all swarm volumes.
            </summary>
            <param name="removeSystem">Optionally remove core cluster volumes as well.</param>
            <remarks>
            By default, this method will not remove core cluster volumes
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="T:Neon.Xunit.EnvironmentFixture">
            <summary>
            Used to manage environment variables and files for unit tests.
            </summary>
            <remarks>
            <para>
            You may instantiate a single <see cref="T:Neon.Xunit.EnvironmentFixture"/> within your unit
            tests to manage environment variables and test files and folders such as simulated 
            service config and secret files.
            </para>
            <note>
            <para>
            <b>IMPORTANT:</b> The Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Couchbase Docker container, modifying the local DNS <b>hosts</b>
            file or managing a Docker Swarm or cluster.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Reset">
            <imheritdoc/>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Restore">
            <summary>
            Restores the original environment variables captured at the time the
            fixture was instantiated and also removes any temporary test files.
            </summary>
        </member>
        <member name="T:Neon.Xunit.HostsFixture">
            <summary>
            Used to manage the local DNS resolver<b>hosts</b> file on the current computer.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Couchbase Docker container, modifying the local DNS <b>hosts</b>
            file or managing a Docker Swarm or cluster.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="F:Neon.Xunit.HostsFixture.HostsPath">
            <summary>
            Path to the local DNS resolver's [hosts] file.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.EnsureReset">
            <summary>
            Called by <see cref="T:Neon.Xunit.TestFixture"/> to ensure that the hosts file
            contains no DNS records remaining after an interrupted test run.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.RemoveSection(System.String)">
            <summary>
            Removes a specific fixture section from the <b>hosts</b> file or all
            fixture sections if <paramref name="fixtureId"/> is <c>null</c>.
            </summary>
            <param name="fixtureId">
            Identifies the fixture section to be removed or <c>null</c> to 
            remove all fixture sections.
            </param>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.GetSectionHostname(System.String)">
            <summary>
            Returns the hostname for a section GUID.
            </summary>
            <param name="guid">The section GUID string.</param>
            <returns>The section hostname.</returns>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.GetHostAddressesAsync(System.String)">
            <summary>
            Performs a DNS lookup.
            </summary>
            <param name="hostname">The target hostname.</param>
            <returns>The array of IP addresses resolved or an empty array if the hostname lookup failed.</returns>
        </member>
        <member name="F:Neon.Xunit.HostsFixture.fixtureId">
            <summary>
            The GUID used to mark this fixture instance's entries in the hosts file.
            </summary>
        </member>
        <member name="F:Neon.Xunit.HostsFixture.records">
            <summary>
            The DNS records.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.AddHostAddress(System.String,System.String,System.Boolean)">
            <summary>
            Adds an IP address to the local DNS resolver's hosts file.
            </summary>
            <param name="hostname">The hostname.</param>
            <param name="address">The IP address.</param>
            <param name="deferCommit">
            Optionally indicates that the change will not be committed to the hosts
            until <see cref="M:Neon.Xunit.HostsFixture.Commit"/> is called.  This defaults to <c>falsae</c>.
            </param>
            <remarks>
            <note>
            This method will not add the duplicate hostname/address mappings
            to the fixture.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Commit">
            <summary>
            Commits the DNS records to the hosts file.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Reset">
            <imheritdoc/>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="T:Neon.Xunit.ITestFixture">
            <summary>
            <para>
            <b>INTERNAL USE ONLY:</b> Defines the behavior of a Neon Xunit test fixture.
            </para>
            <note>
            All test fixture implementations must inherit from <see cref="T:Neon.Xunit.TestFixture"/> to
            work properly.  Do not attempt to create a fixture from scratch that implements
            this interface.
            </note>
            </summary>
            <remarks>
            <para>
            Xunit test fixtures are designed to provide initialize global state 
            that tests can then reference during their execution.  Typical 
            scenarios include:
            </para>
            <list type="bullet">
            <item>
            Starting a database server and prepopulating it with a schema
            and data to test database access code.
            </item>
            <item>
            Starting a Docker service such that REST endpoints can be tested.
            </item>
            <item>
            Initializing a cluster and then configuring it with certificates,
            routes, services etc. and then performing tests against the
            actual swarm.
            </item>
            </list>
            <para>
            Test fixture lifecycle:
            </para>
            <list type="number">
            <item>
            First, you'll need create your Xunit test class and have it derive
            from <see cref="T:Xunit.IClassFixture`1"/>, where <c>TFixture</c>
            identifies the fixture.
            </item>
            <item>
            The Xunit test runner reflects the test assemblies and identifies the
            test classes with <c>[Fact]</c> test methods to be executed.
            </item>
            <item>
            For each test class to be executed, the test runner first creates
            an instance of the test fixture.  This is created <b>before</b>
            one before any of the test classes are instantiated and any
            test methods are called.
            </item>
            <item>
            <para>
            The test runner creates a new instance of the test class for each
            test method to be invoked.  The test class constructor must accept
            a single parameter with type <c>TFixture</c>.  The test class 
            constructor should call <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            to initialize the fixture, passing an optional <see cref="T:System.Action"/>
            that does any custom initialization for the test.
            </para>
            <para>
            The <see cref="T:System.Action"/> parameter is generally intended for internal
            use when implementing custom test fixtures.
            </para>
            <para>
            Test fixtures are designed to be aware of whether they've been
            initialized or not such that only the first call to
            <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/> will perform any
            necessary initialization (including calling the custom action)
            and any subsequent calls will do nothing.
            </para>
            <note>
            Some test fixtures may define a different different initialization
            method.
            </note>
            </item>
            <item>
            The test runner will continue instantiating test class instances
            and calling test methods using the test fixture state setup
            during the first test.
            </item>
            <item>
            Once all of the test methods have been called, the test runner
            will call the test fixtures <see cref="M:System.IDisposable.Dispose"/>
            method so that it can clean up any state.
            </item>
            </list>
            </remarks>
            <threadsafety instance="false"/>
        </member>
        <member name="M:Neon.Xunit.ITestFixture.Start(System.Action)">
            <summary>
            Starts the fixture if it hasn't already been started including invoking the optional
            <see cref="T:System.Action"/> when the first time <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/> is called for
            a fixture instance.
            </summary>
            <param name="action">
            <para>
            The optional custom start action.
            </para>
            <note>
            This is generally intended for use when developing custom test fixtures.
            </note>
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="P:Neon.Xunit.ITestFixture.IsRunning">
            <summary>
            Returns <c>true</c> if the fixture has been started.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ITestFixture.Reset">
            <summary>
            <b>INTERNAL USE ONLY:</b> Resets the fixture state.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ITestFixture.OnRestart">
            <summary>
            <para>
            Called when an already started fixture is being restarted.  This provides the
            fixture an opportunity to do some custom initialization.
            </para>
            <note>
            This method is intended only for use by test fixture implementations.  Unit
            tests or test fixtures should never call this directly.
            </note>
            </summary>
        </member>
        <member name="T:Neon.Xunit.KubeServiceFixture`1">
            <summary>
            Fixture for testing a <see cref="T:Neon.Kube.Service.KubeService"/>.
            </summary>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.KubeServiceFixture`1.Service">
            <summary>
            Returns the service instance.
            </summary>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.Start(System.Action)">
            <summary>
            <b>DON'T USE THIS:</b> Use <see cref="M:Neon.Xunit.KubeServiceFixture`1.Start(System.Func{`0},System.TimeSpan)"/> instead for this fixture.
            </summary>
            <param name="action">The initialization action.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.Start(System.Func{`0},System.TimeSpan)">
            <summary>
            Starts the fixture including a <typeparamref name="TService"/> service instance if
            the fixture is not already running.
            </summary>
            <param name="serviceCreator">Callback that creates and returns the new service instance.</param>
            <param name="runningTimeout">
            Optionally specifies the maximum time the fixture should wait for the service to transition
            to the <see cref="F:Neon.Kube.Service.KubeServiceStatus.Running"/> state.  This defaults to <b>30 seconds</b>.
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.TimeoutException">
            Thrown if the service didn't transition to the running (or terminated) state 
            within <paramref name="runningTimeout"/>.
            </exception>
            <remarks>
            <para>
            This method first calls the <paramref name="serviceCreator"/> callback and expects it to
            return a new service instance that has been initialized by setting its environment variables
            and configuration files as required.  The callback should <b>not start</b> the service.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.StartAsComposed(System.Func{`0},System.TimeSpan)">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="serviceCreator">Callback that creates and returns the new service instance.</param>
            <param name="runningTimeout">
            Optionally specifies the maximum time the fixture should wait for the service to transition
            to the <see cref="F:Neon.Kube.Service.KubeServiceStatus.Running"/> state.  This defaults to <b>30 seconds</b>.
            </param>
            <exception cref="T:System.TimeoutException">
            Thrown if the service didn't transition to the running (or terminated) state
            within <paramref name="runningTimeout"/>.
            </exception>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.ClearCaches(System.Boolean)">
            <summary>
            Clears any instance caches.
            </summary>
            <param name="disposing">Optionally indicates that we're clearing because we're disposing the fixture.</param>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.Restart(System.Func{`0},System.TimeSpan)">
            <summary>
            Restarts the service.
            </summary>
            <param name="serviceCreator">Callback that creates and returns the new service instance.</param>
            <param name="runningTimeout">
            Optionally specifies the maximum time the fixture should wait for the service to transition
            to the <see cref="F:Neon.Kube.Service.KubeServiceStatus.Running"/> state.  This defaults to <b>30 seconds</b>.
            </param>
            <exception cref="T:System.TimeoutException">
            Thrown if the service didn't transition to the running (or terminated) state
            within <paramref name="runningTimeout"/>.
            </exception>
            <remarks>
            <para>
            This method first calls the <paramref name="serviceCreator"/> callback and expects
            it to return a new service instance that has been initialized by setting its environment
            variables and configuration files as required.  The callback should not start thge service.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.StopService">
            <summary>
            Stops the service if it's running.
            </summary>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.GetHttpClient(System.String,System.Net.Http.HttpClientHandler)">
            <summary>
            Returns a <see cref="T:System.Net.Http.HttpClient"/> instance configured to communicate with the
            service via the named HTTP/HTTPS endpoint.
            </summary>
            <param name="endpointName">Optionally specifies HTTP/HTTPS endpoint name as defined by the service description (defaults to <see cref="F:System.String.Empty"/>).</param>
            <param name="handler">Optionally specifies a custom HTTP handler.</param>
            <returns>The configured <see cref="T:System.Net.Http.HttpClient"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the named endpoint doesn't exist.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the endpoint protocol is not <see cref="F:Neon.Service.ServiceEndpointProtocol.Http"/>
            or <see cref="F:Neon.Service.ServiceEndpointProtocol.Https"/>.
            </exception>
            <remarks>
            <para>
            The client returned will have it's <see cref="P:System.Net.Http.HttpClient.BaseAddress"/> initialized
            with the URL of the service including the path prefix defined by the endpoint.
            </para>
            <note>
            The client returned will be cached such that subsequent calls will return
            the same client instance for the endpoint.  This cache will be cleared if
            the service fixture is restarted.
            </note>
            <note>
            Do not dispose the client returned since it will be cached by the fixture and
            then be disposed when the fixture is restarted or disposed.  The optional 
            <paramref name="handler"/> passed will also be disposed when fixture will
            also be disposed automatically.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.KubeServiceFixture`1.GetJsonClient(System.String,System.Net.Http.HttpClientHandler)">
            <summary>
            Returns a <see cref="T:Neon.Net.JsonClient"/> instance configured to communicate with the
            service via the named HTTP/HTTPS endpoint.
            </summary>
            <param name="endpointName">Optionally specifies HTTP/HTTPS endpoint name as defined by the service description (defaults to <see cref="F:System.String.Empty"/>).</param>
            <param name="handler">Optionally specifies a custom HTTP handler.</param>
            <returns>The configured <see cref="T:System.Net.Http.HttpClient"/>.</returns>
            <remarks>
            <para>
            The client returned will have it's <see cref="P:System.Net.Http.HttpClient.BaseAddress"/> initialized
            with the URL of the service including the path prefix defined by the endpoint.
            </para>
            <note>
            The client returned will be cached such that subsequent calls will return
            the same client instance for the endpoint.  This cache will be cleared if
            the service fixture is restarted.
            </note>
            <note>
            Do not dispose the client returned since it will be cached by the fixture and
            then be disposed when the fixture is restarted or disposed.  The optional 
            <paramref name="handler"/> passed will also be disposed when fixture will
            also be disposed automatically.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.NatsFixture">
            <summary>
            Used to run a Docker <b>nats</b> container on the current 
            machine as a test fixture while tests are being performed and 
            then deletes the container when the fixture is disposed.
            </summary>
            <remarks>
            <para>
            This fixture assumes that NATS is not currently running on the
            local workstation or as a container named <b>nats-test</b>.
            You may see port conflict errors if either of these conditions 
            are not true.
            </para>
            <para>
            A somewhat safer but slower alternative, is to use the <see cref="T:Neon.Xunit.DockerFixture"/>
            instead and add <see cref="T:Neon.Xunit.NatsFixture"/> as a subfixture.  The 
            advantage is that <see cref="T:Neon.Xunit.DockerFixture"/> will ensure that all
            (potentially conflicting) containers are removed before the NatsFixture
            fixture is started.
            </para>
            <para>
            Use <see cref="M:Neon.Xunit.NatsFixture.Restart"/> to clear the NATS server state by restarting
            its Docker container.  This also returns the new client connection.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="F:Neon.Xunit.NatsFixture.ConnectionUri">
            <summary>
            Returns the URI for a NATS server running locally (probably as a Docker container).
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="P:Neon.Xunit.NatsFixture.Connection">
            <summary>
            Returns the NATS connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.Start(System.String,System.String,System.String[])">
            <summary>
            <para>
            Starts a NATS container if it's not already running.  You'll generally want
            to call this in your test class constructor instead of <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>.
            </para>
            <note>
            You'll need to call <see cref="M:Neon.Xunit.NatsFixture.StartAsComposed(System.String,System.String,System.String[])"/>
            instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            </summary>
            <param name="image">
            Optionally specifies the NATS container image.  This defaults to 
            <b>nkubeio/nats:latest</b> or <b>nkubedev/nats:latest</b> depending 
            on whether the assembly was built from a git release branch or not.
            </param>
            <param name="name">Optionally specifies the NATS container name (defaults to <c>nats-test</c>).</param>
            <param name="args">Optional NATS server command line arguments.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.StartAsComposed(System.String,System.String,System.String[])">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="image">
            Optionally specifies the NATS container image.  This defaults to 
            <b>nkubeio/nats:latest</b> or <b>nkubedev/nats:latest</b> depending
            on whether the assembly was built from a git release branch or not.
            </param>
            <param name="name">Optionally specifies the container name (defaults to <c>nats-test</c>).</param>
            <param name="args">Optional NATS server command line arguments.</param>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.Restart">
            <summary>
            Restarts the NATS container to clear any previous state and returns the 
            new client connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.Reset">
            <summary>
            This method completely resets the fixture by removing and recreating
            the NATS container.
            </summary>
        </member>
        <member name="T:Neon.Xunit.NatsStreamingFixture">
            <summary>
            Used to run a Docker <b>nats-streaming</b> container on the current 
            machine as a test fixture while tests are being performed and 
            then deletes the container when the fixture is disposed.
            </summary>
            <remarks>
            <para>
            This fixture assumes that NATS-SERVER is not currently running on the
            local workstation or as a container named <b>nats-test</b>.
            You may see port conflict errors if either of these conditions 
            are not true.
            </para>
            <para>
            A somewhat safer but slower alternative, is to use the <see cref="T:Neon.Xunit.DockerFixture"/>
            instead and add <see cref="T:Neon.Xunit.NatsStreamingFixture"/> as a subfixture.  The 
            advantage is that <see cref="T:Neon.Xunit.DockerFixture"/> will ensure that all
            (potentially conflicting) containers are removed before the NatsFixture
            fixture is started.
            </para>
            <para>
            Use <see cref="M:Neon.Xunit.NatsStreamingFixture.Restart"/> to clear the NATS-SATREAMIN server state by
            restarting its Docker container.  This also returns the new client 
            connection.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="P:Neon.Xunit.NatsStreamingFixture.Connection">
            <summary>
            Returns the NATS-STREAMING connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Start(System.String,System.String,System.String[])">
            <summary>
            <para>
            Starts a NATS-STREAMING container if it's not already running.  You'll generally want
            to call this in your test class constructor instead of <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>.
            </para>
            <note>
            You'll need to call <see cref="M:Neon.Xunit.NatsStreamingFixture.StartAsComposed(System.String,System.String,System.String[])"/>
            instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            </summary>
            <param name="image">
            Optionally specifies the NATS-STREAMING container image.  This defaults to 
            <b>nkubeio/nats-streaming:latest</b> or <b>nkubedev/nats-streaming:latest</b>
            depending on whether the assembly was built from a git release branch
            or not.
            </param>
            <param name="name">Optionally specifies the NATS-STREAMING container name (defaults to <c>nats-streaming-test</c>).</param>
            <param name="args">Optional NATS-STREAMING server command line arguments.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.StartAsComposed(System.String,System.String,System.String[])">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="image">
            Optionally specifies the NATS container image.  This defaults to 
            <b>nkubeio/nats-streaming:latest</b> or <b>nkubedev/nats-streaming:latest</b>
            depending on whether the assembly was built from a git release branch
            or not.
            </param>
            <param name="name">Optionally specifies the container name (defaults to <c>nats-streaming-test</c>).</param>
            <param name="args">
            <para>
            Optional NATS-STREAMING server command line arguments.
            </para>
            <note>
            Reasonable defaults are used when <paramref name="args"/> is passed 
            as <c>null</c>.  These connect the NATS streaming server to the NATS
            core server running within the container and also configure the
            default MEMORY persisted store.
            </note>
            </param>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Connect">
            <summary>
            Establishes the server connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Restart">
            <summary>
            Restarts the NATS container to clear any previous state and returns the 
            new client connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Reset">
            <summary>
            This method completely resets the fixture by removing and recreating
            the NATS-STREAMING container.
            </summary>
        </member>
        <member name="T:Neon.Xunit.TestFixture">
            <summary>
            Abstract test fixture base class.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Couchbase Docker container, modifying the local DNS <b>hosts</b>
            file or managing a Docker Swarm or cluster.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file with:
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            </para>
            </note>
            <para>
            Test fixtures that modify global machine or other environmental state must
            implement a <c>public static void EnsureReset()</c> method resets the state
            to reasonable defaults.  These will be reflected and called when the first
            <see cref="T:Neon.Xunit.TestFixture"/> is created by the test runner for every test class.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="F:Neon.Xunit.TestFixture.resetMethods">
            <summary>
            Holds any reflected <c>public static void EnsureReset()</c> from any
            <see cref="T:Neon.Xunit.TestFixture"/> implementations.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.EnsureReset">
            <summary>
            Resets the state of any reflected fixture implementations.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestFixture.RefCount">
            <summary>
            Used to track whether <see cref="M:Neon.Xunit.TestFixture.EnsureReset"/> should be called when
            the first test fixture is created or when the last one is disposed.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestFixture.IsDisposed">
            <summary>
            Returns <c>true</c> if the instance has been disposed.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestFixture.InAction">
            <summary>
            Returns <c>true</c> if the <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/> method
            is running.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestFixture.IsRunning">
            <summary>
            Returns <c>true</c> if the fixture has been initialized.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.CheckDisposed">
            <summary>
            Verifies that the fixture instance has not been disposed.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.CheckWithinAction">
            <summary>
            Verifies that the fixture instance's <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/>
            method is executing.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Start(System.Action)">
            <summary>
            Starts the fixture if it hasn't already been started including invoking the optional
            <see cref="T:System.Action"/> when the first time <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/> is called for
            a fixture instance.
            </summary>
            <param name="action">The optional custom start action.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this is called from within the <see cref="T:System.Action"/>.</exception>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestFixture.OnRestart">
            <summary>
            <para>
            Called when an already started fixture is being restarted.  This provides the
            fixture an opportunity to do some custom initialization.  This base method
            does nothing.
            </para>
            <note>
            This method is intended only for use by test fixture implementations.  Unit
            tests or test fixtures should never call this directly.
            </note>
            </summary>
        </member>
        <member name="T:Neon.Xunit.TestFixtureStatus">
            <summary>
            Returned by <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/> to indicate whether
            the test fixture was just started or was already running.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestFixtureStatus.Started">
            <summary>
            The fixture was just started.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning">
            <summary>
            The fixture was already running.
            </summary>
        </member>
        <member name="T:Neon.Xunit.IncompatibleServiceException">
            <summary>
            Thrown by <see cref="M:Neon.Xunit.XunitExtensions.ValidateController``1(Neon.Data.IGeneratedServiceClient)"/> when
            the service type doesn't match a generated service client.
            </summary>
        </member>
        <member name="M:Neon.Xunit.IncompatibleServiceException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="T:Neon.Xunit.MockHttpServer">
            <summary>
            <para>
            Implements a very lightweight HTTP server suitable for locally
            mocking a service.
            </para>
            <note>
            This currently runs only on Windows.
            </note>
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.MockHttpServer.#ctor(System.String,System.Func{Microsoft.Net.Http.Server.RequestContext,System.Threading.Tasks.Task})">
            <summary>
            Constuctor.
            </summary>
            <param name="urlPrefix">Specifies the URL prefixes to be served.</param>
            <param name="handler">The custom asynchronous request handler.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServer.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.MockHttpServer.RequestProcessor">
            <summary>
            Handles received requests.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Xunit.MockHttpServerExtensions">
            <summary>
            Misc extsnsions.
            </summary>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.QueryGet(Microsoft.Net.Http.Server.Request,System.String)">
            <summary>
            Returns the value of a request query argument.
            </summary>
            <param name="request">The request.</param>
            <param name="name">The query argument name.</param>
            <returns>The argument value or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.GetBodyText(Microsoft.Net.Http.Server.Request)">
            <summary>
            Returns a request body payload as text.
            </summary>
            <param name="request">The request.</param>
            <returns>The body text.</returns>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.Write(Microsoft.Net.Http.Server.Response,System.Byte[])">
            <summary>
            Writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.Write(Microsoft.Net.Http.Server.Response,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to be written.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.Write(Microsoft.Net.Http.Server.Response,System.String)">
            <summary>
            Writes a string to an HTTP response using UTF-8 encoding.
            </summary>
            <param name="response">The response.</param>
            <param name="text">The text to be written.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.WritAsynce(Microsoft.Net.Http.Server.Response,System.Byte[])">
            <summary>
            Asynchronously writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.WriteAsync(Microsoft.Net.Http.Server.Response,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Asynchronously writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to be written.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.WriteAsync(Microsoft.Net.Http.Server.Response,System.String)">
            <summary>
            Asynchronously writes a string to an HTTP response using UTF-8 encoding.
            </summary>
            <param name="response">The response.</param>
            <param name="text">The text to be written.</param>
        </member>
        <member name="T:Neon.Xunit.Program">
            <summary>
            We apparently need a main program entry when building with the 
            <b>Microsoft.NET.Sdk.Web</b> SDK.  We'll fake one here.
            </summary>
        </member>
        <member name="M:Neon.Xunit.Program.Main(System.String[])">
            <summary>
            Fake program entry point.
            </summary>
            <param name="args">Command line arguments.</param>
            <returns>The exit code.</returns>
        </member>
        <member name="T:Neon.Xunit.TestCategory">
            <summary>
            Defines constants used to help categorize unit tests and avoid
            spelling errors and inconsistencies.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.CategoryTrait">
            <summary>
            Identifies the trait.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.Sample">
            <summary>
            Identifies sample tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonCadence">
            <summary>
            Identifies <b>Neon.Cadence</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonCodeGen">
            <summary>
            Identifies <b>Neon.CodeGen</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonCommon">
            <summary>
            Identifies <b>Neon.Common</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonCryptography">
            <summary>
            Identifies <b>Neon.Cryptography</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonKube">
            <summary>
            Identifies <b>Neon.Kube</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonCouchbase">
            <summary>
            Identifies <b>Neon.Couchbase</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonCli">
            <summary>
            Identifies <b>neon-cli</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonDesktop">
            <summary>
            Identifies <b>neon-desktop</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonXunit">
            <summary>
            Identifies <b>neon-xunit</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCategory.NeonWeb">
            <summary>
            Identifies <b>Neon.Web</b> tests.
            </summary>
        </member>
        <member name="T:Neon.Xunit.TestContext">
            <summary>
            Holds information like settings and test files for unit tests.
            </summary>
            <remarks>
            <para>
            This class is pretty easy to use.  Simply construct an instance, perform any
            desired initialization such as reading files (potentionally encypted) and
            configuring variables/settings.  Then your tests can reference this via
            the static <see cref="P:Neon.Xunit.TestContext.Current"/> property.
            </para>
            <para>
            You'll generally construct one of these instances at the beginning of your
            test method or within a test fixture.  Only one <see cref="T:Neon.Xunit.TestContext"/>
            may be active at any given time, so remember to call <see cref="M:Neon.Xunit.TestContext.Dispose"/>
            when your test run is commplete.
            </para>
            <para>
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Xunit.TestContext.Current">
            <summary>
            Returns the cuurent <see cref="T:Neon.Xunit.TestContext"/> or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestContext.#ctor">
            <summary>
            Constructor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if another <see cref="T:Neon.Xunit.TestContext"/> already exists.</exception>
            <remarks>
            <note>
            Only one <see cref="T:Neon.Xunit.TestContext"/> instance may exist at any time.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.TestContext.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Xunit.TestContext.Settings">
            <summary>
            Returns a case senstive dictionary mapping setting names to object values.
            You can use this to pass settings and other information to tests.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestContext.Files">
            <summary>
            Returns a case sensitive dictionary mapping file names to byte arrays 
            with the file contents.  You can use this to pass file data to tests.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestContext.LoadSettings(System.String,System.Func{System.String,System.String})">
            <summary>
            <para>
            Loads settings formatted as <c>NAME=VALUE</c> from a text file into the
            <see cref="P:Neon.Xunit.TestContext.Settings"/> dictionary.  The file will be decrypted using
            <see cref="T:Neon.Cryptography.NeonVault"/> if necessary.
            </para>
            <note>
            Blank lines and lines beginning with '#' will be ignored.
            </note>
            </summary>
            <param name="path">The input file path.</param>
            <param name="passwordProvider">
            Optionally specifies the password provider function to be used to locate the
            password required to decrypt the source file when necessary.  The password will 
            use the <see cref="M:Neon.Kube.KubeHelper.LookupPassword(System.String)"/> method when 
            <paramref name="passwordProvider"/> is <c>null</c>.
            </param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file doesn't exist.</exception>
            <exception cref="T:System.FormatException">Thrown for file formatting problems.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.LoadEnvironment(System.String,System.Func{System.String,System.String})">
            <summary>
            <para>
            Loads environment variables formatted as <c>NAME=VALUE</c> from a text file into environment
            variables.  The file will be decrypted using <see cref="T:Neon.Cryptography.NeonVault"/> if necessary.
            </para>
            <note>
            Blank lines and lines beginning with '#' will be ignored.
            </note>
            </summary>
            <param name="path">The input file path.</param>
            <param name="passwordProvider">
            Optionally specifies the password provider function to be used to locate the
            password required to decrypt the source file when necessary.  The password will 
            use the <see cref="M:Neon.Kube.KubeHelper.LookupPassword(System.String)"/> method when 
            <paramref name="passwordProvider"/> is <c>null</c>.
            </param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file doesn't exist.</exception>
            <exception cref="T:System.FormatException">Thrown for file formatting problems.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.LoadFile(System.String,System.Func{System.String,System.String})">
            <summary>
            Loads a file into the <see cref="P:Neon.Xunit.TestContext.Files"/> dictionary, using the file name
            (without the directory path) as the key.  The file will be decrypted via
            <see cref="T:Neon.Cryptography.NeonVault"/> as necessary.
            </summary>
            <param name="path">The file path.</param>
            <param name="passwordProvider">
            Optionally specifies the password provider function to be used to locate the
            password required to decrypt the source file when necessary.  The password will 
            use the <see cref="M:Neon.Kube.KubeHelper.LookupPassword(System.String)"/> method when 
            <paramref name="passwordProvider"/> is <c>null</c>.
            </param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file doesn't exist.</exception>
            <exception cref="T:System.FormatException">Thrown for file formatting problems.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.GetFileBytes(System.String)">
            <summary>
            Returns the raw bytes for the named file from the <see cref="P:Neon.Xunit.TestContext.Files"/>
            dictionary.
            </summary>
            <param name="filename">The file name.</param>
            <returns>The file bytes.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the file doesn't exist.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.GetFileText(System.String,System.Text.Encoding)">
            <summary>
            Returns the text for the named file from the <see cref="P:Neon.Xunit.TestContext.Files"/>.
            dictionary.
            </summary>
            <param name="filename">The file name.</param>
            <param name="encoding">The encoding to be used (defaults to <see cref="P:System.Text.Encoding.UTF8"/>).</param>
            <returns>The file text.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the file doesn't exist.</exception>
        </member>
        <member name="T:Neon.Xunit.TestHelper">
            <summary>
            Misc local unit test helpers.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestHelper.CreateTestFolder(System.Tuple{System.String,System.String}[])">
            <summary>
            Creates and optionally populates a temporary test folder with test files.
            </summary>
            <param name="files">
            The files to be created.  The first item in each tuple entry will be 
            the local file name and the second the contents of the file.
            </param>
            <returns>The <see cref="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)"/>.</returns>
            <remarks>
            <note>
            Ensure that the <see cref="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)"/> returned is disposed so it and
            any files within will be deleted.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)">
            <summary>
            Creates and populates a temporary test folder with a test file.
            </summary>
            <param name="data">The file name</param>
            <param name="filename">The file data.</param>
            <returns>The <see cref="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)"/>.</returns>
            <remarks>
            <note>
            Ensure that the <see cref="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)"/> returned is disposed so it and
            any files within will be deleted.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Ensures that two enumerations contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order.  This uses the default equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Ensures that two enumerations do not contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order.  This uses the default equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Ensures that two enumerations contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order using an equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <param name="comparer">The comparer used to equate objects in the collection with the expected object</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Ensures that two enumerations do not contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order using an equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <param name="comparer">The comparer used to equate objects in the collection with the expected object</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Ensures that two dictionaries contain the same items using the default equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Ensures that two dictionaries do not contain the same items using the default equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Ensures that two dictionaries contain the same items using an equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <param name="comparer">The equality comparer to be used.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Ensures that two dictionaries do not contain the same items using an equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <param name="comparer">The equality comparer to be used.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEqualLines(System.String,System.String)">
            <summary>
            Compares two strings such that platform line ending differences will be
            ignored.  This works by removing any embedded carriage returns before
            performing the comparision.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="actual">The actual valut.</param>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertThrows``1(System.Action)">
            <summary>
            Verifies that an action throws a <typeparamref name="TException"/> or an
            <see cref="T:System.AggregateException"/> that contains <typeparamref name="TException"/>.
            </summary>
            <typeparam name="TException">The required exception type.</typeparam>
            <param name="action">The test action.</param>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertThrowsAsync``1(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Verifies that an asynchronous action throws a <typeparamref name="TException"/> or an
            <see cref="T:System.AggregateException"/> that contains <typeparamref name="TException"/>.
            </summary>
            <typeparam name="TException">The required exception type.</typeparam>
            <param name="action">The test action.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHelper.RunFixture``1(System.Object[])">
            <summary>
            Used to run a <see cref="T:Neon.Xunit.TestFixture"/> outside of a unit test.
            </summary>
            <typeparam name="T">Specifies the test type.</typeparam>
            <param name="args">
            Optional parameters that will be passed to the constructor after the
            fixture parameter.  Note that the number of parameters and their types
            must match the constructor parameters after the fixture one.
            </param>
            <remarks>
            <para>
            This is often used to run a <see cref="T:Neon.Kube.Service.KubeService"/> using <see cref="T:Neon.Xunit.KubeServiceFixture`1"/>
            or a collection of <see cref="T:Neon.Kube.Service.KubeService"/> instances for debugging purposes using a combination
            of a <see cref="T:Neon.Xunit.ComposedFixture"/> with <see cref="T:Neon.Xunit.KubeServiceFixture`1"/> sub-fixtures.
            But, this can also be used for any <see cref="T:Neon.Xunit.ITestFixture"/> implementation.
            </para>
            <para>
            You'll need to implement a test class that derives from a <see cref="T:Xunit.IClassFixture`1"/>
            implementation and optionally implements <see cref="T:System.IDisposable"/>.  You'll pass
            your test type as <typeparamref name="T"/>.  Your test class must include a public
            constructor that accepts a single parameter with the test fixture type and
            a public method with no parameters called <c>public void Run()</c>.
            </para>
            <para>
            This will look something like:
            </para>
            <code language="C#">
            public class MyTestRunner : IClassFixture&lt;ComposedFixture&gt;
            {
                private ComposedFixture                     composedFixture;
                private NatsFixture                         natsFixture;
                private KubeServiceFixture&lt;QueueService&gt;    queueServiceFixture;
            
                public MyTestRunner(ComposedFixture fixture)
                {
                    this.composedFixture = fixture;
            
                    composedFixture.Start(
                        () =>
                        {
                            composedFixture.AddFixture("nats", new NatsFixture(),
                                natsFixture =>
                                {
                                   natsFixture.StartAsComposed();
                                });
            
                            composedFixture.AddServiceFixture("queue-service", new KubeServiceFixture&lt;QueueService&gt;(), () => CreateQueueService());
                        });
            
                    this.natsFixture         = (NatsFixture)composedFixture["nats"];
                    this.queueServiceFixture = (KubeServiceFixture&lt;QueueService&gt;)composedFixture["queue-service"];
                }
                
                public void Run()
                {
                    // The runner will stop when this method returns.  You can
                    // also use this as an opportunity to perform any initialization.
                    // For this example, we're just going to spin slowly forever.
                    
                    while (true)
                    {
                        System.Threading.Thread.Sleep(10000);
                    }
                }
            }
            </code>
            <para>
            This method performs these steps:
            </para>
            <list type="number">
                <item>
                Perform a runtime check to verify that <typeparamref name="T"/> has a public constructor
                that accepts a single parameter of type <typeparamref name="T"/> as well as any additional
                parameters.
                </item>
                <item>
                Perform a runtime check to ensure that <typeparamref name="T"/> has a <c>public void Run()</c>
                method.
                </item>
                <item>
                Instantiate an instance of the test fixture specified by <see cref="T:Xunit.IClassFixture`1"/>.
                </item>
                <item>
                Instantiate an instance of <typeparamref name="T"/>, passing the test fixture just created
                as the parameter.
                </item>
                <item>
                Call the <c>Run()</c> method and wait for it to return.
                </item>
                <item>
                Dispose the test fixture.
                </item>
                <item>
                Call <see cref="M:System.IDisposable.Dispose"/>, if implemented by the test class.
                </item>
                <item>
                The method returns.
                </item>
            </list>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.TestHttpClient">
            <summary>
            Implements a <see cref="T:System.Net.Http.HttpClient"/> compatible client with additional capabilities,
            like disabling connection reuse.  This is intended for unit testing purposes like
            verifying that load balancing actually works.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.#ctor(System.Boolean,System.Net.Http.HttpMessageHandler,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="disableConnectionReuse">Indicates whether connection reuse should be disabled.</param>
            <param name="handler">Optionally specifies a message handler.</param>
            <param name="disposeHandler">Optionally specifies that the handler should be disposed when this instance is disposed.</param>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetClient">
            <summary>
            Returns the client, ensuring that it hasn't been disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown when the instance is disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetSingleUseClient">
            <summary>
            Returns a single-use client.
            </summary>
            <returns>The client.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown when the instance is disposed.</exception>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.DefaultRequestHeaders">
            <summary>
            The headers that should be sent with each request.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.BaseAddress">
            <summary>
            The base address that to be used when sending requests.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.MaxResponseContentBufferSize">
            <summary>
            the maximum number of bytes to buffer when reading the response content.
            This defaults to 2GiB.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.Timeout">
            <summary>
            The maximum time allowed before a request times out.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.Uri)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.String)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String,System.Net.Http.HttpCompletionOption)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The copmpletion options.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The copmpletion options.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri,System.Net.Http.HttpCompletionOption)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The completion option.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The completion option.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetByteArrayAsync(System.String)">
            <summary>
            Performs a <b>GET</b> request and returns the response contents as a byte array.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The content bytes.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetByteArrayAsync(System.Uri)">
            <summary>
            Performs a <b>GET</b> request and returns the response contents as a byte array.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The content bytes.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStreamAsync(System.String)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a stream.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response stream..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStreamAsync(System.Uri)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a stream.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response stream..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStringAsync(System.String)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a string.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response string..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStringAsync(System.Uri)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a string.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response string..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.String,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.String,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.Uri,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.Uri,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.String,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.String,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.Uri,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.Uri,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpCompletionOption)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <param name="completionOption">The completion option.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <param name="completionOption">The completion option.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="T:Neon.Xunit.TestOutputWriter">
             <summary>
             <para>
             Wraps an <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> with a <see cref="T:System.IO.TextWriter"/> that can
             be used generate output in unit tests that will be included in the captured test log.
             </para>
             <note>
             Only the <c>WriteLine(...)</c> methods are implemented.
             </note>
             </summary>
             <exception cref="T:System.NotImplementedException">Thrown for all methods except for  <c>WriteLine()</c>.</exception>
             <remarks>
             <para>
             To use this class, you'll need to obtain a <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> instance from Xunit via 
             dependency injection by adding a parameter to your test constructor and then creating a
             <see cref="T:Neon.Xunit.TestOutputWriter"/> from it, like:
             </para>
             <code language="c#">
             public class MyTest : IClassFixture&lt;AspNetFixture&gt;
             {
                 private AspNetFixture               fixture;
                 private TestAspNetFixtureClient     client;
                 private TestOutputWriter            testWriter;
            
                 public Test_EndToEnd(AspNetFixture fixture, ITestOutputHelper outputHelper)
                 {
                     this.fixture    = fixture;
                     this.testWriter = new TestOutputWriter(outputHelper);
            
                     fixture.Start&lt;Startup&gt;(logWriter: testWriter, logLevel: Neon.Diagnostics.LogLevel.Debug);
            
                     client = new TestAspNetFixtureClient()
                     {
                         BaseAddress = fixture.BaseAddress
                     };
                  }
             }
             </code>
             </remarks>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.#ctor(Xunit.Abstractions.ITestOutputHelper)">
            <summary>
            Constructor.
            </summary>
            <param name="outputHelper">The test output helper.</param>
        </member>
        <member name="P:Neon.Xunit.TestOutputWriter.Encoding">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.FlushAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Char[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteAsync(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Char[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Xunit.XunitExtensions">
            <summary>
            Unit test related extensions.
            </summary>
        </member>
        <member name="M:Neon.Xunit.XunitExtensions.ValidateController``1(Neon.Data.IGeneratedServiceClient)">
            <summary>
            <para>
            Compares the service model implemented by the generated service client against
            the actual ASP.NET service controller implementation.  This ensures that the
            generated client actually matches the controller implementation.
            </para>
            <note>
            <b>IMPORTANT:</b> You should always include a call to this in your service unit
            tests to ensure that the service models used to generate the service clients 
            actually match the service as implemented.  It is very likely for definitions
            and implementations to diverge over time.
            </note>
            </summary>
            <typeparam name="TServiceController">The service controller implementation type.</typeparam>
            <param name="client">The service client implementation being tested.</param>
            <exception cref="T:Neon.Xunit.IncompatibleServiceException">Thrown when the service implementaton doesn't match the generated client.</exception>
        </member>
        <member name="M:Neon.Xunit.XunitExtensions.GetMethodSignature(System.Reflection.MethodInfo,System.String,System.String,System.Boolean)">
            <summary>
            Generates a method signature for a <see cref="T:System.Reflection.MethodInfo"/> and route template.
            </summary>
            <param name="method">The method information.</param>
            <param name="httpMethod">The HTTP method required for the method call.</param>
            <param name="routeTemplate">The route template.</param>
            <param name="requireGeneratedParamAttribute">
            Indicates that only parameters tagged with <c>[GeneratedParam]</c> will be
            included in the signature.
            </param>
            <returns>The method signature.</returns>
        </member>
        <member name="M:Neon.Xunit.XunitExtensions.NormalizeType(System.Type)">
            <summary>
            Normalizes types to strings including converting <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> 
            types to <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="type">The input type.</param>
            <returns>The normalized type rendered as a string.</returns>
        </member>
    </members>
</doc>
